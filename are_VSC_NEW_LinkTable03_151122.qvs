///$tab Main
SET ThousandSep='’';
SET DecimalSep='.';
SET MoneyThousandSep='’';
SET MoneyDecimalSep='.';
SET MoneyFormat='CHF #’##0.00;CHF-#’##0.00';
SET TimeFormat='hh:mm:ss';
SET DateFormat='DD.MM.YYYY';
SET TimestampFormat='DD.MM.YYYY hh:mm:ss[.fff]';
SET FirstWeekDay=0;
SET BrokenWeeks=0;
SET ReferenceDay=4;
SET FirstMonthOfYear=1;
SET CollationLocale='de-CH';
SET MonthNames='Jan.;Feb.;März;Apr.;Mai;Juni;Juli;Aug.;Sep.;Okt.;Nov.;Dez.';
SET LongMonthNames='Januar;Februar;März;April;Mai;Juni;Juli;August;September;Oktober;November;Dezember';
SET DayNames='Mo.;Di.;Mi.;Do.;Fr.;Sa.;So.';
SET LongDayNames='Montag;Dienstag;Mittwoch;Donnerstag;Freitag;Samstag;Sonntag';
SET NumericalAbbreviation='3:Tsd.;6:Mio.;9:Mia.;12:Bio.;15:P;18:E;21:Z;24:Y;-3:m;-6:μ;-9:n;-12:p;-15:f;-18:a;-21:z;-24:y';
Set CreateSearchIndexOnReload=0;

Trace ***** SkriptStart *****;

//****************************************** Module **********************************************************************************

// SET vModule = 0243_UBS_AM_PREV;
// SET vModule = 0239_Ruby_WP_PREV;
// SET vModule = 0254_UBS_AM_TEST;
// SET vModule = 0312_MasterApp_Ruby_are;
//  SET vModule = 9999_Itec_vap;
 SET vModule = 0259_UBS_PREV_Pre;
// SET vModule = 0304_API_hsc;

// LET vStore = 'qlik-local/BI/' & '$(vModule)';
LET vStore = '$(vModule)';

LET vModuleCloud = '$(vModule)';

TRACE vModule: $(vModule);
TRACE vStore: $(vStore);
TRACE vModuleCloud: $(vModuleCloud);

// //***************************Variablen definieren via Konfigurationsfile***************************//
Variablen:
LOAD
    Name,
    "$(vModule)"
FROM [lib://0100_Global/04_Datasource/04_Excel/Konfigurationsfile.xlsx]
(ooxml, embedded labels, table is Variablen)
where isnull("$(vModule)") <> -1 
and RF_03 = 1;


FOR i = 0 to NoOfRows('Variablen')-1

	Let vName = peek('Name', i,'Variablen');
	Let $(vName) = peek('$(vModule)', i,'Variablen');

NEXT i 


If '$(vSchnittstelleAbrechnung)' = 'Ja' then
set vAbrechnungsquelle = 'AbrechnungBudgetVerwaltung';
else 
set vAbrechnungsquelle = 'AbrechnungBudget';
end if;


//****************************************** Anzahl zu ladende Perioden (immer in Schicht 04 anpassen!) ********************************
nPerioden:
	Load *
FROM [lib://$(vStore)/Protokoll_API/nPerioden.qvd]  // leave it on WebDav for more control
(qvd);
Let nPeriods = peek('nPerioden',0,'nPerioden');

Drop Table nPerioden;


//****************************************** Bewertungsmethode **********************************************************************************
SET vBewertungsmethode = DCF; //Angabe der Bewertungsmethode


//****************************************** Set Variables ***************************************************************************
SET vqvdPrefixMD =  'RF_MD';
SET vqvdPrefixST =  'RF_ST';
SET vqvdPrefixMP =  'RF_MP';
SET vqvdPrefixTR =  'RF_TR';

Drop Table Variablen;

Trace $(nPeriods);

Set vMonateRem = 12;


///$tab VAR-Definition
//************ Set Working Variables **************//

LET vKeepDM = '1';   // keep the Data-Model in the App (Testing App) or switch it off (Live App)
// LET vStoreCsv = '0';  // only for an old Use-Case (storing the Files in CSV in order to convert them in Python for Postgres)

LET vKeySep = '|';   // global separator for the keys in order to have always the same "pipe" sign

LET vQvdStoreDebug = '1';   // switch on the Debug-File generation

LET vSrcDateFormat = 'YYYY-MM-DD';

SET vCurrentDate = today();
SET vCurrentYear = year($1);
SET vCurrentMonth = num(month($1));

if $(vCurrentMonth) < 10 then
	SET vCurrentMonth = '0' & $(vCurrentMonth);
else
	SET vCurrentMOnth = $(vCurrentMonth);
    
end if

SET vFormatDate = Date(Date#($1, '$(vSrcDateFormat)'), '$(DateFormat)');
SET vLoadDate = now();

LET vIVM_MinStartDate = '01.01.2000';


SET vSourcePath = 'lib://$(vStore)/04_Datasource/01_qvd/';
SET vSourcePath06 = 'lib://$(vStore)/04_Datasource/06_qvd_api/';

//  SET vSourcePath = 'lib://$(vModule)/04_Datasource/01_qvd/';
//  SET vSourcePath06 = 'lib://$(vModule)/04_Datasource/06_qvd_api/';

 SET vStorePath = 'lib://$(vStore)/03_Refinement/01_qvd/Ruby_new_DM/Test\';
// SET vStorePath = 'lib://$(vStore)/03_Refinement/01_qvd/Ruby_new_DM/';

SET vCSVPath = 'lib://$(vStore)/04_Datasource/03_csv/';

SET vMonthDiff = Num(((year($2) * 12) + month($2)) - (((year($1) * 12) + month($1))) + 1);

//are: 10/11/2022 wurde ausgeschaltet und wir nicht mehr benötigt - reaktivated temporarily 15/11/22
//Store Ruby Mapping into QVD
KontoMapping_UBS_Ruby:
LOAD
   *
FROM [lib://$(vModuleCloud)/04_Datasource/05_Kunde/Konto_Mapping_Detailed.xlsx]
(ooxml, embedded labels, table is Uebersetzung_KeyFigures);

Store KontoMapping_UBS_Ruby Into [$(vStorePath)SpezialKontoMapping_Ruby.qvd](qvd);
Drop Table KontoMapping_UBS_Ruby;


// Wird für die Dimensions-Kontostruktur immer noch benötigt, der Endpunkt /ws/account-plans gibt keine "Valuation" AccountType Struktur zurück
// Store Kontozusatzinformationen into QVD
KontoZusatzinformationen:
LOAD
   *
FROM [lib://0100_Global/04_Datasource\04_Excel\Kontozusatzinformationen.xlsx]
(ooxml, embedded labels, table is Tabelle2);

Store KontoZusatzinformationen Into [$(vStorePath)KontoZusatzinformationen.qvd](qvd);
Drop Table KontoZusatzinformationen;


// ************** Define Functions ******************* //

// Store Qvd-Files
SUB QvdStore (pTableName, pQvdPath, pQvdPrefix, pQvdName, pFields, pDropIt)

	// Parameter übernehmen		
	LET vQvdStoreTableName = pTableName;
	// Wenn der Tabellenname leer ist -> abbrechen
	IF (IsNull (vQvdStoreTableName)) OR (Len ('$(vQvdStoreTableName)') = 0) THEN
		EXIT SUB;
	ENDIF
    LET vQvdPath = pQvdPath;
	IF (IsNull (vQvdPath)) OR (Len ('$(vQvdPath)') = 0) THEN
		LET vQvdPath = vStorePath;
	ENDIF
    LET vQvdPrefix = pQvdPrefix;
	IF (IsNull (vQvdPrefix)) OR (Len ('$(vQvdPrefix)') = 0) THEN
		LET vQvdPrefix = vqvdPrefixMD;
	ENDIF
	LET vQvdStoreQvdName = pQvdName;
	IF (IsNull (vQvdStoreQvdName)) OR (Len ('$(vQvdStoreQvdName)') = 0) THEN
		LET vQvdStoreQvdName = vQvdStoreTableName;
	ENDIF
	LET vQvdStoreQvdFileName 	= pQvdPath & pQvdPrefix & '-' & pQvdName & '.QVD';
	// Felder bereinigen
	LET vQvdStoreFields = pFields;
	IF (IsNull (vQvdStoreFields)) OR (Len ('$(vQvdStoreFields)') = 0) THEN
		LET vQvdStoreFields = '*';
	ENDIF
	// Das bei der Parameterübergabe die '-Zeichen zu " umgewandelt werden, 
	// muss ein eigenes Zeichen für "String-Werte" verwendet werden.
	LET vQvdStoreFields = replace (vQvdStoreFields,'""', chr(39));
	// Hier die Daten in die Datei speichern
	TRACE ---> STORING TABLE $(vQvdStoreTableName) INTO $(vQvdStoreQvdFileName);
	STORE $(vQvdStoreFields) FROM "$(vQvdStoreTableName)" INTO '$(vQvdStoreQvdFileName)' (qvd);
		
	IF (not IsNull (pDropIt)) and (pDropIt <> 0) THEN
		call dropTable ('$(vQvdStoreTableName)');
	ENDIF
	
END SUB

// Store Qvd-Files
// Dieses Flag steuert die funktion QvdStoreDebug. 
// Sie kann im script oder im UI der entsprechenden App gesetzt werden.
// Default ist aus
LET vQvdStoreDebug = if (IsNull(vQvdStoreDebug), 0, vQvdStoreDebug); 
SUB QvdStoreDebug (pTableName, pQvdPath, pQvdName, pFields)

    if (vQvdStoreDebug=0) then
        Exit sub;
    endif

	LET vQvdName = if (len (pQvdName)=0, pTableName, pQvdName);
    LET vQvdPath = pQvdPath & 'Debug';
	LET vQvdFullFileName = vQvdPath & '\' & vQvdName & '.qvd';
	STORE '$(pTableName)' INTO [$(vQvdFullFileName)] (qvd);
END SUB


// Store Csv-Files
SUB QvdToCsv (pTableName, pQvdPath, pQvdName, pFields, pDropIt)
	
    // Parameter übernehmen		
	LET vQvdToCsvTableName = pTableName;
	// Wenn der Tabellenname leer ist -> abbrechen
	IF (IsNull (vQvdToCsvTableName)) OR (Len ('$(vQvdToCsvTableName)') = 0) THEN
		EXIT SUB;
	ENDIF
    LET vQvdToCsvPath = pQvdPath;
	IF (IsNull (vQvdToCsvPath)) OR (Len ('$(vQvdToCsvPath)') = 0) THEN
		LET vQvdToCsvPath = vCSVPath;
	ENDIF
	LET vQvdToCsvQvdName = pQvdName;
	IF (IsNull (vQvdToCsvQvdName)) OR (Len ('$(vQvdToCsvQvdName)') = 0) THEN
		LET vQvdToCsvQvdName = vQvdToCsvTableName;
	ENDIF
	LET vQvdToCsvQvdFileName 	= pQvdPath & pQvdName & '.csv';
    	// Felder bereinigen
	LET vQvdToCsvFields = pFields;
	IF (IsNull (vQvdToCsvFields)) OR (Len ('$(vQvdToCsvFields)') = 0) THEN
		LET vQvdToCsvFields = '*';
	ENDIF
	// Das bei der Parameterübergabe die '-Zeichen zu " umgewandelt werden, 
	// muss ein eigenes Zeichen für "String-Werte" verwendet werden.
	LET vQvdToCsvFields = replace (vQvdToCsvFields,'""', chr(39));
	// Hier die Daten in die Datei speichern
	TRACE ---> STORING TABLE $(vQvdToCsvTableName) INTO $(vQvdToCsvQvdFileName);
	STORE $(vQvdToCsvFields) FROM "$(vQvdToCsvTableName)" INTO '$(vQvdToCsvQvdFileName)' (txt);
	IF (not IsNull (pDropIt)) and (pDropIt <> 0) THEN
		call dropTable ('$(vQvdToCsvTableName)');
	ENDIF
	
END SUB

// Drop Tables
SUB dropTable(pTableName)
	TRACE ---> DROPING TABLE $(pTableName);
	DROP TABLE $(pTableName);
END SUB

///$tab >> Start Timer
//********************************* Start Zeitmessung *********************************
Let vStartTime  = now();
Set vElapsed = 0;
//*************************************************************************************
///$tab 0. Mapping
//********************************* Start Zeitmessung *********************************
// SET vStartTime_Map = 0;
// Set vElapsed_Map = 0;
Let vStartTime_Map  = now();

//*************************************************************************************

// GlobalesMapping
//$(Must_Include=lib://0100_Global/01_Include\01_qvs\MappingGlobal.qvs);
$(Must_Include=lib://0100_Global/01_Include\01_qvs\MappingGlobal_schnell.qvs);  //hsc: neues globales Mapping auf QVD anstatt auf Excel basierend

//Mapping Dimensions Faktor
Map_DimAccountFactor:
Mapping LOAD
	account_key,
    If(Match([account_factor], 'NEGATIVE')>0, -1, 1) as Faktor
FROM [$(vStorePath)KontoZusatzinformationen.qvd]
(qvd);

//Mapping Dimensions Account Group
Map_DimAccountGroup:
Mapping LOAD
    account_key,
    account_parent
FROM [$(vStorePath)KontoZusatzinformationen.qvd]
(qvd);


//Mapping Dimensions Kontolevel
Map_DimAccountLevel:
Mapping LOAD
	account_key,
    account_level
FROM [$(vStorePath)KontoZusatzinformationen.qvd]
(qvd);

//Mapping Dimensions Kontolevel
Map_DimAccountSort:
Mapping LOAD
	account_key,
    sort_code
FROM [$(vStorePath)KontoZusatzinformationen.qvd]
(qvd);


// Load Month Translation
Map_Months_EnDe:
Mapping LOAD
    Fakten.Monat_EN,
    Fakten.Monat_DE
FROM [lib://0100_Global/04_Datasource/04_Excel/Uebersetzung_Data.xlsx]
(ooxml, embedded labels, table is Fakten.Monat);

/*
// Project Id
Map_Project_to_Bew:
Mapping LOAD Distinct
	__KEY_root,
    ProjectID
FROM [lib://$(vStore)/04_Datasource/06_qvd_api/root.qvd]
(qvd);
*/

// Bew to Project Id
Map_BewToProj:
Mapping LOAD Distinct
    ProjectId,
    BewertungsID
FROM [$(vSourcePath)DS_api_Root.qvd]
(qvd);



//Fix hsc 22.08.2022 (Pfad abgeändert)
// Project Id
Map_Project_to_Bew:
Mapping LOAD Distinct 
	 _KEY_root as __KEY_root,
    ProjectId as ProjectID
FROM [$(vSourcePath)DS_api_Root.qvd]
(qvd);


//Fix hsc 22.08.2022 (Mapping darf nicht verwendet werden)
/*
// Map Portfolio to Valuation
Map_Portfolio_to_Bew:
Mapping LOAD Distinct
	ValuationID,
    PortfolioID
FROM [lib://$(vStore)/04_Datasource/06_qvd_api/root.qvd]
(qvd);
*/

//Fix hsc 22.08.2022 (Mapping darf nicht verwendet werden)
/*
// Map Project to Portfolio
Map_Project_to_PF:
Mapping LOAD Distinct
	PortfolioID,
    ProjectID
FROM [lib://$(vStore)/04_Datasource/06_qvd_api/root.qvd]
(qvd);
*/


// Project Id
/*
// Map Valuation Date to Valuation
Map_BewStichtag_to_BewID:
Mapping LOAD Distinct
	left(__KEY_root, 11) as %BewertungsID,
	Date(valuationDate) as Bewertungsstichtag
FROM [lib://$(vStore)/04_Datasource/06_qvd_api/settings.qvd]
(qvd);
*/

//Fix hsc 22.08.2022 (Pfad abgeändert)
Map_BewStichtag_to_BewID:
Mapping LOAD Distinct
	SubField([_KEY_root],'|',1) as %BewertungsID,
	Date(Bewertungsstichtag) as Bewertungsstichtag
FROM [$(vSourcePath)DS_api_Einstellungen.qvd]
(qvd);


/*
// Map Portfolio to Property Unit
Map_WE_to_Portfolio:
Mapping LOAD Distinct
	id,
    PortfolioID
FROM [lib://$(vStore)/04_Datasource/06_qvd_api/propertyUnit_WE.qvd]
(qvd);
*/

//Fix hsc 22.08.2022 (Pfad abgeändert)
// Map Portfolio to Property Unit
Map_WE_to_Portfolio:
Mapping LOAD Distinct
	WirtschaftseinheitsID,
    PortfolioId
FROM [$(vSourcePath)DS_api_Wirtschaftseinheit_WE.qvd]
(qvd);


// Map Parent-Portfolio to Portfolio
Map_Parent_Portfolio:
Mapping LOAD Distinct
    PortfolioId,
    ParentPortfolio
FROM [$(vSourcePath)DS_api_Portfolios.qvd]
(qvd);



/*
// Map Portfolio-Name to Portfolio
Map_Name_Portfolio:
Mapping LOAD Distinct
	PortfolioID,
    name
FROM [lib://$(vStore)/04_Datasource/06_qvd_api/portfolios.qvd]
(qvd);
*/

//Fix hsc 22.08.2022 (Pfad abgeändert)
Map_Name_Portfolio:
Mapping LOAD Distinct
	PortfolioId,
    Name
FROM [$(vSourcePath)DS_api_Portfolios.qvd]
(qvd);


// Map Account Name to Account No. (Custom Account Plan)
Map_AccountLevel:
Mapping LOAD
	externalId,
    SubStringCount(key,'-') + 1 as AccountLevel
FROM [$(vSourcePath06)accountPlan.qvd]
(qvd);

Map_AccountFactor_Custom:
Mapping LOAD
	externalId,
    SubField(type, '_', -1) as Type 
FROM [$(vSourcePath06)accountPlan.qvd]
(qvd);

//tpl:

// Map Account Name to Account No. (SIA Account Plan)
Map_AccountLevelSIA:
Mapping LOAD
	AP_externalId,
    AP_level
FROM [$(vSourcePath06)account_tree.qvd]
(qvd);

// Map Account Name to Account Faktor (SIA Account Plan)
Map_AccountFaktorStandard:
Mapping LOAD
	AP_externalId,
    AP_group
FROM [$(vSourcePath06)account_tree.qvd]
(qvd);

Map_HauptAccountSIA:
Mapping Load * Inline [
KontoNr, Bezeichnung
1,Mietertrag (SOLL)
201,Mietzinsverlust
202,Leerstand
301,Mietzinsreduktion
4,Mietertrag (IST)
5,Betriebskosten total inkl. Nebenkosten z.L. Eigentümer
6,Instandhaltungskosten
7,Eigentümerkosten (nicht auf Mieter überwälzbar)
8,Nettoertrag
9,Portfolio- u. Managementkosten
  10,Gewinne / Verluste aus Verkäufen / Wiederbewertung
  11,Gewinne / Verluste aus Verkäufen / Wiederbewertung
  12,Gewinne / Verluste aus Verkäufen / Wiederbewertung
  13,Gewinne / Verluste aus Verkäufen / Wiederbewertung
14,EBITDA (operativer Liegenschaftsertrag)
15,Instandsetzungskosten
16,EBIT (nachhaltiger Liegenschaftsertrag)
17,Finanzierungskosten
18,Ertragssteuern
19,Veränderung latente Steuern
20,Liegenschaftserfolg (Triple Net)
];

Map_HauptAccountSIASort:
Mapping Load * Inline [
KontoNr, Bezeichnung
  1,1
201,2.01
202,2.02
301,3.01
  4,4
  5,5
  6,6
  7,7
  8,8
  9,9
  10,10.1
  11,10.1
  12,10.1
  13,10.1
  14,14
  15,15
  16,16
  17,17
  18,18
  19,19
  20,20
];


// Map Custom Account Name to Account No.
Map_AccountName:
Mapping LOAD Distinct
    externalId,
    de
FROM [$(vSourcePath06)accountPlan.qvd]
(qvd);

// Map Account No. to Account Key (Custom Account Plan)
Map_Kundenkonto:
Mapping LOAD
	key,
    externalId
FROM [$(vSourcePath06)accountPlan.qvd]
(qvd);    

// Map Account No. to Parent Account Key (Custom Account Plan)
Map_ParentAccount:
Mapping LOAD
	SubField(key, '-', 1) &'-'& SubField(key, '-', 2) as AccountParent,
    externalId
FROM [$(vSourcePath06)accountPlan.qvd]
(qvd)
WHERE len(externalId)=4;

// Uebersetzung TechName nach KontoId
Map_Kontobaum:
Mapping LOAD
    AP_key,
    AP_externalId
FROM [$(vSourcePath06)account_tree.qvd]
(qvd)
WHERE Len(Trim(AP_key))>0;

// Uebersetzung KontoId zu TechName
Map_KontobaumRev:
Mapping LOAD
    Num(AP_externalId) as extid,
    AP_key
FROM [$(vSourcePath06)account_tree.qvd]
(qvd)
WHERE Len(Trim(AP_externalId))>0;

// Map Custom Account No. to Dimensions Account No.
Map_CustomtoDim:
Mapping LOAD
	externalId,
    accountKey
FROM [$(vSourcePath06)accountPlan.qvd]
(qvd)
WHERE Match(accountPlan, 'VALUATION');


// Map Custom Account No. to SIA Account No.
Map_CustomtoSIA:
Mapping LOAD
	externalId,
    ApplyMap('Map_Kontobaum', accountKey, null()) as SIA_Id
FROM [$(vSourcePath06)accountPlan.qvd]
(qvd)
WHERE Match(accountPlan, 'SIA');


// Map Custom Account No. to KKV Account No.
Map_CustomtoKKV:
Mapping LOAD
	//ApplyMap('Map_Kontobaum', accountKey, null()) as SIA_Id,
	externalId,
    accountKey
FROM [$(vSourcePath06)accountPlan.qvd]
(qvd)
WHERE Match(accountPlan, 'KKV');

// Map Custom Account No. to OR Account No.
Map_CustomtoOR:
Mapping LOAD
//	ApplyMap('Map_Kontobaum', accountKey, null()) as SIA_Id,
	externalId,
    accountKey
FROM [$(vSourcePath06)accountPlan.qvd]
(qvd)
WHERE Match(accountPlan, 'ASSET_STATEMENT_LAW_OF_BONDS');


// Map Custom Account No. to SIA, KKV and OR Account No.
Map_CustomtoCombinedSIA:
Mapping LOAD
	externalId,
    ApplyMap('Map_Kontobaum', accountKey, null()) as SIA_CombinedId
FROM [$(vSourcePath06)accountPlan.qvd]
(qvd)
WHERE Match(accountPlan, 'SIA', 'KKV', 'ASSET_STATEMENT_LAW_OF_BONDS');

// Combined Account Mappings SIA & KKV & OR
Map_CombSIAToName:
Mapping LOAD
	AP_key,
    AP_de

FROM [$(vSourcePath06)account_tree.qvd]
(qvd);

Map_CombSIAToParent:
Mapping LOAD
	AP_key,
    AP_parent

FROM [$(vSourcePath06)account_tree.qvd]
(qvd);

Map_CombSIAToLevel_orig:
Mapping LOAD
	AP_key,
    AP_level

FROM [$(vSourcePath06)account_tree.qvd]
(qvd);

Map_CombSIAToLevel_mod:
Mapping LOAD
	AP_key,
//    AP_level
    If(Match(AP_accountType, 'ASSET_STATEMENT_LAW_OF_BONDS', 'KKV')>0, If(AP_level='0', '1', '0'), AP_level) as AP_level_new

FROM [$(vSourcePath06)account_tree.qvd]
(qvd);

Map_CombSIAToGroup:
Mapping LOAD
	AP_key,
    AP_group

FROM [$(vSourcePath06)account_tree.qvd]
(qvd);

Map_CombSIAToType:
Mapping LOAD
	AP_key,
    AP_accountType

FROM [$(vSourcePath06)account_tree.qvd]
(qvd);

Map_CombSIAToExternalID:
Mapping LOAD
	AP_key,
    AP_externalId

FROM [$(vSourcePath06)account_tree.qvd]
(qvd);


// Map Next-Level Account No. to the lowest-level Account No. (Custom Account Plan)
temp1:
LOAD Distinct
	key,
    externalId,
    Accountlevel
WHERE Accountlevel = 3
;
LOAD
	*,
    SubStringCount(key,'-') + 1 as Accountlevel
    
FROM [$(vSourcePath06)accountPlan.qvd]
(qvd);

Map_OneLevelUpAccount:
Mapping LOAD
	key,
    externalId
Resident temp1;
DROP TABLE temp1;

// *** Reverse Account Mappings **//
accountPlan:
NoConcatenate
LOAD
    externalId,
    accountPlan,
    accountKey
FROM [$(vSourcePath06)accountPlan.qvd]
(qvd);

// Map first CustomAccount No. to SIA Account No.
Map_SIAtoCustom:
Mapping LOAD Distinct
	accountKey,
    FirstValue(externalId) as accountCustom

Resident accountPlan
WHERE Match(accountPlan, 'SIA')
GROUP BY accountKey
ORDER BY externalId Asc;

// Map first CustomAccount No. to Dimensions Account
Map_DimtoCustom:
Mapping LOAD Distinct
	accountKey,
    FirstValue(externalId) as accountCustom

Resident accountPlan
WHERE Match(accountPlan, 'VALUATION')
GROUP BY accountKey
ORDER BY externalId Asc;

// Map first CustomAccount No. to KKV Account
Map_KKVtoCustom:
Mapping LOAD Distinct
	accountKey,
    FirstValue(externalId) as accountCustom

Resident accountPlan
WHERE Match(accountPlan, 'KKV')
GROUP BY accountKey
ORDER BY externalId Asc;

// Map first CustomAccount No. to OR Account
Map_ORtoCustom:
Mapping LOAD Distinct
	accountKey,
    FirstValue(externalId) as accountCustom

Resident accountPlan
WHERE Match(accountPlan, 'ASSET_STATEMENT_LAW_OF_BONDS')
GROUP BY accountKey
ORDER BY externalId Asc;

Map_CombSIAtoCustom:
Mapping LOAD Distinct
	accountKey,
    FirstValue(externalId) as accountCustom

Resident accountPlan
WHERE Match(accountPlan, 'SIA', 'ASSET_STATEMENT_LAW_OF_BONDS', 'KKV')
GROUP BY accountKey
ORDER BY externalId Asc;

// Map SIA to Dimensions Account
Map_DimtoCombSIA:
Mapping LOAD Distinct
	accountKey,
    ApplyMap('Map_CustomtoCombinedSIA', FirstValue(externalId), Null()) as accountSIAComb

Resident accountPlan
WHERE Match(accountPlan, 'VALUATION')
GROUP BY accountKey
ORDER BY externalId Asc;

Map_DimtoSIA:
Mapping LOAD Distinct
	accountKey,
    ApplyMap('Map_CustomtoSIA', FirstValue(externalId), Null()) as accountSIA

Resident accountPlan
WHERE Match(accountPlan, 'VALUATION')
GROUP BY accountKey
ORDER BY externalId Asc;

Map_DimtoKKV:
Mapping LOAD Distinct
	accountKey,
    ApplyMap('Map_CustomtoKKV', FirstValue(externalId), Null()) as accountKKV

Resident accountPlan
WHERE Match(accountPlan, 'VALUATION')
GROUP BY accountKey
ORDER BY externalId Asc;

Map_DimtoOR:
Mapping LOAD Distinct
	accountKey,
    ApplyMap('Map_CustomtoOR', FirstValue(externalId), Null()) as accountOR

Resident accountPlan
WHERE Match(accountPlan, 'VALUATION')
GROUP BY accountKey
ORDER BY externalId Asc;


//
DROP TABLE accountPlan;
// **** END Reverse Accoutn Mappings *** ///


// are: 10/11/2022 wurde ausgeschlatet, wir nicht mehr benötigt (aber noch activ)
//***** START KEY FIGURES MAPPING (Custom Account Plan Accounts to Key Figures) *****//


// Build a temporary Mapping table: Custom Accounts to Key Figures and Dimensions Account to Key Figures
KeyFig_Mapping:
LOAD Distinct
    KontonameAnzeigeWE,
    "Beschreibung L1",
    L2,
    "Beschreibung L2",
    L3,
    "Beschreibung L3",
    KeyFiguresKontoname_temp as KeyFiguresKontoname,
    Faktor,
    "Include",
    Sort_temp as Sort,
    GruppenKontoL0_temp as GruppenKontoL0,
    GruppenKontoL1_temp as GruppenKontoL1,
    GruppenKontoL2_temp as GruppenKontoL2,
    GruppenKontoL3_temp as GruppenKontoL3,
    GruppenKontoL4_temp as GruppenKontoL4,
    GruppenKontoL5_temp as GruppenKontoL5,
    GruppenSortL0_temp as GruppenSortL0,
    GruppenSortL1_temp as GruppenSortL1,
    GruppenSortL2_temp as GruppenSortL2,
    GruppenSortL3_temp as GruppenSortL3,
    GruppenSortL4_temp as GruppenSortL4,
    GruppenSortL5_temp as GruppenSortL5,
    Fakten_KontonameAnzeige,
    KontomappingImportFile,
    Fakten_Faktor,
    KeyFiguresKontoname_CF,
    Sort_CF,
    GruppenKontoL0_CF,
    GruppenKontoL1_CF,
    GruppenKontoL2_CF,
    GruppenKontoL3_CF,
    GruppenKontoL4_CF,
    GruppenKontoL5_CF,
    GruppenSortL0_CF,
    GruppenSortL1_CF,
    GruppenSortL2_CF,
    GruppenSortL3_CF,
    GruppenSortL4_CF,
    GruppenSortL5_CF,   
    Kommentar
;
// Preceding load
LOAD
	*,
    if(Match(KeyFiguresKontoname, 'Soll Mietertrag'), 'Soll Mietertrag Netto', KeyFiguresKontoname) as KeyFiguresKontoname_temp,
    if(Match(KeyFiguresKontoname, 'Soll Mietertrag'), '', Sort) as Sort_temp,
    if(Match(KeyFiguresKontoname, 'Soll Mietertrag', 'Mietzinsausfall'), 'Soll Mietertrag', '') as GruppenKontoL0_temp,
    if(Match(KeyFiguresKontoname, 'Soll Mietertrag', 'Mietzinsausfall'), 'A099', '') as GruppenSortL0_temp,
    if(Match(KeyFiguresKontoname, 'Mietzinsausfall'), '', GruppenKontoL1) as GruppenKontoL1_temp,
    if(Match(KeyFiguresKontoname, 'Mietzinsausfall'), '', GruppenKontoL2) as GruppenKontoL2_temp,
    if(Match(KeyFiguresKontoname, 'Mietzinsausfall'), '', GruppenKontoL3) as GruppenKontoL3_temp,
    if(Match(KeyFiguresKontoname, 'Mietzinsausfall'), '', GruppenKontoL4) as GruppenKontoL4_temp,
    if(Match(KeyFiguresKontoname, 'Mietzinsausfall'), '', GruppenKontoL5) as GruppenKontoL5_temp,
    if(Match(KeyFiguresKontoname, 'Mietzinsausfall'), '', GruppenSortL1) as GruppenSortL1_temp,
    if(Match(KeyFiguresKontoname, 'Mietzinsausfall'), '', GruppenSortL2) as GruppenSortL2_temp,
    if(Match(KeyFiguresKontoname, 'Mietzinsausfall'), '', GruppenSortL3) as GruppenSortL3_temp,
    if(Match(KeyFiguresKontoname, 'Mietzinsausfall'), '', GruppenSortL4) as GruppenSortL4_temp,
    if(Match(KeyFiguresKontoname, 'Mietzinsausfall'), '', GruppenSortL5) as GruppenSortL5_temp,
    if(len(KontomappingImportFile)>0, if(Match(KeyFiguresKontoname, 'Soll Mietertrag'), 'Soll Mietertrag Brutto', KeyFiguresKontoname), '') as KeyFiguresKontoname_CF,
    if(len(KontomappingImportFile)>0, if(Match(KeyFiguresKontoname, 'Soll Mietertrag'), '', Sort), '') as Sort_CF,
    if(Match(KontomappingImportFile, 'INCOME_SHALL'), 'Soll Mietertrag', '') as GruppenKontoL0_CF,
    if(Match(KontomappingImportFile, 'INCOME_SHALL'), 'A099', '') as GruppenSortL0_CF,
    GruppenKontoL1 as GruppenKontoL1_CF,
    GruppenKontoL2 as GruppenKontoL2_CF,
    GruppenKontoL3 as GruppenKontoL3_CF,
    GruppenKontoL4 as GruppenKontoL4_CF,
    GruppenKontoL5 as GruppenKontoL5_CF,
    GruppenSortL1 as GruppenSortL1_CF,
    GruppenSortL2 as GruppenSortL2_CF,
    GruppenSortL3 as GruppenSortL3_CF,
    GruppenSortL4 as GruppenSortL4_CF,
    GruppenSortL5 as GruppenSortL5_CF
FROM [$(vStorePath)SpezialKontoMapping_Ruby.qvd]
(qvd);

// Mapping Key Figures to Expense-Accounts (Custom Account Plan)
Map_KeyFiguresAccounts:
Mapping LOAD
    KontonameAnzeigeWE,
    KeyFiguresKontoname
Resident KeyFig_Mapping;

Map_KeyFiguresFaktor:
Mapping LOAD
    KontonameAnzeigeWE,
    Faktor
Resident KeyFig_Mapping;

Map_KeyFiguresSort:
Mapping LOAD
    KontonameAnzeigeWE,
    Sort
Resident KeyFig_Mapping;

Map_GruppenKontoL0:
Mapping LOAD
    KontonameAnzeigeWE,
    GruppenKontoL0
Resident KeyFig_Mapping;

Map_GruppenKontoL1:
Mapping LOAD
    KontonameAnzeigeWE,
    GruppenKontoL1
Resident KeyFig_Mapping;

Map_GruppenKontoL2:
Mapping LOAD
    KontonameAnzeigeWE,
    GruppenKontoL2
Resident KeyFig_Mapping;

Map_GruppenKontoL3:
Mapping LOAD
    KontonameAnzeigeWE,
    GruppenKontoL3
Resident KeyFig_Mapping;

Map_GruppenKontoL4:
Mapping LOAD
    KontonameAnzeigeWE,
    GruppenKontoL4
Resident KeyFig_Mapping;

Map_GruppenKontoL5:
Mapping LOAD
    KontonameAnzeigeWE,
    GruppenKontoL5
Resident KeyFig_Mapping;

Map_GruppenSortL0:
Mapping LOAD
    KontonameAnzeigeWE,
    GruppenSortL0
Resident KeyFig_Mapping;

Map_GruppenSortL1:
Mapping LOAD
    KontonameAnzeigeWE,
    GruppenSortL1
Resident KeyFig_Mapping;

Map_GruppenSortL2:
Mapping LOAD
    KontonameAnzeigeWE,
    GruppenSortL2
Resident KeyFig_Mapping;

Map_GruppenSortL3:
Mapping LOAD
    KontonameAnzeigeWE,
    GruppenSortL3
Resident KeyFig_Mapping;

Map_GruppenSortL4:
Mapping LOAD
    KontonameAnzeigeWE,
    GruppenSortL4
Resident KeyFig_Mapping;

Map_GruppenSortL5:
Mapping LOAD
    KontonameAnzeigeWE,
    GruppenSortL5
Resident KeyFig_Mapping;

// Map Key Figures Groups to the Key Figures Accounts
Map_KeyFigGruppenKontoL0:
Mapping LOAD
	KeyFiguresKontoname,
    GruppenKontoL0
Resident KeyFig_Mapping;

Map_KeyFigGruppenKontoL1:
Mapping LOAD
	KeyFiguresKontoname,
    GruppenKontoL1
Resident KeyFig_Mapping;

Map_KeyFigGruppenKontoL2:
Mapping LOAD
	KeyFiguresKontoname,
    GruppenKontoL2
Resident KeyFig_Mapping;

Map_KeyFigGruppenKontoL3:
Mapping LOAD
	KeyFiguresKontoname,
    GruppenKontoL3
Resident KeyFig_Mapping;

Map_KeyFigGruppenKontoL4:
Mapping LOAD
	KeyFiguresKontoname,
    GruppenKontoL4
Resident KeyFig_Mapping;

Map_KeyFigGruppenKontoL5:
Mapping LOAD
	KeyFiguresKontoname,
    GruppenKontoL5
Resident KeyFig_Mapping;

// Sorting
Map_KeyFigGruppenSortL0:
Mapping LOAD
	KeyFiguresKontoname,
    GruppenSortL0
Resident KeyFig_Mapping;

Map_KeyFigGruppenSortL1:
Mapping LOAD
	KeyFiguresKontoname,
    GruppenSortL1
Resident KeyFig_Mapping;

Map_KeyFigGruppenSortL2:
Mapping LOAD
	KeyFiguresKontoname,
    GruppenSortL2
Resident KeyFig_Mapping;

Map_KeyFigGruppenSortL3:
Mapping LOAD
	KeyFiguresKontoname,
    GruppenSortL3
Resident KeyFig_Mapping;

Map_KeyFigGruppenSortL4:
Mapping LOAD
	KeyFiguresKontoname,
    GruppenSortL4
Resident KeyFig_Mapping;

Map_KeyFigGruppenSortL5:
Mapping LOAD
	KeyFiguresKontoname,
    GruppenSortL5
Resident KeyFig_Mapping;

// Key Figures Reverse Mapping (Dimensions to Key Figures)
Map_KeyFiguresAccounts_Rev:
Mapping LOAD
    KontomappingImportFile,
    KeyFiguresKontoname_CF
Resident KeyFig_Mapping
WHERE not(isnull(KontomappingImportFile));

Map_KeyFiguresFaktor_Rev:
Mapping LOAD
    KontomappingImportFile,
    Fakten_Faktor
Resident KeyFig_Mapping
WHERE not(isnull(KontomappingImportFile));

Map_KeyFiguresSort_Rev:
Mapping LOAD
    KontomappingImportFile,
    Sort_CF
Resident KeyFig_Mapping
WHERE not(isnull(KontomappingImportFile));

Map_REVGruppenKontoL0:
Mapping LOAD
    KontomappingImportFile,
    GruppenKontoL0_CF
Resident KeyFig_Mapping
WHERE not(isnull(KontomappingImportFile));

Map_REVGruppenKontoL1:
Mapping LOAD
    KontomappingImportFile,
    GruppenKontoL1_CF
Resident KeyFig_Mapping
WHERE not(isnull(KontomappingImportFile));

Map_REVGruppenKontoL2:
Mapping LOAD
    KontomappingImportFile,
    GruppenKontoL2_CF
Resident KeyFig_Mapping
WHERE not(isnull(KontomappingImportFile));

Map_REVGruppenKontoL3:
Mapping LOAD
    KontomappingImportFile,
    GruppenKontoL3_CF
Resident KeyFig_Mapping
WHERE not(isnull(KontomappingImportFile));

Map_REVGruppenKontoL4:
Mapping LOAD
    KontomappingImportFile,
    GruppenKontoL4_CF
Resident KeyFig_Mapping
WHERE not(isnull(KontomappingImportFile));

Map_REVGruppenKontoL5:
Mapping LOAD
    KontomappingImportFile,
    GruppenKontoL5_CF
Resident KeyFig_Mapping
WHERE not(isnull(KontomappingImportFile));

Map_REVGruppenSortL0:
Mapping LOAD
    KontomappingImportFile,
    GruppenSortL0_CF
Resident KeyFig_Mapping
WHERE not(isnull(KontomappingImportFile));

Map_REVGruppenSortL0:
Mapping LOAD
    KontomappingImportFile,
    GruppenSortL0_CF
Resident KeyFig_Mapping
WHERE not(isnull(KontomappingImportFile));

Map_REVGruppenSortL1:
Mapping LOAD
    KontomappingImportFile,
    GruppenSortL1_CF
Resident KeyFig_Mapping
WHERE not(isnull(KontomappingImportFile));

Map_REVGruppenSortL2:
Mapping LOAD
    KontomappingImportFile,
    GruppenSortL2_CF
Resident KeyFig_Mapping
WHERE not(isnull(KontomappingImportFile));

Map_REVGruppenSortL3:
Mapping LOAD
    KontomappingImportFile,
    GruppenSortL3_CF
Resident KeyFig_Mapping
WHERE not(isnull(KontomappingImportFile));

Map_REVGruppenSortL4:
Mapping LOAD
    KontomappingImportFile,
    GruppenSortL4_CF
Resident KeyFig_Mapping
WHERE not(isnull(KontomappingImportFile));

Map_REVGruppenSortL5:
Mapping LOAD
    KontomappingImportFile,
    GruppenSortL5_CF
Resident KeyFig_Mapping
WHERE not(isnull(KontomappingImportFile));

Map_REVBeschreibung:
Mapping LOAD
    KontomappingImportFile,
    "Beschreibung L3"
Resident KeyFig_Mapping
WHERE not(isnull(KontomappingImportFile));

Map_REVInclude:
Mapping LOAD
    KontomappingImportFile,
    "Include"
Resident KeyFig_Mapping
WHERE not(isnull(KontomappingImportFile));

// Reverse Mapping Key Figures Groups to the Key Figures Accounts (Dimensions View)
Map_REVKeyFigGruppenKontoL0:
Mapping LOAD
	KeyFiguresKontoname_CF,
    GruppenKontoL0_CF
Resident KeyFig_Mapping;

Map_REVKeyFigGruppenKontoL1:
Mapping LOAD
	KeyFiguresKontoname_CF,
    GruppenKontoL1_CF
Resident KeyFig_Mapping;

Map_REVKeyFigGruppenKontoL2:
Mapping LOAD
	KeyFiguresKontoname_CF,
    GruppenKontoL2_CF
Resident KeyFig_Mapping;

Map_REVKeyFigGruppenKontoL3:
Mapping LOAD
	KeyFiguresKontoname_CF,
    GruppenKontoL3_CF
Resident KeyFig_Mapping;

Map_REVKeyFigGruppenKontoL4:
Mapping LOAD
	KeyFiguresKontoname_CF,
    GruppenKontoL4_CF
Resident KeyFig_Mapping;

Map_REVKeyFigGruppenKontoL5:
Mapping LOAD
	KeyFiguresKontoname_CF,
    GruppenKontoL5_CF
Resident KeyFig_Mapping;

// Sorting Dimensions Key Figures Groups
Map_REVKeyFigGruppenSortL0:
Mapping LOAD
	KeyFiguresKontoname_CF,
    GruppenSortL0_CF
Resident KeyFig_Mapping;

Map_REVKeyFigGruppenSortL1:
Mapping LOAD
	KeyFiguresKontoname_CF,
    GruppenSortL1_CF
Resident KeyFig_Mapping;

Map_REVKeyFigGruppenSortL2:
Mapping LOAD
	KeyFiguresKontoname_CF,
    GruppenSortL2_CF
Resident KeyFig_Mapping;

Map_REVKeyFigGruppenSortL3:
Mapping LOAD
	KeyFiguresKontoname_CF,
    GruppenSortL3
Resident KeyFig_Mapping;

Map_REVKeyFigGruppenSortL4:
Mapping LOAD
	KeyFiguresKontoname_CF,
    GruppenSortL4_CF
Resident KeyFig_Mapping;

Map_REVKeyFigGruppenSortL5:
Mapping LOAD
	KeyFiguresKontoname_CF,
    GruppenSortL5_CF
Resident KeyFig_Mapping;


// ***  END OF KEY FIGURES MAPPING *** //

/*
// Mapi User Combined Name to UserId
Map_Users:
Mapping LOAD Distinct
    id,
	Text(firstName & ' ' & lastName) as Comb_Name
FROM [lib://$(vStore)/04_Datasource/06_qvd_api/users.qvd]
(qvd);
*/

//Fix hsc 22.08.2022 (Pfad abgeändert)

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_User.qvd')) Then

Map_Users:
Mapping LOAD Distinct
    UserID,
	Text(Vorname & ' ' & Nachname) as Comb_Name
FROM [$(vSourcePath)DS_api_User.qvd]
(qvd);

ELSE

Map_Users:
Mapping LOAD * Inline [
    UserID, Comb_Name
    '', ''
];

END IF

/*
// Map Stakeholder Name to StakeholderId
Map_Stakeholders_Name:
Mapping LOAD Distinct
    id,
    name
FROM [lib://$(vStore)/04_Datasource/06_qvd_api/stakeholders_root.qvd]
(qvd);
*/

//Fix hsc 22.08.2022 (Pfad abgeändert)
// Map Stakeholder Name to StakeholderId

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Stakeholders.qvd')) Then

Map_Stakeholders_Name:
Mapping LOAD Distinct
    StakeholderID,
    NameStakeholder
FROM [$(vSourcePath)DS_api_Stakeholders.qvd]
(qvd);

ELSE

Map_Stakeholders_Name:
Mapping LOAD * Inline [
    StakeholderID, NameStakeholder
    '', ''
];

END IF

// Parent Filiale
IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_StakeholdersFilialen.qvd')) Then

Map_Stakeholders_Parent:
Mapping LOAD Distinct
    StakeholderID,
	ParentStakeholderID
FROM [$(vSourcePath)DS_api_StakeholdersFilialen.qvd]
(qvd);

ELSE

Map_Stakeholders_Parent:
Mapping LOAD * Inline [
    StakeholderID, ParentStakeholderID
    '', ''
];

END IF

/*
// Map Stakeholder's Addresses to StakeholderId
Map_Stakeholders_Address:
Mapping LOAD Distinct
    SubField([__KEY_root], '$(vKeySep)', 1) as id,
	addressLine1 & ' ' & addressLine2 & ' ' & zipCode & ' ' & place as Address
FROM [lib://$(vStore)/04_Datasource/06_qvd_api/stakeholders_adress.qvd]
(qvd);
*/

//Fix hsc 22.08.2022 (Pfad abgeändert)
// Map Stakeholder's Addresses to StakeholderId

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_StakeholdersAdresse.qvd')) Then

Map_Stakeholders_Address:
Mapping LOAD Distinct
    SubField([_KEY_root], '$(vKeySep)', 1) as id,
	Adresse1 & ' ' & Adresse2 & ' ' & PLZ & ' ' & Ort as Address
FROM [$(vSourcePath)DS_api_StakeholdersAdresse.qvd]
(qvd);

ELSE

Map_Stakeholders_Address:
Mapping LOAD * Inline [
    id, Address
    '', ''
];

END IF

/*
// Map LIVE Name to Live(Stakeholder)Id
Map_LIVE_Name:
Mapping LOAD Distinct
    left([__KEY_root], 7) as id,
    firstName & ' ' & lastName as Name
FROM [lib://$(vStore)/04_Datasource/06_qvd_api/stakeholders_contacts.qvd]
(qvd);
*/

//Fix hsc 22.08.2022 (Pfad abgeändert)

IF Not Isnull(QvdCreateTime('$(vSourcePath)StakeholdersPersonen.qvd')) Then

Map_LIVE_Name:
Mapping LOAD Distinct
    left([_KEY_root], 7) as id,
    Vorname & ' ' & Nachname as Name
FROM [$(vSourcePath)DS_api_StakeholdersPersonen.qvd]
(qvd);

ELSE

Map_LIVE_Name:
Mapping LOAD * Inline [
    id, Name
    '', ''
];

END IF

/*
// Map LIVE TelNo to Live(Stakeholder)Id
Map_LIVE_Tel:
Mapping LOAD Distinct
    left([__KEY_root], 7) as id,
    fixedLineNumber
FROM [lib://$(vStore)/04_Datasource/06_qvd_api/stakeholders_contacts.qvd]
(qvd);
*/

//Fix hsc 22.08.2022 (Pfad abgeändert)

IF Not Isnull(QvdCreateTime('$(vSourcePath)StakeholdersPersonen.qvd')) Then

Map_LIVE_Tel:
Mapping LOAD Distinct
    left([_KEY_root], 7) as id,
    Telefon
FROM [$(vSourcePath)DS_api_StakeholdersPersonen.qvd]
(qvd);

ELSE

Map_LIVE_Tel:
Mapping LOAD * Inline [
    id, Telefon
    '', ''
];

END IF

/*
// Map LIVE OfficeTel to Live(Stakeholder)Id
Map_LIVE_OfficeTel:
Mapping LOAD Distinct
    left([__KEY_root], 7) as id,
    officeNumber
FROM [lib://$(vStore)/04_Datasource/06_qvd_api/stakeholders_contacts.qvd]
(qvd);
*/

//Fix hsc 22.08.2022 (Pfad abgeändert)

IF Not Isnull(QvdCreateTime('$(vSourcePath)StakeholdersPersonen.qvd')) Then

Map_LIVE_OfficeTel:
Mapping LOAD Distinct
    left([_KEY_root], 7) as id,
    Direktwahl
FROM [$(vSourcePath)DS_api_StakeholdersPersonen.qvd]
(qvd);

ELSE

Map_LIVE_OfficeTel:
Mapping LOAD * Inline [
    id, Direktwahl
    '', ''
];

END IF

/*
// Map LIVE MobileNo to Live(Stakeholder)Id
Map_LIVE_Mobile:
Mapping LOAD Distinct
    left([__KEY_root], 7) as id,
    mobileNumber
FROM [lib://$(vStore)/04_Datasource/06_qvd_api/stakeholders_contacts.qvd]
(qvd);
*/

//Fix hsc 22.08.2022 (Pfad abgeändert)

IF Not Isnull(QvdCreateTime('$(vSourcePath)StakeholdersPersonen.qvd')) Then

Map_LIVE_Mobile:
Mapping LOAD Distinct
    left([_KEY_root], 7) as id,
    MobilTelefon
FROM [$(vSourcePath)DS_api_StakeholdersPersonen.qvd]
(qvd);

ELSE

Map_LIVE_Mobile:
Mapping LOAD * Inline [
    id, MobilTelefon
    '', ''
];

END IF

/*
// Map LIVE Email to Live(Stakeholder)Id
Map_LIVE_Email:
Mapping LOAD Distinct
    left([__KEY_root], 7) as id,
    email
FROM [lib://$(vStore)/04_Datasource/06_qvd_api/stakeholders_contacts.qvd]
(qvd);
*/

//Fix hsc 22.08.2022 (Pfad abgeändert)

IF Not Isnull(QvdCreateTime('$(vSourcePath)StakeholdersPersonen.qvd')) Then

Map_LIVE_Email:
Mapping LOAD Distinct
    left([_KEY_root], 7) as id,
    Email
FROM [$(vSourcePath)DS_api_StakeholdersPersonen.qvd]
(qvd);

ELSE

Map_LIVE_Email:
Mapping LOAD * Inline [
    id, Email
    '', ''
];

END IF


// Map CHF Rate to Currency to CurrencyCode
Map_Currency:
Mapping Load
    Currency_code,
    CHF_Currency
FROM $(vPfadCurrency);	//für tagesaktuelle Währungen diesen Pfad benutzen

// Map Inverse Currency Rate to CHF to CurrencyCode
Map_Inverse_Currency:
Mapping Load
    Currency_code,
    Currency_CHF
FROM $(vPfadCurrency);	//für tagesaktuelle Währungen diesen Pfad benutzen

/*
// Map Property Unit Base URL to PUId
Map_BasisURL:
Mapping LOAD
    id,
    BaseURL
FROM [lib://$(vStore)/04_Datasource/06_qvd_api/propertyUnit_WE.qvd]
(qvd);
*/

//Fix hsc 22.08.2022 (Pfad abgeändert)
Map_BasisURL:
Mapping LOAD
    WirtschaftseinheitsID,
    BasisURL
FROM [$(vSourcePath)DS_api_Wirtschaftseinheit_WE.qvd]
(qvd);


// *** Mapping CD Projekte ***//

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Bauprojekte.qvd')) Then

map_CD_Projects_Kennwerte:
Mapping Load
  	[_KEY_content],
  	Id
FROM [$(vSourcePath)DS_api_Bauprojekte.qvd]
(qvd);

ELSE

map_CD_Projects_Kennwerte:
Mapping LOAD * Inline [
    _KEY_content, Id
    '', ''
];

END IF

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Bauprojekte.qvd')) Then

map_CD_Projects_Phasen:
Mapping Load
      [_KEY_settings],
      Id
FROM [$(vSourcePath)DS_api_Bauprojekte.qvd]
(qvd);

ELSE

map_CD_Projects_Phasen:
Mapping LOAD * Inline [
    _KEY_settings, Id
    '', ''
];

END IF

Map_PhaseGroup:
Mapping Load *  Inline [
Phase, PhaseGroup
'INITIALIZATION'	,'laufend'
'UBS_PHASE_1'		,'laufend'
'UBS_PHASE_2'		,'laufend'
'UBS_PHASE_3'		,'laufend'
'UBS_PHASE_4_5'		,'laufend'
'UBS_PHASE_6'		,'laufend'
'FINAL'				,'abgeschlossen'
];


Map_AbrBdgTyp:
Mapping Load * Inline [
Typ, TypNum
EXPENSE, 0
BUDGET, 1
SIMULATION, 2
];

// are: 10/11/2022 wurde ausgeschaltet, wird nicht mehr benötigt
// Store QVD
// Call QvdStore ('KeyFig_Mapping', '$(vStorePath)', 'temp', 'KeyFig_Mapping', '*', 1);

//DROP TABLE KeyFig_Mapping;

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_Map = (now() - vStartTime_Map)*86400;
Trace ---------------------------------- Mapping geladen ----------------------------------;
Trace $(vElapsed_Map);
//********************************************************************************************

///$tab >> 1. Kontohierarchien
//********************************* Start Zeitmessung *********************************
// SET vStartTime_KTO = 0;
// Set vElapsed_KTO = 0;
Let vStartTime_KTO  = now();

//*************************************************************************************
///$tab 1.1 Konto_HierarchyCustom (neu)
//********************************* Zeitmessung Mapping *********************************
// SET vStartTime_KtoCustom = 0;
// Set vElapsed_KtoCustom = 0;
Let vStartTime_KtoCustom  = now();

//*************************************************************************************

// Kontohierarchien
// Custom


// Ausgehend von Kontoplan, welches schon eine fertige Hierarchie ist, werden die Nodes und ParentNodes generiert
KontoplanCustomTree:
NoConcatenate Load 
     *
     , Mid (NodeID, 1, Index (NodeID, '-', -1)-1)   AS ParentNodeID // SIA-0-1-5
     ;
Load Distinct
    '0' & '-' &  Kontenschluessel AS NodeID // SIA-0-1-5-1
    , Kontoname         AS PlanLevelName
    , ReferenzNrKonto   AS PlanLevelID
    , SubStringCount(Kontenschluessel,'-') + 1 as Kontolevel
    , Kontenschluessel
    , SubField(Kontenschluessel, '-', 1) &'-'& SubField(Kontenschluessel, '-', 2) as ParentKontoKey
    // , ApplyMap ('Map_CustomtoDim', ReferenzNrKonto, Null()) AS PlanLevelID_Dim
    // , ApplyMap ('Map_CustomtoSIA', ReferenzNrKonto, Null()) AS PlanLevelID_SIA
    // , ApplyMap ('Map_CustomtoKKV', ReferenzNrKonto, Null()) AS PlanLevelID_KKV
    // , ApplyMap ('Map_CustomtoOR', ReferenzNrKonto, Null())  AS PlanLevelID_OR
    // , Kontoname_technisch as PlanLevelID_SIA
    // , Typ       AS 
FROM [$(vSourcePath)DS_api_Kontoplan.qvd](qvd)
where (Aktiv = 'True');
// Hier wird für jeden PlanVariante (Planvariante) eine oberste Ebene "Erfolg" hinzugefügt
Concatenate (KontoplanCustomTree) Load Distinct
    '0'  AS NodeID
    , 'Erfolg'             AS PlanLevelName
    , 0                    AS PlanLevelID
Resident KontoplanCustomTree;
Call QvdStoreDebug ('KontoplanCustomTree', vStorePath, 'KontoplanCustomTree_000');
// Anzahl der Ebenen bestimmen
KontoplanCustomLevels:
NoConcatenate Load
    Max(SepCount) AS MaxDepth
Group By 1;
Load Distinct
    SubStringCount (NodeID, '-') AS SepCount
Resident KontoplanCustomTree;
LET vMaxDepth = peek ('MaxDepth', 0, 'KontoplanCustomLevels');
Drop Table KontoplanCustomLevels;
TRACE MaxDepth = $(vMaxDepth);

// Die Hierarchie-Berechnung
// Wir generieren hier nicht den Namen für jedes Level, sondern nehmen gleich den NodeID -> NodeIDLevel1..x. 
// So können sind wir nachher flexibler und können danach joinen, was wir brauchen.
KontoplanCustomHierarchy:
Hierarchy (NodeID, ParentNodeID, NodeIDLevel, , , , '$(vKeySep)', Depth) 
LOAD 
    // , PlanLevelID
    // if (Len (PlanLevelID)>=5, 1, 0) AS IstKontoLevel
    1 AS IstKontoLevel  // ist nicht ermittelbar
    , NodeID
    , NodeID AS NodeIDLevel
    , ParentNodeID
    , Kontolevel
    , If(Kontolevel=3 OR Kontolevel=4, Kontenschluessel, ParentKontoKey) as Sort
    
Resident KontoplanCustomTree;
// Hier haben wir das Gerüst der Hierarchie Tabelle, welche ev. noch bereichert werden muss  
Call QvdStoreDebug ('KontoplanCustomHierarchy', vStorePath, 'KontoplanCustomHierarchy_000');

FOR vLevel = vMaxDepth to 1 step -1 // es wird down geloopt
    Left Join (KontoplanCustomHierarchy) Load
        *
        , PlanLevelID$(vLevel) & ' ' & PlanLevelName$(vLevel) AS PlanLevelIDName$(vLevel)
    ;
    Load
        NodeID          AS NodeIDLevel$(vLevel) // join field
        , PlanLevelName AS PlanLevelName$(vLevel)
        , PlanLevelID   AS PlanLevelID$(vLevel)
        // , PlanLevelID_SIA AS PlanLevelID_SIA$(vLevel)
    Resident KontoplanCustomTree;
Next 
Call QvdStoreDebug ('KontoplanCustomHierarchy', vStorePath, 'KontoplanCustomHierarchy_001');
// Unterster Level joinen
Left Join (KontoplanCustomHierarchy) Load
    *
    , PlanLevelID & ' ' & PlanLevelName AS PlanLevelIDName
;
Load
    NodeID          AS NodeIDLevel // join field
    , PlanLevelName AS PlanLevelName
    , PlanLevelID   AS PlanLevelID
    // , PlanLevelID_Dim
    // , PlanLevelID_SIA
    // , PlanLevelID_KKV
    // , PlanLevelID_OR
Resident KontoplanCustomTree;
Call QvdStoreDebug ('KontoplanCustomHierarchy', vStorePath, 'KontoplanCustomHierarchy_002');
Drop Table KontoplanCustomTree;

// Zusammenstellen der Feld expressions
FieldExpressions:
NoConcatenate Load
    Concat (Field_PlanLevelIDName, ', ')    AS Fields_PlanLevelIDName
    , Concat (Field_PlanLevelID, ', ')      AS Fields_PlanLevelID
    , Concat (Field_PlanLevelName, ', ')    AS Fields_PlanLevelName
Group By 1;
Load
    'PlanLevelIDName' & IterNo()    AS Field_PlanLevelIDName
    , 'PlanLevelID' & IterNo()      AS Field_PlanLevelID
    , 'PlanLevelName' & IterNo()    AS Field_PlanLevelName
Autogenerate 1
while (IterNo () <= $(vMaxDepth));
Call QvdStoreDebug ('FieldExpressions', vStorePath, 'FieldExpressions');
LET vFields_PlanLevelIDName = peek ('Fields_PlanLevelIDName', 0, 'FieldExpressions');  // PlanLevelIDName1, PlanLevelIDName2, PlanLevelIDName..
LET vFields_PlanLevelID     = peek ('Fields_PlanLevelID', 0, 'FieldExpressions');       // PlanLevelID1, PlanLevelID2, PlanLevelID..
LET vFields_PlanLevelName   = peek ('Fields_PlanLevelName', 0, 'FieldExpressions');      // PlanLevelName1, PlanLevelName2, PlanLevelName..
Drop Table FieldExpressions;

// Finale Tabelle
Rename Table KontoplanCustomHierarchy To KontoplanCustomHierarchyTmp;
KontoplanCustomHierarchy:
NoConcatenate Load
    Depth
    // , IstKontoLevel
    , [PlanLevelIDName]
    , $(vFields_PlanLevelIDName)
    , PlanLevelID
    , $(vFields_PlanLevelID)
    , PlanLevelName
    , $(vFields_PlanLevelName)
    , Kontolevel
    , Sort
    // , ParentNodeID
    // , PlanLevelID_Dim
    // , PlanLevelID_SIA
    // , PlanLevelID_KKV
    // , PlanLevelID_OR
    , PlanLevelID as %KontoCustom
Resident KontoplanCustomHierarchyTmp
where (IstKontoLevel = 1);
Call QvdStore ('KontoplanCustomHierarchy', '$(vStorePath)', 'RF_TR', 'KontoplanCustomHierarchy', '*', 1);
Drop Table KontoplanCustomHierarchyTmp;


/*
Kontostruktur_Custom_temp2:
NoConcatenate
LOAD Distinct
	Kontenschluessel as %KontoKeyFull,
	ReferenzNrKonto_temp as %ReferenzNrKonto,
    Kontoname,
//    Kontoname_technisch,
    Kontoname_zh,
    UeberKontoKey,
    UeberKonto,
    ApplyMap('Map_AccountName', UeberKonto, null()) as UeberKontoName,
    ParentKontoKey,
    ParentKonto,
    ApplyMap('Map_AccountName', ParentKonto, null()) as ParentKontoName,
    ParentOfParentKontoKey,
    ParentOfParentKonto,
    ApplyMap('Map_AccountName', ParentOfParentKonto, null()) as ParentofParentName,
    CombKontoKey,
    CombParentKonto,
    // tpl erfolg
    //OLD
    //ApplyMap('Map_AccountName', CombParentKonto, null()) as CombParentKontoName, 
    //NEW       
    if(CombParentKonto='Erfolg', 'Erfolg', ApplyMap('Map_AccountName', CombParentKonto, null())) as CombParentKontoName,  
    ParentOfAllKey,
    'Erfolg' as ParentOfAllName,
    
    Kontolevel,
//     Kontoplan,
    Aktiv,
    Typ,
    KeyFiguresKontoName,
    KeyFiguresFaktor,
    KeyFiguresSort,
    GruppenKontoL0,
    GruppenKontoL1,
    GruppenKontoL2,
    GruppenKontoL3,
    GruppenKontoL4,
    GruppenKontoL5,
	GruppenSortL0,
//    If(Len(Trim(GruppenKontoL0))>0, GruppenKontoL0, KeyFiguresKontoName) as %KeyFiguresKontoName,
    GruppenSortL1,
    GruppenSortL2,
    GruppenSortL3,
    GruppenSortL4,
    GruppenSortL5,    
    If(Match(Left(ReferenzNrKonto_temp,1), '1', '4')>0, -1, 1) as Faktor
;
// Preceding load
LOAD
	*,
    ApplyMap('Map_KeyFigGruppenKontoL0', KeyFiguresKontoName, null()) as GruppenKontoL0,
    ApplyMap('Map_KeyFigGruppenKontoL1', KeyFiguresKontoName, null()) as GruppenKontoL1,
    ApplyMap('Map_KeyFigGruppenKontoL2', KeyFiguresKontoName, null()) as GruppenKontoL2,
    ApplyMap('Map_KeyFigGruppenKontoL3', KeyFiguresKontoName, null()) as GruppenKontoL3,
    ApplyMap('Map_KeyFigGruppenKontoL4', KeyFiguresKontoName, null()) as GruppenKontoL4,
    ApplyMap('Map_KeyFigGruppenKontoL5', KeyFiguresKontoName, null()) as GruppenKontoL5,
	ApplyMap('Map_KeyFigGruppenSortL0', KeyFiguresKontoName, null()) as GruppenSortL0,
    ApplyMap('Map_KeyFigGruppenSortL1', KeyFiguresKontoName, null()) as GruppenSortL1,
    ApplyMap('Map_KeyFigGruppenSortL2', KeyFiguresKontoName, null()) as GruppenSortL2,
    ApplyMap('Map_KeyFigGruppenSortL3', KeyFiguresKontoName, null()) as GruppenSortL3,
    ApplyMap('Map_KeyFigGruppenSortL4', KeyFiguresKontoName, null()) as GruppenSortL4,
    ApplyMap('Map_KeyFigGruppenSortL5', KeyFiguresKontoName, null()) as GruppenSortL5
;
// Preceding load (mappings)
LOAD
	*,
//     ApplyMap('Map_Kundenkonto', CombKontoKey, null()) as CombParentKonto,
    if(CombKontoKey='0', '00', ApplyMap('Map_Kundenkonto', CombKontoKey, null())) as CombParentKonto, // tpl erfolg
    ApplyMap('Map_ParentAccount', ParentKontoKey, null()) as ParentKonto,
	ApplyMap('Map_OneLevelUpAccount', UeberKontoKey, null()) as UeberKonto,
    ApplyMap('Map_KeyFiguresAccounts', ReferenzNrKonto_temp, null()) as KeyFiguresKontoName,
    ApplyMap('Map_KeyFiguresFaktor', ReferenzNrKonto_temp, null()) as KeyFiguresFaktor,
    ApplyMap('Map_KeyFiguresSort', ReferenzNrKonto_temp, null()) as KeyFiguresSort
;
// Preceding load
LOAD
	*,
//     If(Kontolevel=4, UeberKontoKey, If(Kontolevel=3, ParentKontoKey, If(Kontolevel=2, ParentOfParentKontoKey, Kontenschluessel))) as CombKontoKey
    If(Kontolevel=4, UeberKontoKey, If(Kontolevel=3, ParentKontoKey, If(Kontolevel=2, ParentOfParentKontoKey, If(Kontolevel=1, ParentOfAllKey, Kontenschluessel)))) as CombKontoKey // tpl erfolg
;
// Preceding load
LOAD
	*,
    SubField(Kontenschluessel, '-', 1) &'-'& SubField(Kontenschluessel, '-', 2) as ParentKontoKey,
    SubField(Kontenschluessel, '-', 1) &'-'& SubField(Kontenschluessel, '-', 2) &'-'& SubField(Kontenschluessel, '-', 3)as UeberKontoKey,
    SubField(Kontenschluessel, '-', 1) as ParentOfParentKontoKey,
    left(Kontenschluessel, 1)&'0' as ParentOfParentKonto,
    '0' as ParentOfAllKey, // tpl erfolg
    SubField(Kontenschluessel, '-', 3) as KontoKey
;
// Preceding load
LOAD
	*,
    SubStringCount(Kontenschluessel,'-') + 1 as Kontolevel,
    if(WildMatch(ReferenzNrKonto, '*Moved*') ,left(ReferenzNrKonto,5), ReferenzNrKonto) as ReferenzNrKonto_temp

// FROM [$(vSourcePath)DS_api_Kontoplan.qvd]
// (qvd)
// WHERE Match(Aktiv, 'True')>0;
resident KontoplanCustomTree //tpl erfolg
WHERE Match(Aktiv, 'True')>0;
drop table KontoplanCustomTree; //tpl erfolg

LEFT JOIN (Kontostruktur_Custom_temp2)
LOAD Distinct
	Kontoname_technisch as Konto_SIA,
    Kontenschluessel as %KontoKeyFull
    
FROM [$(vSourcePath)DS_api_Kontoplan.qvd]
(qvd)
WHERE Match(Kontoplan, 'SIA') >0;    

LEFT JOIN (Kontostruktur_Custom_temp2)
LOAD Distinct
	Kontoname_technisch as Konto_KKV,
    Kontenschluessel as %KontoKeyFull
    
FROM [$(vSourcePath)DS_api_Kontoplan.qvd]
(qvd)
WHERE Match(Kontoplan, 'KKV') >0;    

LEFT JOIN (Kontostruktur_Custom_temp2)
LOAD Distinct
	Kontoname_technisch as Konto_VermgsRechn,
    Kontenschluessel as %KontoKeyFull
    
FROM [$(vSourcePath)DS_api_Kontoplan.qvd]
(qvd)
WHERE Match(Kontoplan, 'ASSET_STATEMENT_LAW_OF_BONDS') >0;    


Kontostruktur_Custom_temp:
Hierarchy (%ReferenzNrKonto, CombParentKonto, Kontoname, Account, Name, PortfolioPath, '/', Depth)
LOAD Distinct
	%ReferenzNrKonto, 
    CombParentKonto,
    Kontoname,
    %KontoKeyFull,
    Kontoname_zh,
    UeberKontoKey,
    UeberKonto,
    UeberKontoName,
    ParentKontoKey,
    ParentKonto,
    ParentKontoName,
    ParentOfParentKontoKey,
    ParentOfParentKonto,
    ParentofParentName,
    ParentOfAllKey, //tpl erfolg
    ParentOfAllName, //tpl erfolg
    CombKontoKey,
    CombParentKontoName,  
    Kontolevel,
    Aktiv,
    Typ,
    KeyFiguresKontoName,
    KeyFiguresFaktor,
    GruppenKontoL0,
    GruppenKontoL1,
    GruppenKontoL2,
    GruppenKontoL3,
    GruppenKontoL4,
    GruppenKontoL5,
    KeyFiguresSort,
	GruppenSortL0,
    GruppenSortL1,
    GruppenSortL2,
    GruppenSortL3,
    GruppenSortL4,
    GruppenSortL5,    
    Faktor,
    Konto_SIA,
    Konto_VermgsRechn
    
Resident Kontostruktur_Custom_temp2;
DROP TABLE Kontostruktur_Custom_temp2;

Ancestry_Kto_temp:
HierarchyBelongsTo(NodeID, AncestorID, PlanLevelName, AncestorID, AncestorName, DepthDiff)
Load Distinct %ReferenzNrKonto as NodeID, CombParentKonto as AncestorID, Kontoname as PlanLevelName Resident Kontostruktur_Custom_temp;

LEFT JOIN (Kontostruktur_Custom_temp)
LOAD Distinct
	NodeID as %ReferenzNrKonto,
    PlanLevelName as KontoNameAnc,
    AncestorID as KtoAncestorID,
    AncestorName as KontoRollup,
    DepthDiff as KtoDepth
Resident Ancestry_Kto_temp;
DROP TABLE Ancestry_Kto_temp;

// Store QVD
Call QvdStore ('Kontostruktur_Custom_temp', '$(vStorePath)', 'temp', 'KontostrukturCustom', '*', 1);
*/

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_KtoCustom = (now() - vStartTime_KtoCustom)*86400;
Trace ---------------------------------- Ktostruktur Custom geladen ----------------------------------;
Trace $(vElapsed_KtoCustom);
//********************************************************************************************
///$tab 1.2 Konto_HierarchyDIM (neu)
//********************************* Zeitmessung Mapping *********************************
// SET vStartTime_KtoDim = 0;
// Set vElapsed_KtoDim = 0;
Let vStartTime_KtoDim  = now();

//*************************************************************************************

// Kontohierarchien
// Dimensions
StandardKonti:
NoConcatenate
LOAD Distinct
    KontoNameKonto                                              as KontoName
    , [KontoNameKonto]                                          as KontoNr
FROM [$(vSourcePath)DS_api_StandardKonti.qvd] (qvd)
WHERE Not IsNull([KontoNameKonto]);
Call QvdStoreDebug ('StandardKonti', vStorePath, 'StandardKonti_000');


KontoplanDimTree:
NoConcatenate Load Distinct
    account_key         AS NodeID           // COSTS_CAPITAL-EXPENDITURE_TENANT-EXTENSION
    , account_parent    AS ParentNodeID     // COSTS_CAPITAL-EXPENDITURE
    , origin            AS PlanLevelOrigin
    // , account_level
    , sort_code         AS PlanLevelSort
    , if (Left (account_factor, 1)='N', -1, 1)    AS PlanLevelFactor
FROM [$(vStorePath)KontoZusatzinformationen.qvd] (qvd)
;
Call QvdStoreDebug ('KontoplanDimTree', vStorePath, 'KontoplanDimTree_000');
Left Join (KontoplanDimTree) Load Distinct
    KontoName           AS NodeID // join field
    // , Bezeichnung       AS PlanLevelBezeichnung
  	// , KontoRGB          AS PlanLevelRGB
    // , KontoSortierung   AS PlanLevelSortierung
    , KontoNr           AS PlanLevelKontoNr
Resident StandardKonti;
Call QvdStoreDebug ('KontoplanDimTree', vStorePath, 'KontoplanDimTree_001');
Drop Table StandardKonti;


// Die Hierarchie-Berechnung
// Wir generieren hier nicht den Namen für jedes Level, sondern nehmen gleich den NodeID -> NodeIDLevel1..x. 
// So können sind wir nachher flexibler und können danach joinen, was wir brauchen.
KontoplanDimHierarchy:
Hierarchy (NodeID, ParentNodeID, NodeIDLevel, , , , '$(vKeySep)', Depth) 
LOAD 
    // , if (Len (PlanLevelID)>=5, 1, 0) AS IstKontoLevel
    NodeID
    , NodeID       AS NodeIDLevel
    , ParentNodeID
Resident KontoplanDimTree;
// Hier haben wir das Gerüst der Hierarchie Tabelle, welche ev. noch bereichert werden muss  
Call QvdStoreDebug ('KontoplanDimHierarchy', vStorePath, 'KontoplanDimHierarchy_000');

// Anzahl der Ebenen bestimmen
KontoplanDimLevels:
NoConcatenate Load
    Max(Depth) AS MaxDepth
Resident KontoplanDimHierarchy
Group By 1;
LET vMaxDepth = peek ('MaxDepth', 0, 'KontoplanDimLevels');
Drop Table KontoplanDimLevels;
TRACE MaxDepth = $(vMaxDepth);

LET vIstKontoLevelExpression = '';
FOR vLevel = vMaxDepth to 1 step -1 // es wird down geloopt
    LET vIstKontoLevelExpression = vIstKontoLevelExpression & 'if (Len (NodeIDLevel$(vLevel))>0, $(vLevel), ';

    Left Join (KontoplanDimHierarchy) Load
        *
        , PlanLevelID$(vLevel) & ' ' & PlanLevelName$(vLevel) AS PlanLevelIDName$(vLevel)
    ;
    Load
        NodeID                  AS NodeIDLevel$(vLevel) // join field
        , NodeID                AS PlanLevelID$(vLevel) 
        , PlanLevelOrigin       AS PlanLevelOrigin$(vLevel)
        , PlanLevelFactor       AS PlanLevelFactor$(vLevel)
        , PlanLevelSort         AS PlanLevelSort$(vLevel)
        , ApplyMap ('MappingKonto', NodeID, null())        as PlanLevelName$(vLevel)
        , ApplyMap ('MappingKontoRGB', NodeID, null())     as PlanLevelRGB$(vLevel)
        , ApplyMap ('MappingKontoOrder', NodeID, null())   as PlanLevelSortierung$(vLevel)
    Resident KontoplanDimTree;
Next 
Call QvdStoreDebug ('KontoplanDimHierarchy', vStorePath, 'KontoplanDimHierarchy_001');
LET vIstKontoLevelExpression = vIstKontoLevelExpression & repeat (')', vMaxDepth); // Klammern schliessen

// Unterster Level joinen
Left Join (KontoplanDimHierarchy) Load
    *
    , PlanLevelID & ' ' & PlanLevelName AS PlanLevelIDName
;
Load
    NodeID                  AS NodeIDLevel // join field
    , NodeID                AS PlanLevelID 
    , PlanLevelOrigin       AS PlanLevelOrigin
    , PlanLevelFactor       AS PlanLevelFactor
    , PlanLevelSort         AS PlanLevelSort
    , ApplyMap ('MappingKonto', NodeID, null())        as PlanLevelName
    , ApplyMap ('MappingKontoRGB', NodeID, null())     as PlanLevelRGB
    , ApplyMap ('MappingKontoOrder', NodeID, null())   as PlanLevelSortierung
Resident KontoplanDimTree;
Call QvdStoreDebug ('KontoplanDimHierarchy', vStorePath, 'KontoplanDimHierarchy_002');
Drop Table KontoplanDimTree;

// Zusammenstellen der Feld expressions
FieldExpressions:
NoConcatenate Load
    Concat (Field_PlanLevelIDName, ', ')    AS Fields_PlanLevelIDName
    , Concat (Field_PlanLevelID, ', ')      AS Fields_PlanLevelID
    , Concat (Field_PlanLevelName, ', ')    AS Fields_PlanLevelName
Group By 1;
Load
    'PlanLevelIDName' & IterNo()    AS Field_PlanLevelIDName
    , 'PlanLevelID' & IterNo()      AS Field_PlanLevelID
    , 'PlanLevelName' & IterNo()    AS Field_PlanLevelName
    , 'if (Len (NodeIDLevel' & $(vMaxDepth) - IterNo() + 1 & ')>0, '
Autogenerate 1
while (IterNo () <= $(vMaxDepth));
Call QvdStoreDebug ('FieldExpressions', vStorePath, 'FieldExpressions');
LET vFields_PlanLevelIDName = peek ('Fields_PlanLevelIDName', 0, 'FieldExpressions');  // PlanLevelIDName1, PlanLevelIDName2, PlanLevelIDName..
LET vFields_PlanLevelID     = peek ('Fields_PlanLevelID', 0, 'FieldExpressions');       // PlanLevelID1, PlanLevelID2, PlanLevelID..
LET vFields_PlanLevelName   = peek ('Fields_PlanLevelName', 0, 'FieldExpressions');      // PlanLevelName1, PlanLevelName2, PlanLevelName..
Drop Table FieldExpressions;

// exit script;
// Finale Tabelle
Rename Table KontoplanDimHierarchy To KontoplanDimHierarchyTmp;
KontoplanDimHierarchy:
NoConcatenate Load
    *
// Where (IstKontoLevel = 1)
;
Load
    *
    // , if (KontoLevel = Depth, 1, 0) AS IstKontoLevel
    , 1 AS IstKontoLevel // ist nicht ermittelbar!
    ;
Load
    Depth
    // , IstKontoLevel
    , [PlanLevelIDName]
    , $(vFields_PlanLevelIDName)
    , PlanLevelID
    , $(vFields_PlanLevelID)
    , PlanLevelName
    , $(vFields_PlanLevelName)
    , $(vIstKontoLevelExpression) AS KontoLevel
    // , ParentNodeID
    , PlanLevelID as %KontoDim
Resident KontoplanDimHierarchyTmp;
Call QvdStore ('KontoplanDimHierarchy', '$(vStorePath)', 'RF_TR', 'KontoplanDimHierarchy', '*', 1);
Drop Table KontoplanDimHierarchyTmp;


/*
Kontostruktur_Dimensions_temp2:
NoConcatenate
LOAD Distinct
    KontoNameKonto as KontoName,
    ApplyMap('MappingKonto', KontoNameKonto, null()) as Bezeichnung,
  	ApplyMap('MappingKontoRGB',[KontoNameKonto], null()) as KontoRGB,
    ApplyMap('MappingKontoOrder',[KontoNameKonto], null()) as KontoSortierung,
    [KontoNameKonto] as %ReferenzNrKonto
FROM [$(vSourcePath)DS_api_StandardKonti.qvd]
(qvd)
WHERE Not IsNull([KontoNameKonto]);

Left Join (Kontostruktur_Dimensions_temp2)
LOAD Distinct
	[account_key] as [KontoName],
    [account_parent] as [ElternKonto],
    [account_factor] as [KontoFaktor],
    [account_level] as Kontolevel,
    KeyFiguresKontoName_CF as KeyFiguresKontoName,
	KeyFiguresFaktor_CF as KeyFiguresFaktor,
    KeyFiguresSort_CF as KeyFiguresSort,
    GruppenKontoL0_CF,
    GruppenKontoL1_CF,
    GruppenKontoL2_CF,
    GruppenKontoL3_CF,
    GruppenKontoL4_CF,
    GruppenKontoL5_CF,
	GruppenSortL0_CF,
    GruppenSortL1_CF,
    GruppenSortL2_CF,
    GruppenSortL3_CF,
    GruppenSortL4_CF,
    GruppenSortL5_CF,
    If(Match([account_factor], 'NEGATIVE')>0, -1, 1) as Faktor
;
// Preceding load
LOAD
	*,
    ApplyMap('Map_REVKeyFigGruppenKontoL0', KeyFiguresKontoName_CF, null()) as GruppenKontoL0_CF,
    ApplyMap('Map_REVKeyFigGruppenKontoL1', KeyFiguresKontoName_CF, null()) as GruppenKontoL1_CF,
    ApplyMap('Map_REVKeyFigGruppenKontoL2', KeyFiguresKontoName_CF, null()) as GruppenKontoL2_CF,
    ApplyMap('Map_REVKeyFigGruppenKontoL3', KeyFiguresKontoName_CF, null()) as GruppenKontoL3_CF,
    ApplyMap('Map_KeyFigGruppenKontoL4', KeyFiguresKontoName_CF, null()) as GruppenKontoL4_CF,
    ApplyMap('Map_REVKeyFigGruppenKontoL5', KeyFiguresKontoName_CF, null()) as GruppenKontoL5_CF,
	ApplyMap('Map_REVKeyFigGruppenSortL0', KeyFiguresKontoName_CF, null()) as GruppenSortL0_CF,
    ApplyMap('Map_REVKeyFigGruppenSortL1', KeyFiguresKontoName_CF, null()) as GruppenSortL1_CF,
    ApplyMap('Map_REVKeyFigGruppenSortL2', KeyFiguresKontoName_CF, null()) as GruppenSortL2_CF,
    ApplyMap('Map_REVKeyFigGruppenSortL3', KeyFiguresKontoName_CF, null()) as GruppenSortL3_CF,
    ApplyMap('Map_REVKeyFigGruppenSortL4', KeyFiguresKontoName_CF, null()) as GruppenSortL4_CF,
    ApplyMap('Map_REVKeyFigGruppenSortL5', KeyFiguresKontoName_CF, null()) as GruppenSortL5_CF
;
// Preceding load
LOAD
	*,
	ApplyMap('Map_KeyFiguresAccounts_Rev', [account_key], null()) as KeyFiguresKontoName_CF,
    ApplyMap('Map_KeyFiguresFaktor_Rev', [account_key], null()) as KeyFiguresFaktor_CF,
    ApplyMap('Map_KeyFiguresSort_Rev', [account_key], null()) as KeyFiguresSort_CF

FROM [$(vStorePath)KontoZusatzinformationen.qvd]
(qvd);

LEFT JOIN (Kontostruktur_Dimensions_temp2)
LOAD Distinct
	[account_key] as KontoName,
    [sort_code] as KtoSortKey
    
FROM [$(vStorePath)KontoZusatzinformationen.qvd]
(qvd);

Kontostruktur_Dimensions_temp:
Hierarchy(KontoName, ElternKonto, Bezeichnung, ParentName, Bezeichnung, PathName, '\', Depth)
LOAD Distinct
  	ElternKonto,
  	KontoName,
    %ReferenzNrKonto,
  	Bezeichnung,
  	KontoRGB,
    KontoSortierung,
  	KontoFaktor,
    Kontolevel,
//  	KontoName as %BewKontoKey,
    KeyFiguresKontoName,
    KeyFiguresFaktor,
    KeyFiguresSort,
    KtoSortKey,
    GruppenKontoL0_CF,
    GruppenKontoL1_CF,
    GruppenKontoL2_CF,
    GruppenKontoL3_CF,
    GruppenKontoL4_CF,
    GruppenKontoL5_CF,
	GruppenSortL0_CF,
    GruppenSortL1_CF,
    GruppenSortL2_CF,
    GruppenSortL3_CF,
    GruppenSortL4_CF,
    GruppenSortL5_CF,
    Faktor
    
Resident Kontostruktur_Dimensions_temp2;
Drop Table Kontostruktur_Dimensions_temp2;

LEFT JOIN (Kontostruktur_Dimensions_temp)
LOAD Distinct
	KontoName as ElternKonto,
    ElternKonto as ElternVonElternKonto

Resident Kontostruktur_Dimensions_temp;

Concatenate (Kontostruktur_Dimensions_temp)
LOAD Distinct  
    'Marktwert' as ElternKonto,
  	'Marktwert' as KontoName,
    'Marktwert' as %ReferenzNrKonto,
  	'Marktwert' as Bezeichnung,
  	'RGB(145,145,145)' as KontoRGB,
    '99999' as KontoSortierung,
  	'POSITIVE' as KontoFaktor,
    '4' as Kontolevel,
//  	'9-99' as %BewKontoKey,
    'Marktwert' as KeyFiguresKontoName,
    '1' as KeyFiguresFaktor,
    'A999' as KeyFiguresSort,
    '99999' as KtoSortKey,
    'Marktwert' as GruppenKontoL0_CF,
    'Marktwert' as GruppenKontoL1_CF,
    'Marktwert' as GruppenKontoL2_CF,
    'Marktwert' as GruppenKontoL3_CF,
    'Marktwert' as GruppenKontoL4_CF,
    'Marktwert' as GruppenKontoL5_CF,
	'A999' as GruppenSortL0_CF,
    'A999' as GruppenSortL1_CF,
    'A999' as GruppenSortL2_CF,
    'A999' as GruppenSortL3_CF,
    'A999' as GruppenSortL4_CF,
    'A999' as GruppenSortL5_CF,
    '1' as Faktor

Resident Kontostruktur_Dimensions_temp;

Ancestry_Kto_Dim_temp:
HierarchyBelongsTo(NodeID, AncestorID, PlanLevelName, AncestorID, AncestorName, DepthDiff)
Load Distinct KontoName as NodeID, ElternKonto as AncestorID, Bezeichnung as PlanLevelName Resident Kontostruktur_Dimensions_temp;

LEFT JOIN (Kontostruktur_Dimensions_temp)
LOAD Distinct
	NodeID as KontoName,
    PlanLevelName as BezeichnungAnc,
    AncestorID as KtoAncestorID,
    AncestorName as KontoRollup,
    DepthDiff as KtoDepth
Resident Ancestry_Kto_Dim_temp;
DROP TABLE Ancestry_Kto_Dim_temp;

// Store QVD
Call QvdStore ('Kontostruktur_Dimensions_temp', '$(vStorePath)', 'temp', 'KontostrukturDimensions', '*', 1);
*/



//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_KtoDim = (now() - vStartTime_KtoDim)*86400;
Trace ---------------------------------- Ktostruktur Dim geladen ----------------------------------;
Trace $(vElapsed_KtoDim);
//********************************************************************************************
///$tab 1.3 Konto_HierarchySIA (neu)
//********************************* Zeitmessung Mapping *********************************
// SET vStartTime_KtoSIA = 0;
// Set vElapsed_KtoSIA = 0;
Let vStartTime_KtoSIA  = now();

//*************************************************************************************

// Kontohierarchien
// SIA-Konten


KontoplanSIATree:
NoConcatenate Load Distinct
    Konto           AS NodeID           // L1_ASSETS_CASH_ON_HAND_POSTAL_CHECK_AND_BANK_DEPOSITS
    , KontoParent   AS ParentNodeID     // L0_ASSETS
    , ExterneID     AS PlanLevelID
    , KontonameDe   AS PlanLevelName
//    , Kontolevel
FROM [$(vSourcePath)DS_api_Kontobaum.qvd] (qvd)
where (KontoTyp = 'SIA');
Call QvdStoreDebug ('KontoplanSIATree', vStorePath, 'KontoplanSIATree_000');


// Die Hierarchie-Berechnung
// Wir generieren hier nicht den Namen für jedes Level, sondern nehmen gleich den NodeID -> NodeIDLevel1..x. 
// So können sind wir nachher flexibler und können danach joinen, was wir brauchen.
KontoplanSIAHierarchy:
Hierarchy (NodeID, ParentNodeID, NodeIDLevel, , , , '$(vKeySep)', Depth) 
LOAD 
    NodeID
    , NodeID       AS NodeIDLevel
    , ParentNodeID
Resident KontoplanSIATree;
// Hier haben wir das Gerüst der Hierarchie Tabelle, welche ev. noch bereichert werden muss  
Call QvdStoreDebug ('KontoplanSIAHierarchy', vStorePath, 'KontoplanSIAHierarchy_000');

// Anzahl der Ebenen bestimmen
KontoplanSIALevels:
NoConcatenate Load
    Max(Depth) AS MaxDepth
Resident KontoplanSIAHierarchy
Group By 1;
LET vMaxDepth = peek ('MaxDepth', 0, 'KontoplanSIALevels');
Drop Table KontoplanSIALevels;
TRACE MaxDepth = $(vMaxDepth);

LET vIstKontoLevelExpression = '';
FOR vLevel = vMaxDepth to 1 step -1 // es wird down geloopt
    LET vIstKontoLevelExpression = vIstKontoLevelExpression & 'if (Len (NodeIDLevel$(vLevel))>0, $(vLevel), ';

    Left Join (KontoplanSIAHierarchy) Load
        *
        , PlanLevelID$(vLevel) & ' ' & PlanLevelName$(vLevel) AS PlanLevelIDName$(vLevel)
    ;
    Load
        NodeID          AS NodeIDLevel$(vLevel) // join field
        , NodeID        AS PlanLevelIDTech$(vLevel)
        , PlanLevelID   AS PlanLevelID$(vLevel)
        , PlanLevelName AS PlanLevelName$(vLevel)
    Resident KontoplanSIATree;
Next 
Call QvdStoreDebug ('KontoplanSIAHierarchy', vStorePath, 'KontoplanSIAHierarchy_001');
LET vIstKontoLevelExpression = vIstKontoLevelExpression & repeat (')', vMaxDepth); // Klammern schliessen

// Unterster Level joinen
Left Join (KontoplanSIAHierarchy) Load
    *
    , PlanLevelID & ' ' & PlanLevelName AS PlanLevelIDName
;
Load
    NodeID                  AS NodeIDLevel // join field
    , NodeID                AS PlanLevelIDTech
    , PlanLevelID           AS PlanLevelID
    , PlanLevelName         AS PlanLevelName
Resident KontoplanSIATree;
Call QvdStoreDebug ('KontoplanSIAHierarchy', vStorePath, 'KontoplanSIAHierarchy_002');
Drop Table KontoplanSIATree;

// Zusammenstellen der Feld expressions
FieldExpressions:
NoConcatenate Load
    Concat (Field_PlanLevelIDName, ', ')    AS Fields_PlanLevelIDName
    , Concat (Field_PlanLevelID, ', ')      AS Fields_PlanLevelID
    , Concat (Field_PlanLevelIDTech, ', ')  AS Fields_PlanLevelIDTech
    , Concat (Field_PlanLevelName, ', ')    AS Fields_PlanLevelName
Group By 1;
Load
    'PlanLevelIDName' & IterNo()    AS Field_PlanLevelIDName
    , 'PlanLevelIDTech' & IterNo()  AS Field_PlanLevelIDTech
    , 'PlanLevelID' & IterNo()      AS Field_PlanLevelID
    , 'PlanLevelName' & IterNo()    AS Field_PlanLevelName
    , 'if (Len (NodeIDLevel' & $(vMaxDepth) - IterNo() + 1 & ')>0, '
Autogenerate 1
while (IterNo () <= $(vMaxDepth));
Call QvdStoreDebug ('FieldExpressions', vStorePath, 'FieldExpressions');
LET vFields_PlanLevelIDName = peek ('Fields_PlanLevelIDName', 0, 'FieldExpressions');  // PlanLevelIDName1, PlanLevelIDName2, PlanLevelIDName..
LET vFields_PlanLevelID     = peek ('Fields_PlanLevelID', 0, 'FieldExpressions');       // PlanLevelID1, PlanLevelID2, PlanLevelID..
LET vFields_PlanLevelIDTech = peek ('Fields_PlanLevelIDTech', 0, 'FieldExpressions');       // PlanLevelIDTech1, PlanLevelIDTech2, PlanLevelIDTech..
LET vFields_PlanLevelName   = peek ('Fields_PlanLevelName', 0, 'FieldExpressions');      // PlanLevelName1, PlanLevelName2, PlanLevelName..
Drop Table FieldExpressions;

// exit script;
// Finale Tabelle
Rename Table KontoplanSIAHierarchy To KontoplanSIAHierarchyTmp;
KontoplanSIAHierarchy:
NoConcatenate Load
    *
Where (IstKontoLevel = 1);
Load
    *
    // , if (Len(PlanLevelID) >= 5, 1, 0) AS IstKontoLevel
    , 1 AS IstKontoLevel // ist nicht ermittelbar
    ;
Load
    Depth
    // , IstKontoLevel
    , [PlanLevelIDName]
    , $(vFields_PlanLevelIDName)
    , PlanLevelID
    , $(vFields_PlanLevelID)
    , PlanLevelIDTech
    // , $(vFields_PlanLevelIDTech)
    , PlanLevelName
    , $(vFields_PlanLevelName)
    , $(vIstKontoLevelExpression) AS Kontolevel
//    , ParentNodeID
    , PlanLevelID as %KontoSIA 
Resident KontoplanSIAHierarchyTmp;
Call QvdStore ('KontoplanSIAHierarchy', '$(vStorePath)', 'RF_TR', 'KontoplanSIAHierarchy', '*', 1);
Drop Table KontoplanSIAHierarchyTmp;

/*
Kontostruktur_SIA_temp2:
NoConcatenate
LOAD Distinct
    KontoTyp,
    KontonameDe,
    "KontonameDe-D",
    KontonameEN,
    ExterneID as KontoNum,
    SIAKtoNum as %ReferenzNrKonto,
//    ParentKontoNum,
    ParentKontoNum_new as ParentKontoNum,
    KontonameFR,
    "KontonameFR-F",
    KontoGruppe,
    KontonameIT,
    Konto as KontoTechName,
    Kontolevel,
//    KontoParent as ParentKontoTechName,
	If(Len(Trim(KontoParent))>0, KontoParent, ApplyMap('Map_KontobaumRev', ParentKontoNum_new, Null())) as ParentKontoTechName,
    KontonameZH,
//    Sort_temp as Sort,
	If(Num(ExterneID)/100<1, Num(ExterneID)*100, If(Num(Kontolevel)<2, Num(ExterneID), Num(Num(ParentKontoNum_new) &'.'& Right(ExterneID,2))))  as Sort,
    _KEY_content,
    _KEY_root,
    ApplyMap('Map_KeyFiguresAccounts', SIAtoCustomAccount, null()) as KeyFiguresKontoName,
;
// Preceding load
LOAD
	*,
    If(Num(Kontolevel) = 0, 
     If(Num(ExterneID)<4, 4, 
      If(Num(ExterneID)<7, 7, 
       If(Num(ExterneID)<8, 8, 
        If(Num(ExterneID)<14, 14, 
         If(Num(ExterneID)<16, 16, 
          If(Num(ExterneID)<20, 20, Null())))))),
      ApplyMap('Map_Kontobaum', KontoParent, Null())) as ParentKontoNum_new,
//    ApplyMap('Map_Kontobaum', KontoParent, Null()) as ParentKontoNum,
    Num(ExterneID) as SIAKtoNum,
    ApplyMap('Map_SIAtoCustom', Num(ExterneID), Null()) as SIAtoCustomAccount
         
FROM [$(vSourcePath)DS_api_Kontobaum.qvd]
(qvd);


Kontostruktur_SIA_temp:
Hierarchy (KontoNum, ParentKontoNum, KontonameDe, Account, Name, PortfolioPath, '/', Depth)
LOAD Distinct
	KontoNum,
    %ReferenzNrKonto,
    ParentKontoNum,
    KontoGruppe,
    KontonameDe as Kontoname,
    KontonameDe,
    "KontonameDe-D" as KontonameDe_D,
    KontonameEN,
    KontonameFR,
    "KontonameFR-F" as KontonameFR_F,
    KontonameIT,
    KontonameZH,
    KontoTechName,
    KontoTyp,
    Kontolevel,
    Sort,
    KeyFiguresKontoName
Resident Kontostruktur_SIA_temp2
//WHERE Match(KontoTyp, 'SIA')>0
;
DROP TABLE Kontostruktur_SIA_temp2;

Ancestry_Kto_SIA_temp:
HierarchyBelongsTo(NodeID, AncestorID, PlanLevelName, AncestorID, AncestorName, DepthDiff)
Load Distinct KontoNum as NodeID, ParentKontoNum as AncestorID, Kontoname as PlanLevelName Resident Kontostruktur_SIA_temp;

LEFT JOIN (Kontostruktur_SIA_temp)
LOAD Distinct
	NodeID as KontoNum,
    PlanLevelName as KontoNameAnc,
    AncestorID as KtoAncestorID,
    AncestorName as KontoRollup,
    DepthDiff as KtoDepth
Resident Ancestry_Kto_SIA_temp;
DROP TABLE Ancestry_Kto_SIA_temp;

// Store QVD
Call QvdStore ('Kontostruktur_SIA_temp', '$(vStorePath)', 'temp', 'KontostrukturSIA', '*', 1);
*/

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_KtoSIA = (now() - vStartTime_KtoSIA)*86400;
Trace ---------------------------------- Ktostruktur SIA geladen ----------------------------------;
Trace $(vElapsed_KtoSIA);
//********************************************************************************************


///$tab 1.4 Konto_HierarchyKKV (neu)
//********************************* Zeitmessung Mapping *********************************
// SET vStartTime_KtoKKV = 0;
// Set vElapsed_KtoKKV = 0;
Let vStartTime_KtoKKV  = now();

//*************************************************************************************

// Kontohierarchien
// KKV-Konten


KontoplanKKVTree:
NoConcatenate Load Distinct
    Konto           AS NodeID           // L1_INCOME_SHORT_TERM_INTEREST_BEARING_EFFECTS
    , KontoParent   AS ParentNodeID     // L0_INCOMES
    , Konto     AS PlanLevelID
    , KontonameDe   AS PlanLevelName
 //   , Kontolevel
    , SubField(_KEY_content, '$(vKeySep)', -1)*100 as Sort
FROM [$(vSourcePath)DS_api_Kontobaum.qvd] (qvd)
where (KontoTyp = 'KKV');
Call QvdStoreDebug ('KontoplanKKVTree', vStorePath, 'KontoplanKKVTree_000');


// Die Hierarchie-Berechnung
// Wir generieren hier nicht den Namen für jedes Level, sondern nehmen gleich den NodeID -> NodeIDLevel1..x. 
// So können sind wir nachher flexibler und können danach joinen, was wir brauchen.
KontoplanKKVHierarchy:
Hierarchy (NodeID, ParentNodeID, NodeIDLevel, , , , '$(vKeySep)', Depth) 
LOAD 
    NodeID
    , NodeID       AS NodeIDLevel
    , ParentNodeID
    , Sort
Resident KontoplanKKVTree;
// Hier haben wir das Gerüst der Hierarchie Tabelle, welche ev. noch bereichert werden muss  
Call QvdStoreDebug ('KontoplanKKVHierarchy', vStorePath, 'KontoplanKKVHierarchy_000');

// Anzahl der Ebenen bestimmen
KontoplanKKVLevels:
NoConcatenate Load
    Max(Depth) AS MaxDepth
Resident KontoplanKKVHierarchy
Group By 1;
LET vMaxDepth = peek ('MaxDepth', 0, 'KontoplanKKVLevels');
Drop Table KontoplanKKVLevels;
TRACE MaxDepth = $(vMaxDepth);

LET vIstKontoLevelExpression = '';
FOR vLevel = vMaxDepth to 1 step -1 // es wird down geloopt
    LET vIstKontoLevelExpression = vIstKontoLevelExpression & 'if (Len (NodeIDLevel$(vLevel))>0, $(vLevel), ';

    Left Join (KontoplanKKVHierarchy) Load
        *
        , PlanLevelID$(vLevel) & ' ' & PlanLevelName$(vLevel) AS PlanLevelIDName$(vLevel)
    ;
    Load
        NodeID          AS NodeIDLevel$(vLevel) // join field
        , NodeID        AS PlanLevelIDTech$(vLevel)
        , PlanLevelID   AS PlanLevelID$(vLevel)
        , PlanLevelName AS PlanLevelName$(vLevel)
    Resident KontoplanKKVTree;
Next 
Call QvdStoreDebug ('KontoplanKKVHierarchy', vStorePath, 'KontoplanKKVHierarchy_001');
LET vIstKontoLevelExpression = vIstKontoLevelExpression & repeat (')', vMaxDepth); // Klammern schliessen

// Unterster Level joinen
Left Join (KontoplanKKVHierarchy) Load
    *
    , PlanLevelID & ' ' & PlanLevelName AS PlanLevelIDName
;
Load
    NodeID                  AS NodeIDLevel // join field
    , NodeID                AS PlanLevelIDTech
    , PlanLevelID           AS PlanLevelID
    , PlanLevelName         AS PlanLevelName
Resident KontoplanKKVTree;
Call QvdStoreDebug ('KontoplanKKVHierarchy', vStorePath, 'KontoplanKKVHierarchy_002');
Drop Table KontoplanKKVTree;

// Zusammenstellen der Feld expressions
FieldExpressions:
NoConcatenate Load
    Concat (Field_PlanLevelIDName, ', ')    AS Fields_PlanLevelIDName
    , Concat (Field_PlanLevelID, ', ')      AS Fields_PlanLevelID
    , Concat (Field_PlanLevelIDTech, ', ')  AS Fields_PlanLevelIDTech
    , Concat (Field_PlanLevelName, ', ')    AS Fields_PlanLevelName
Group By 1;
Load
    'PlanLevelIDName' & IterNo()    AS Field_PlanLevelIDName
    , 'PlanLevelIDTech' & IterNo()  AS Field_PlanLevelIDTech
    , 'PlanLevelID' & IterNo()      AS Field_PlanLevelID
    , 'PlanLevelName' & IterNo()    AS Field_PlanLevelName
    , 'if (Len (NodeIDLevel' & $(vMaxDepth) - IterNo() + 1 & ')>0, '
Autogenerate 1
while (IterNo () <= $(vMaxDepth));
Call QvdStoreDebug ('FieldExpressions', vStorePath, 'FieldExpressions');
LET vFields_PlanLevelIDName = peek ('Fields_PlanLevelIDName', 0, 'FieldExpressions');  // PlanLevelIDName1, PlanLevelIDName2, PlanLevelIDName..
LET vFields_PlanLevelID     = peek ('Fields_PlanLevelID', 0, 'FieldExpressions');       // PlanLevelID1, PlanLevelID2, PlanLevelID..
LET vFields_PlanLevelIDTech = peek ('Fields_PlanLevelIDTech', 0, 'FieldExpressions');       // PlanLevelIDTech1, PlanLevelIDTech2, PlanLevelIDTech..
LET vFields_PlanLevelName   = peek ('Fields_PlanLevelName', 0, 'FieldExpressions');      // PlanLevelName1, PlanLevelName2, PlanLevelName..
Drop Table FieldExpressions;

// exit script;
// Finale Tabelle
Rename Table KontoplanKKVHierarchy To KontoplanKKVHierarchyTmp;
KontoplanKKVHierarchy:
NoConcatenate Load
    *
Where (IstKontoLevel = 1);
Load
    *
    // , if (Len(PlanLevelID) >= 5, 1, 0) AS IstKontoLevel
    , 1 AS IstKontoLevel // ist nicht ermittelbar
    ;
Load
    Depth
    // , IstKontoLevel
    , [PlanLevelIDName]
    , $(vFields_PlanLevelIDName)
    , PlanLevelID
    , $(vFields_PlanLevelID)
    , PlanLevelIDTech
    // , $(vFields_PlanLevelIDTech)
    , PlanLevelName
    , $(vFields_PlanLevelName)
    , $(vIstKontoLevelExpression) AS Kontolevel
//    , ParentNodeID
    , Sort
    , PlanLevelID as %KontoKKV
Resident KontoplanKKVHierarchyTmp;
Call QvdStore ('KontoplanKKVHierarchy', '$(vStorePath)', 'RF_TR', 'KontoplanKKVHierarchy', '*', 1);
Drop Table KontoplanKKVHierarchyTmp;

/*

Kontostruktur_KKV_temp2:
LOAD Distinct
    KontoTyp,
    KontonameDe,
    "KontonameDe-D",
    KontonameEN,
    KKVKtoNum as KontoNum,
    KKVKtoNum as %ReferenzNrKonto,
    ParentKontoNum_new as ParentKontoNum,
    KontonameFR,
    "KontonameFR-F",
    KontoGruppe,
    KontonameIT,
    Konto as KontoTechName,
    Kontolevel,
	KontoParent as ParentKontoTechName,
    KontonameZH,
	SubField(_KEY_content, '|', -1)*100 as Sort,
    _KEY_content,
    _KEY_root,
    ApplyMap('Map_KeyFiguresAccounts', KKVtoCustomAccount, null()) as KeyFiguresKontoName,
;
// Preceding load
LOAD
	*,
      KontoParent as ParentKontoNum_new,
      Konto as KKVKtoNum,
      ApplyMap('Map_KKVtoCustom', Konto, Null()) as KKVtoCustomAccount
         
FROM [$(vSourcePath)DS_api_Kontobaum.qvd]
(qvd)
WHERE Match(KontoTyp, 'KKV')>0;

Kontostruktur_KKV_temp:
Hierarchy (KontoNum, ParentKontoNum, KontonameDe, Account, Name, PortfolioPath, '/', Depth)
LOAD Distinct
	KontoNum,
    %ReferenzNrKonto,
    ParentKontoNum,
    KontoGruppe,
    KontonameDe as Kontoname,
    KontonameDe,
    "KontonameDe-D" as KontonameDe_D,
    KontonameEN,
    KontonameFR,
    "KontonameFR-F" as KontonameFR_F,
    KontonameIT,
    KontonameZH,
    KontoTechName,
    KontoTyp,
    Kontolevel,
    Sort,
    KeyFiguresKontoName
Resident Kontostruktur_KKV_temp2;
DROP TABLE Kontostruktur_KKV_temp2;

Ancestry_Kto_KKV_temp:
HierarchyBelongsTo(NodeID, AncestorID, NodeName, AncestorID, AncestorName, DepthDiff)
Load Distinct KontoNum as NodeID, ParentKontoNum as AncestorID, Kontoname as NodeName Resident Kontostruktur_KKV_temp;

LEFT JOIN (Kontostruktur_KKV_temp)
LOAD Distinct
	NodeID as KontoNum,
    NodeName as KontoNameAnc,
    AncestorID as KtoAncestorID,
    AncestorName as KontoRollup,
    DepthDiff as KtoDepth
Resident Ancestry_Kto_KKV_temp;
DROP TABLE Ancestry_Kto_KKV_temp;

// Store QVD
Call QvdStore ('Kontostruktur_KKV_temp', '$(vStorePath)', 'temp', 'KontostrukturKKV', '*', 1);

*/

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_KtoKKV = (now() - vStartTime_KtoKKV)*86400;
Trace ---------------------------------- Ktostruktur KKV geladen ----------------------------------;
Trace $(vElapsed_KtoKKV);
//********************************************************************************************


///$tab 1.5 Konto_HierarchyOR (neu)
//********************************* Zeitmessung Mapping *********************************
// SET vStartTime_KtoOR = 0;
// Set vElapsed_KtoOR = 0;
Let vStartTime_KtoOR  = now();

//*************************************************************************************

// Kontohierarchien
// OR-Konten


KontoplanORTree:
NoConcatenate Load Distinct
    Konto           AS NodeID           // L1_ACQUISITION_COST
    , KontoParent   AS ParentNodeID     // L0_PRIME_COST
    , Konto     AS PlanLevelID
    , KontonameDe   AS PlanLevelName
 //   , Kontolevel
    , SubField(_KEY_content, '$(vKeySep)', -1)*100 as Sort
FROM [$(vSourcePath)DS_api_Kontobaum.qvd] (qvd)
where (KontoTyp = 'ASSET_STATEMENT_LAW_OF_BONDS');
Call QvdStoreDebug ('KontoplanORTree', vStorePath, 'KontoplanORTree_000');


// Die Hierarchie-Berechnung
// Wir generieren hier nicht den Namen für jedes Level, sondern nehmen gleich den NodeID -> NodeIDLevel1..x. 
// So können sind wir nachher flexibler und können danach joinen, was wir brauchen.
KontoplanORHierarchy:
Hierarchy (NodeID, ParentNodeID, NodeIDLevel, , , , '$(vKeySep)', Depth) 
LOAD 
    NodeID
    , NodeID       AS NodeIDLevel
    , ParentNodeID
    , Sort
Resident KontoplanORTree;
// Hier haben wir das Gerüst der Hierarchie Tabelle, welche ev. noch bereichert werden muss  
Call QvdStoreDebug ('KontoplanORHierarchy', vStorePath, 'KontoplanORHierarchy_000');

// Anzahl der Ebenen bestimmen
KontoplanORLevels:
NoConcatenate Load
    Max(Depth) AS MaxDepth
Resident KontoplanORHierarchy
Group By 1;
LET vMaxDepth = peek ('MaxDepth', 0, 'KontoplanORLevels');
Drop Table KontoplanORLevels;
TRACE MaxDepth = $(vMaxDepth);

LET vIstKontoLevelExpression = '';
FOR vLevel = vMaxDepth to 1 step -1 // es wird down geloopt
    LET vIstKontoLevelExpression = vIstKontoLevelExpression & 'if (Len (NodeIDLevel$(vLevel))>0, $(vLevel), ';

    Left Join (KontoplanORHierarchy) Load
        *
        , PlanLevelID$(vLevel) & ' ' & PlanLevelName$(vLevel) AS PlanLevelIDName$(vLevel)
    ;
    Load
        NodeID          AS NodeIDLevel$(vLevel) // join field
        , NodeID        AS PlanLevelIDTech$(vLevel)
        , PlanLevelID   AS PlanLevelID$(vLevel)
        , PlanLevelName AS PlanLevelName$(vLevel)
    Resident KontoplanORTree;
Next 
Call QvdStoreDebug ('KontoplanORHierarchy', vStorePath, 'KontoplanORHierarchy_001');
LET vIstKontoLevelExpression = vIstKontoLevelExpression & repeat (')', vMaxDepth); // Klammern schliessen

// Unterster Level joinen
Left Join (KontoplanORHierarchy) Load
    *
    , PlanLevelID & ' ' & PlanLevelName AS PlanLevelIDName
;
Load
    NodeID                  AS NodeIDLevel // join field
    , NodeID                AS PlanLevelIDTech
    , PlanLevelID           AS PlanLevelID
    , PlanLevelName         AS PlanLevelName
Resident KontoplanORTree;
Call QvdStoreDebug ('KontoplanORHierarchy', vStorePath, 'KontoplanORHierarchy_002');
Drop Table KontoplanORTree;

// Zusammenstellen der Feld expressions
FieldExpressions:
NoConcatenate Load
    Concat (Field_PlanLevelIDName, ', ')    AS Fields_PlanLevelIDName
    , Concat (Field_PlanLevelID, ', ')      AS Fields_PlanLevelID
    , Concat (Field_PlanLevelIDTech, ', ')  AS Fields_PlanLevelIDTech
    , Concat (Field_PlanLevelName, ', ')    AS Fields_PlanLevelName
Group By 1;
Load
    'PlanLevelIDName' & IterNo()    AS Field_PlanLevelIDName
    , 'PlanLevelIDTech' & IterNo()  AS Field_PlanLevelIDTech
    , 'PlanLevelID' & IterNo()      AS Field_PlanLevelID
    , 'PlanLevelName' & IterNo()    AS Field_PlanLevelName
    , 'if (Len (NodeIDLevel' & $(vMaxDepth) - IterNo() + 1 & ')>0, '
Autogenerate 1
while (IterNo () <= $(vMaxDepth));
Call QvdStoreDebug ('FieldExpressions', vStorePath, 'FieldExpressions');
LET vFields_PlanLevelIDName = peek ('Fields_PlanLevelIDName', 0, 'FieldExpressions');  // PlanLevelIDName1, PlanLevelIDName2, PlanLevelIDName..
LET vFields_PlanLevelID     = peek ('Fields_PlanLevelID', 0, 'FieldExpressions');       // PlanLevelID1, PlanLevelID2, PlanLevelID..
LET vFields_PlanLevelIDTech = peek ('Fields_PlanLevelIDTech', 0, 'FieldExpressions');       // PlanLevelIDTech1, PlanLevelIDTech2, PlanLevelIDTech..
LET vFields_PlanLevelName   = peek ('Fields_PlanLevelName', 0, 'FieldExpressions');      // PlanLevelName1, PlanLevelName2, PlanLevelName..
Drop Table FieldExpressions;

// exit script;
// Finale Tabelle
Rename Table KontoplanORHierarchy To KontoplanORHierarchyTmp;
KontoplanORHierarchy:
NoConcatenate Load
    *
Where (IstKontoLevel = 1);
Load
    *
    // , if (Len(PlanLevelID) >= 5, 1, 0) AS IstKontoLevel
    , 1 AS IstKontoLevel // ist nicht ermittelbar
    ;
Load
    Depth
    // , IstKontoLevel
    , [PlanLevelIDName]
    , $(vFields_PlanLevelIDName)
    , PlanLevelID
    , $(vFields_PlanLevelID)
    , PlanLevelIDTech
    // , $(vFields_PlanLevelIDTech)
    , PlanLevelName
    , $(vFields_PlanLevelName)
    , $(vIstKontoLevelExpression) AS Kontolevel
//    , ParentNodeID
    , Sort
    , PlanLevelID as %KontoOR
Resident KontoplanORHierarchyTmp;
Call QvdStore ('KontoplanORHierarchy', '$(vStorePath)', 'RF_TR', 'KontoplanORHierarchy', '*', 1);
Drop Table KontoplanORHierarchyTmp;

/*

Kontostruktur_OR_temp2:
LOAD Distinct
    KontoTyp,
    KontonameDe,
    "KontonameDe-D",
    KontonameEN,
    ORKtoNum as KontoNum,
    ORKtoNum as %ReferenzNrKonto,
    ParentKontoNum_new as ParentKontoNum,
    KontonameFR,
    "KontonameFR-F",
    KontoGruppe,
    KontonameIT,
    Konto as KontoTechName,
    Kontolevel,
	KontoParent as ParentKontoTechName,
    KontonameZH,
	SubField(_KEY_content, '|', -1)*100 as Sort,
    _KEY_content,
    _KEY_root,
    ApplyMap('Map_KeyFiguresAccounts', ORtoCustomAccount, null()) as KeyFiguresKontoName,
;
// Preceding load
LOAD
	*,
      KontoParent as ParentKontoNum_new,
      Konto as ORKtoNum,
      ApplyMap('Map_ORtoCustom', Konto, Null()) as ORtoCustomAccount
         
FROM [$(vSourcePath)DS_api_Kontobaum.qvd]
(qvd)
WHERE Match(KontoTyp, 'OR')>0;

Kontostruktur_OR_temp:
Hierarchy (KontoNum, ParentKontoNum, KontonameDe, Account, Name, PortfolioPath, '/', Depth)
LOAD Distinct
	KontoNum,
    %ReferenzNrKonto,
    ParentKontoNum,
    KontoGruppe,
    KontonameDe as Kontoname,
    KontonameDe,
    "KontonameDe-D" as KontonameDe_D,
    KontonameEN,
    KontonameFR,
    "KontonameFR-F" as KontonameFR_F,
    KontonameIT,
    KontonameZH,
    KontoTechName,
    KontoTyp,
    Kontolevel,
    Sort,
    KeyFiguresKontoName
Resident Kontostruktur_OR_temp2;
DROP TABLE Kontostruktur_OR_temp2;

Ancestry_Kto_OR_temp:
HierarchyBelongsTo(NodeID, AncestorID, NodeName, AncestorID, AncestorName, DepthDiff)
Load Distinct KontoNum as NodeID, ParentKontoNum as AncestorID, Kontoname as NodeName Resident Kontostruktur_OR_temp;

LEFT JOIN (Kontostruktur_OR_temp)
LOAD Distinct
	NodeID as KontoNum,
    NodeName as KontoNameAnc,
    AncestorID as KtoAncestorID,
    AncestorName as KontoRollup,
    DepthDiff as KtoDepth
Resident Ancestry_Kto_OR_temp;
DROP TABLE Ancestry_Kto_OR_temp;

// Store QVD
Call QvdStore ('Kontostruktur_OR_temp', '$(vStorePath)', 'temp', 'KontostrukturOR', '*', 1);

*/

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_KtoOR = (now() - vStartTime_KtoOR)*86400;
Trace ---------------------------------- Ktostruktur OR geladen ----------------------------------;
Trace $(vElapsed_KtoOR);
//********************************************************************************************


///$tab 1.6 Consolidated Konto Hierarchy (neu)
//********************************* Zeitmessung Mapping *********************************
// SET vStartTime_KtoCONS = 0;
// Set vElapsed_KtoCONS = 0;
Let vStartTime_KtoCONS  = now();

//*************************************************************************************

// Erstellen der konsolidierten Konto-Hierarchietabelle

// Starte mit Kundenkonten
KontoplanConsHierarchy:
NoConcatenate
LOAD
	*,
    'Custom' as KontoplanTyp, 
    PlanLevelID & ' ' &'$(vKeySep)' & ' ' & PlanLevelName as AnzeigeName,
    ApplyMap('Map_AccountFactor_Custom', PlanLevelID2, Null()) as Kontogruppe,
    (replace(Sort,'-','')&repeat('0', (10 - len(replace(Sort,'-','')))))*1 as KontoSort,
    %KontoCustom as %GlobalKontoKey
FROM [$(vStorePath)RF_TR-KontoplanCustomHierarchy.qvd] (qvd); 

// Füge Dimensions-Konten hinzu
Concatenate (KontoplanConsHierarchy)
LOAD
	*,
    'Valuation' as KontoplanTyp, 
    PlanLevelID & ' ' &'$(vKeySep)' & ' ' & PlanLevelName as AnzeigeName,
    ApplyMap('Map_DimAccountGroup', PlanLevelID, Null()) as Kontogruppe,
    ApplyMap('Map_DimAccountSort', PlanLevelID, Null()) as KontoSort,
    %KontoDim as %GlobalKontoKey
FROM [$(vStorePath)RF_TR-KontoplanDimHierarchy.qvd] (qvd);

// Füge SIA-Konten hinzu
Concatenate (KontoplanConsHierarchy)
LOAD
	*,
    'SIA' as KontoplanTyp, 
     PlanLevelID & ' ' &'$(vKeySep)' & ' ' & PlanLevelName as AnzeigeName,
     ApplyMap('Map_AccountFaktorStandard', PlanLevelIDTech, Null()) as Kontogruppe,
     Num(PlanLevelID*Num(If(Kontolevel=1, 10000, If(Kontolevel=2, 100, 1)))) as KontoSort,
     %KontoSIA as %GlobalKontoKey
//     If(Num(PlanLevelID)/100<1, Num(PlanLevelID), If(Num(Kontolevel)<2, Num(PlanLevelID), Num(Num(ApplyMap('Map_Kontobaum', ParentNodeID, Null())) &'.'& Right(PlanLevelID,2))))  as KontoSort
FROM [$(vStorePath)RF_TR-KontoplanSIAHierarchy.qvd] (qvd);

// Füge KKV-Konten hinzu
Concatenate (KontoplanConsHierarchy)
LOAD
	*,
    'KKV' as KontoplanTyp, 
     PlanLevelID & ' ' &'$(vKeySep)' & ' ' & PlanLevelName as AnzeigeName,
     ApplyMap('Map_AccountFaktorStandard', PlanLevelIDTech, Null()) as Kontogruppe,
	 Sort as KontoSort,
     %KontoKKV as %GlobalKontoKey
FROM [$(vStorePath)RF_TR-KontoplanKKVHierarchy.qvd] (qvd);

// Füge OR-Konten hinzu (Asset Statement Law Of Bonds)
Concatenate (KontoplanConsHierarchy)
LOAD
	*,
    'OR' as KontoplanTyp, 
     PlanLevelID & ' ' &'$(vKeySep)' & ' ' & PlanLevelName as AnzeigeName,
     ApplyMap('Map_AccountFaktorStandard', PlanLevelIDTech, Null()) as Kontogruppe,
	 Sort as KontoSort,
     %KontoOR as %GlobalKontoKey
FROM [$(vStorePath)RF_TR-KontoplanORHierarchy.qvd] (qvd);


DROP FIELDS Sort, IstKontoLevel, %KontoCustom, %KontoDim, %KontoSIA, %KontoKKV, %KontoOR FROM KontoplanConsHierarchy;



// Store QVD
Call QvdStore ('KontoplanConsHierarchy', '$(vStorePath)', 'temp', 'KontoplanConsHierarchy', '*', 1);

/*

// Custom Accounts
Konto_Hierarchy_Cons:
NoConcatenate
LOAD Distinct
    %ReferenzNrKonto,
//     Kontoname1,
//     Kontoname2,
//     Kontoname3,
//     Kontoname4,
//     Account,
//     PortfolioPath,
//     CombParentKonto,
    %ReferenzNrKonto as KontoNum,
    Kontoname,
//    %KontoKeyFull,
//    Kontoname_zh,
//    UeberKontoKey,
    UeberKonto,
    UeberKontoName,
//    ParentKontoKey,
    ParentKonto as ElternKonto,
    ParentKontoName as ElternKontoName,
//    ParentOfParentKontoKey,
    ParentOfParentKonto as ElternVonElternKonto,
    ParentofParentName as ElternVonElternName,
    CombKontoKey as NextLevelUpKonto,
    CombParentKontoName as NextLevelUpKontoName,
    'CustomAccounts' as KontoTyp,
    Typ as KontoSubTyp,
    Kontolevel,
//    Aktiv,
    KeyFiguresKontoName as %KeyFigKontoname,
//     KeyFiguresFaktor,
//     GruppenKontoL0,
//     GruppenKontoL1,
//     GruppenKontoL2,
//     GruppenKontoL3,
//     GruppenKontoL4,
//     GruppenKontoL5,
//     KeyFiguresSort,
//     GruppenSortL0,
//     GruppenSortL1,
//     GruppenSortL2,
//     GruppenSortL3,
//     GruppenSortL4,
//     GruppenSortL5,
    Faktor,
//     Konto_SIA,
//     Konto_VermgsRechn,
//     Depth,
//     KontoNameAnc,
    KtoAncestorID,
    KontoRollup,
//     KtoDepth,
	If(Kontolevel=3 OR Kontolevel=4, %KontoKeyFull, ParentKontoKey) as Sort
FROM [$(vStorePath)temp-KontostrukturCustom.QVD](qvd);

// Dimensions Accounts
Concatenate (Konto_Hierarchy_Cons)
LOAD Distinct
    %ReferenzNrKonto,
    KontoName as KontoNum,
    Bezeichnung as Kontoname,
    '' as UeberKonto,
    '' as UeberKontoName,  
    ElternKonto,
    ParentName as ElternKontoName,
    ElternVonElternKonto,
    '' as ElternVonElternName,
    '' as NextLevelUpKonto,
    '' as NextLevelUpKontoName,
    'DimensionsAccounts' as KontoTyp,
    '' as KontoSubTyp,
//     Bezeichnung1,
//     Bezeichnung2,
//     Bezeichnung3,
//     Bezeichnung4,
//     PathName,
//     KontoRGB,
    Kontolevel,
    KeyFiguresKontoName as %KeyFigKontoname,
//    KontoFaktor, 
//     KeyFiguresFaktor,
//     KeyFiguresSort,
//     GruppenKontoL0_CF,
//     GruppenKontoL1_CF,
//     GruppenKontoL2_CF,
//     GruppenKontoL3_CF,
//     GruppenKontoL4_CF,
//     GruppenKontoL5_CF,
//     GruppenSortL0_CF,
//     GruppenSortL1_CF,
//     GruppenSortL2_CF,
//     GruppenSortL3_CF,
//     GruppenSortL4_CF,
//     GruppenSortL5_CF,
    Faktor,
//  Depth,
//  BezeichnungAnc,
    KtoAncestorID,
    KontoRollup,
//  KtoDepth,
	KontoSortierung as Sort
FROM [$(vStorePath)temp-KontostrukturDimensions.QVD](qvd);

// SIA-Accounts
Concatenate (Konto_Hierarchy_Cons)
LOAD Distinct
    %ReferenzNrKonto,
    KontoNum,
    Kontoname,
//     KontonameDe2,
//     Account,
//     PortfolioPath,
    '' as UeberKonto,
    '' as UeberKontoName,  
    ParentKontoNum as ElternKonto,
//    KontonameDe1 as ElternKontoName,
    KontonameDe as ElternKontoName,
    '' as ElternVonElternKonto,
    '' as ElternVonElternName,
    '' as NextLevelUpKonto,
    '' as NextLevelUpKontoName,
    'SIACombAccounts' as KontoTyp,
    KontoTyp as KontoSubTyp,
//     KontonameDe,    
//     KontoGruppe,    
//     KontonameDe_D,
//     KontonameEN,
//     KontonameFR,
//     KontonameFR_F,
//     KontonameIT,
//     KontonameZH,
//     KontoTechName,
    Kontolevel,
    KeyFiguresKontoName as %KeyFigKontoname,
    '' as Faktor,
//    Depth,
//    KontoNameAnc,
    KtoAncestorID,
    KontoRollup,
//    KtoDepth,
    Sort
FROM [$(vStorePath)temp-KontostrukturSIA.QVD](qvd);

// KKV-Accounts
Concatenate (Konto_Hierarchy_Cons)
LOAD Distinct
    %ReferenzNrKonto,
    KontoNum,
    Kontoname,
    '' as UeberKonto,
    '' as UeberKontoName,  
    ParentKontoNum as ElternKonto,
//    KontonameDe1 as ElternKontoName,
    KontonameDe as ElternKontoName,
    '' as ElternVonElternKonto,
    '' as ElternVonElternName,
    '' as NextLevelUpKonto,
    '' as NextLevelUpKontoName,
    'SIACombAccounts' as KontoTyp,
    KontoTyp as KontoSubTyp,
    Kontolevel,
    KeyFiguresKontoName as %KeyFigKontoname,
    '' as Faktor,
    KtoAncestorID,
    KontoRollup,
    Sort
FROM [$(vStorePath)temp-KontostrukturKKV.QVD](qvd);

// OR-Accounts
Concatenate (Konto_Hierarchy_Cons)
LOAD Distinct
    %ReferenzNrKonto,
    KontoNum,
    Kontoname,
    '' as UeberKonto,
    '' as UeberKontoName,  
    ParentKontoNum as ElternKonto,
    KontonameDe2 as ElternKontoName,
    '' as ElternVonElternKonto,
    '' as ElternVonElternName,
    '' as NextLevelUpKonto,
    '' as NextLevelUpKontoName,
    'SIACombAccounts' as KontoTyp,
    KontoTyp as KontoSubTyp,
    Kontolevel,
    KeyFiguresKontoName as %KeyFigKontoname,
    '' as Faktor,
    KtoAncestorID,
    KontoRollup,
    Sort
FROM [$(vStorePath)temp-KontostrukturOR.QVD](qvd);

*/



//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_KtoCONS = (now() - vStartTime_KtoCONS)*86400;
Trace ---------------------------------- Ktostruktur Konsolidiert geladen ----------------------------------;
Trace $(vElapsed_KtoCONS);
//********************************************************************************************

///$tab Ende Kontohierarchien 1. <<
//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_KTO = (now() - vStartTime_KTO)*86400;
Trace ---------------------------------- Kontohierarchien Total geladen ----------------------------------;
Trace $(vElapsed_KTO);
//********************************************************************************************
///$tab >> 2. Dimensionen
//********************************* Start Zeitmessung *********************************
// SET vStartTime_DIM = 0;
// Set vElapsed_DIM = 0;
Let vStartTime_DIM  = now();

//*************************************************************************************
///$tab 2.1  Portfolios
//********************************* Start Zeitmessung *********************************
// SET vStartTime_PF = 0;
// Set vElapsed_PF = 0;
Let vStartTime_PF  = now();

//*************************************************************************************

// Load Portfolios
Portfolios_temp:
NoConcatenate
LOAD Distinct
	BasisURL,
    PortfolioURL,
    PortfolioId as %PortfolioID,
    PortfolioId as PortfolioID,  	//Dieses Feld wird für die BI-Konfiguration (Filterübergabe bei Absprungslink WD-> Insights) benötigt
//    ProjektID,
	ParentPortfolio,
    ParentOfParent,
	ExterneID,
    ReferenzNrPortfolio,
    Name as PFName,
    Beschrieb,
    Status,
    PortfolioTyp,
    Boersensymbol,
    ISIN,
    Stueckelung,
    Eigentuemer as PFEigentuemer,
    Valorennummer,
    Kurs,
    Aktienkapital,
    Gruendungsdatum,
    Abschlussperiodizitaet,
//    Abschlussdatum,
    AbschlussMonatName,
    AbschlussMonatNum,
    BHMandant,
    BHGeschaeftsbereich,
    Waehrung,
    AdditionalFee,
//    Adresse1,
//    Adresse2,    
//    Land,
//    Ort,    
//    Kanton, 
//    PLZ,
    FlatFee,    
    Verwaltungshonorar,
    BasisVerwaltungshonorar,
    maxGesHyposchuld,
    maxStratFremdFinQuote,    
    Kaufdatum,
    ReglVerguetung,    
    SteuerBeschrieb,
    SteuerRegisterNr,
    MWSt_Nr,
    PMPortfolio
;
// Preceding load
LOAD
	*,
//    ApplyMap('Map_Project_to_PF', PortfolioId, null()) as ProjektID,
    ApplyMap('Map_Parent_Portfolio', ParentPortfolio, null()) as ParentOfParent,
    ApplyMap('MappingPortfolioTyp', PortfolioTyp, null()) as PortfolioTyp,
	Date(Gruendungsdatum) as Gruendungsdatum,
	Num(Month(Date(Date#(ApplyMap('Map_Months_EnDe', capitalize(lower(Abschlussdatum))), 'MMMM'), '$(DateFormat)'))) as AbschlussMonatNum,
    Date(Date#(ApplyMap('Map_Months_EnDe', capitalize(lower(Abschlussdatum))), 'MMMM'), 'MMMM') as AbschlussMonatName,
    Left( BasisURL, Len( Trim( BasisURL) ) -3) & '/#/'& subfield(PortfolioId,'-',1) &'/val/portfolios/'& subfield(PortfolioId,'-',2) &'/basic-data' as PortfolioURL,
    ApplyMap('Map_Users', PMPortfolioId, Null()) as PMPortfolio
FROM [$(vSourcePath)DS_api_Portfolios.qvd]
(qvd);


// Load Portfolio Hierarchies
Hierarchy_Portfolio:
Hierarchy (%PortfolioID, ParentPortfolio, PFName, Gesellschaft, Name, PortfolioPath, '/', Depth)
LOAD Distinct
	%PortfolioID, 
    ParentPortfolio,
    PFName
Resident Portfolios_temp;

//Damit PFName 1-3 in jedem Fall existieren
Outer Join(Hierarchy_Portfolio)
Load * Inline [
	PFName1, PFName2, PFName3 
];

Ancestry_PF_temp:
HierarchyBelongsTo(NodeID, AncestorID, NodeName, AncestorID, AncestorName, DepthDiff)
Load %PortfolioID as NodeID, ParentPortfolio as AncestorID, PFName as NodeName Resident [Portfolios_temp];

Ancestry_Portfolio_temp:
LOAD Distinct
	NodeID as [%PortfolioID],
    NodeName as PF_Name,
    AncestorID as PFAncestorID,
    AncestorName as PortfolioRollup,
    DepthDiff as PFDepth
Resident Ancestry_PF_temp;
DROP TABLE Ancestry_PF_temp;


// Join Back the Portfolio Hierarchy to Portfolio-Table
LEFT JOIN (Portfolios_temp)
LOAD Distinct
	%PortfolioID,
    PFName3 as SubGesellschaft, //Portfolio_IG,
    PFName2 as Gesellschaft, //Portfolio_Portfolio,
    PFName1 as Portfolio //Portfolio_Fond
Resident Hierarchy_Portfolio;
DROP TABLE Hierarchy_Portfolio;

LEFT JOIN (Portfolios_temp)
LOAD Distinct
	[%PortfolioID],
    PFAncestorID,
    PortfolioRollup,
    PFDepth
    
Resident Ancestry_Portfolio_temp;
DROP TABLE Ancestry_Portfolio_temp;

// Store QVD
Call QvdStore ('Portfolios_temp', '$(vStorePath)', 'RF_MD', 'Portfolios', '*', 1);


//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_PF = (now() - vStartTime_PF)*86400;
Trace ---------------------------------- Portfolio Dim geladen ----------------------------------;
Trace $(vElapsed_PF);
//********************************************************************************************

///$tab 2.2 Wirtschaftseinheiten (WE)

///$tab 2.2.1  WE_Versioniert
//********************************* Start Zeitmessung *********************************
// SET vStartTime_WETotal = 0;
// SET vStartTime_WEVer = 0;
// Set vElapsed_WEVer = 0;
// Set vElapsed_WETotal = 0;
Let vStartTime_WETotal  = now();
Let vStartTime_WEVer  = now();

//*************************************************************************************

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Wirtschaftseinheit_Versionen.qvd')) Then

// Load PU Versions
WE_Versionen:
NoConcatenate
LOAD Distinct
    WirtschaftseinheitsID as %WirtschaftseinheitNr,
    Name as WEName,
    WirtschaftseinheitsVersionID,
    WirtschaftseinheitsID & '$(vKeySep)' & WirtschaftseinheitsVersionID as %WirtschaftseinheitSCDID,
    PortfolioId, //as %PortfolioID,	// Alias has to be removed for the live model
//    ApplyMap('Map_Portfolio_to_Portfolio', PortfolioId) as ParentPortfolio,
    Eigentumsanteil,
    KommentarWirtschaftseinheit,
    Eigentuemer as WEEigentuemer,
    Eigentum as WEEigentum,
    Liegenschaftstyp,
   	LiegenschaftRGB,
    Spezialitaet,
//    STWEWertquoteEigentum,
//    STWEWertquoteTotal,
//    RelLinkName,
    %WERN,
    Liegenschaft,
    ReferenzNrWirtschaftseinheit2,
    _KEY_root,
    BasisURL,
    WEURL,
    Bearbeitungsdatum,
    VersionDate,
    ValidFromDate,
    ValidToDate,
    '0' as CurrentFlag,
    Adresse1,
    Adresse2,
    Land,
    Land as %CountryCode2,
    '$(vOGStand)' as vOGStand,
    Ort,
    Kanton,
    PLZ,
//    VersionErstellungsDatum,
//    WE_isDeleted,
    Breitengrad,
    Laengengrad,
    Geokey,
    'WGS84' as KoordinatenTyp,
    WirtschaftseinheitsID & '$(vKeySep)' & VersionKey as %WEVersion,
    VersionKey as WE_Version
//    WirtschaftseinheitsID & '$(vKeySep)' & Version as %WE_Version
;
// Preceding load
LOAD Distinct
	*,
//    Dual('Ver' & '-' & Num(Month(VersionDate), '00') & '-' & Year(VersionDate), Year(VersionDate) & Num(Month(VersionDate), '00'))  as Version,
    Date(ValidFromDate, 'MMM-YY') as VersionKey,
    GeoMakePoint(Breitengrad, Laengengrad) as Geokey,
    Adresse1 & ' $(vKeySep) ' &  PLZ &' '& Ort & ' $(vKeySep) LG-Nr. ' & if('$(vModuleCloud)'= '0220_Baloise' or '$(vModuleCloud)'= '0237_PK_BS', num(Num#(%WERN),'0000'), %WERN) as Liegenschaft
;
// Preceding Load
LOAD Distinct
	*,
	Date(Floor(MonthStart(Date(WE_versionStart)))) as ValidFromDate,
    Date(Floor(MonthEnd(Date(WE_versionDate)))) as ValidToDate,
    Date(Floor(MonthEnd(WE_versionDate))) as VersionDate,
    Applymap('MappingEigentum',Eigentum, null())as Eigentum,
    Applymap('MappingLiegenschaft',Liegenschaftstyp, null()) as Liegenschaftstyp,
   	Applymap('MappingLiegenschaftRGB',Liegenschaftstyp, null()) as LiegenschaftRGB,
    ApplyMap('Map_WE_to_Portfolio', WirtschaftseinheitsID, null()) as PortfolioId,
    Left( BasisURL, Len( Trim( BasisURL) ) -3)&'/#/'&subfield(WirtschaftseinheitsID,'-',1)&'/val/property-units/'&subfield(WirtschaftseinheitsID,'-',2)&'/property-data/basic-data' as WEURL,
    ReferenzNrWirtschaftseinheit as %WERN
FROM [$(vSourcePath)DS_api_Wirtschaftseinheit_Versionen.qvd]
(qvd);

LEFT JOIN (WE_Versionen)
LOAD Distinct
    _KEY_root,
    InvestmentDataID,
    Währung as Waehrung,
    Optierungsgrad,
    if(Optierungsgrad = 1, 'optiert', if ( Optierungsgrad > 0, 'teiloptiert', if ( Optierungsgrad <= 0, 'nicht optiert', null() ))) as Optierungstyp,
    KAGKategorie,
    KommentarKAGKategorie,
    FiskalischeKategorie_tmp as FiskalischeKategorie,
    KommentarFiskalischeKategorie,
    FiskalischeKategorieRGB,
    FINMAKategorie,
//    KAGNebenkategorie,
//    FINMANebenkategorie,
    MSCILiegenschaftsTyp,
    MSCIsekundaererLiegenschaftsTyp,
    KontenplanAnzeigeModus,
    VomPortfolioVererben,
    Abschlussdatum,
    Abschlussperiodizitaet,    
    AbschlussMonatNum,
    AbschlussMonatName,
    WirtschaftseinheitGueltigAb,
    WirtschaftseinheitGueltigBis,
    NKAuslagerungGueltigAb,    
    LiegenschaftsverwaltungsId,
    Liegenschaftsverwaltung,
    LiegenschaftsverwaltungManager,
    LIVE_HauptsitzId,
    LIVE_HauptsitzName,
    KontaktName,
	Telefon,
	BueroTelefon,
	Mobile,		
	Email,	
    Assetmanager,
    AssetManagerName,
    AssetmanagerStv,
    AssetManagerStvName,
	Bauleiter,
    BauleiterName,
    BauleiterStv,
    BauleiterStvName,
    CapexBuildingToken,
    LebenszyklusFokus,
    RisikoAkzeptanz,
    CapExModelVerwenden,
    DatumLetzteUeberpruefung_temp as DatumLetzteUeberpruefung
//    Konto_NebenkostenLIVE
//    RelLinkName,
//    WirtschaftseinheitsID,
//    WirtschaftseinheitsVersionID
;
// Preceding load
LOAD Distinct
	*,
    ApplyMap('MappingKAG',KAGKategorie, null()) as KAGKategorie,
    ApplyMap('MappingKAGRGB',KAGKategorie, null()) as KAGKategorieRGB,
    ApplyMap('MappingFiskalischeKategorie', FiskalischeKategorie, null()) as FiskalischeKategorie_tmp,
    ApplyMap('MappingFiskalischeKategorieRGB', FiskalischeKategorie, null()) as FiskalischeKategorieRGB,
    ApplyMap('MappingFINMAHauptKategorie', FINMAKategorie, null()) as FINMAKategorie,
//    ApplyMap('MappingFINMANebenKategorie', FINMANebenkategorie, null()) as FINMANebenkategorie,
    ApplyMap('MappingMSCIKategorie', MSCILiegenschaftsTyp, null()) as MSCILiegenschaftsTyp,
    ApplyMap('MappingMSCIKategorie', MSCIsekundaererLiegenschaftsTyp, null()) as MSCIsekundaererLiegenschaftsTyp,
    ApplyMap('MappingLebenszyklusFokus', LebenszyklusFokus, null()) as LebenszyklusFokus,
    ApplyMap('MappingRisikoAkzeptanz', RisikoAkzeptanz, null()) as RisikoAkzeptanz,
//    ApplyMap('MappingNebenkostenKonto', Konto_NebenkostenLIVE, null()) as Konto_NebenkostenLIVE,
//    ApplyMap('MappingKAGNebenkategorie', KAGNebenkategorie, 'nicht verfügbar') as KAGNebenkategorie,
    ApplyMap('Map_Users', Assetmanager, null()) as AssetManagerName,
    ApplyMap('Map_Users', AssetmanagerStv, null()) as AssetManagerStvName,
    ApplyMap('Map_Users', Bauleiter, null()) as BauleiterName,
    ApplyMap('Map_Users', BauleiterStv, null()) as BauleiterStvName,
    ApplyMap('Map_Stakeholders_Parent', LiegenschaftsverwaltungsId, null()) as LIVE_HauptsitzId,
    ApplyMap('Map_Stakeholders_Name', ApplyMap('Map_Stakeholders_Parent', LiegenschaftsverwaltungsId, null()), null()) as LIVE_HauptsitzName,
    ApplyMap('Map_LIVE_Name', LiegenschaftsverwaltungsId, null()) as KontaktName,
    ApplyMap('Map_LIVE_Tel', LiegenschaftsverwaltungsId, null()) as Telefon,
    ApplyMap('Map_LIVE_OfficeTel', LiegenschaftsverwaltungsId, null()) as BueroTelefon,
    ApplyMap('Map_LIVE_Mobile', LiegenschaftsverwaltungsId, null()) as Mobile,
    ApplyMap('Map_LIVE_Email', LiegenschaftsverwaltungsId, null()) as Email,
	Num(Month(Date(Date#(ApplyMap('Map_Months_EnDe', capitalize(lower(Abschlussdatum))), 'MMMM'), '$(DateFormat)'))) as AbschlussMonatNum,
    Date(Date#(ApplyMap('Map_Months_EnDe', capitalize(lower(Abschlussdatum))), 'MMMM'), 'MMMM') as AbschlussMonatName,
    Date(WirtschaftseinheitGueltigAb) as WirtschaftseinheitGueltigAb,
    Date(WirtschaftseinheitGueltigBis) as WirtschaftseinheitGueltigBis,
    Date(NKAuslagerungGueltigAb) as NKAuslagerungGueltigAb,
    Date(DatumLetzteUeberpruefung) as DatumLetzteUeberpruefung_temp
FROM [$(vSourcePath)DS_api_InvestmentData_WE_Versionen.qvd]
(qvd);


IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_InvestmentData_WE_Versionen.qvd')) Then

// KAG Nebenkategorie Wide-Table
KAG_NK_Generic_Ver:
Generic
LOAD Distinct
	_KEY_root,
 	KAGNebenkategorie,
	'1' as Value
;
//Preceding load
LOAD Distinct
	*,
    ApplyMap('MappingKAGNebenkategorie', KAGNebenkategorie) as KAGNebenkategorie
FROM [$(vSourcePath)DS_api_InvestmentData_WE_Versionen.qvd]
(qvd)
WHERE not(isnull(KAGNebenkategorie));

KAG_NK_Cross_Ver:
LOAD Distinct
	_KEY_root
Resident WE_Versionen;

FOR i = NoOfTables()-1 to 0 STEP -1;
	LET vTable=TableName($(i));
    IF WildMatch('$(vTable)','KAG_NK_Generic_Ver.*') THEN
    LEFT JOIN ([KAG_NK_Cross_Ver]) LOAD * RESIDENT [$(vTable)];
	DROP TABLE [$(vTable)];
    ENDIF
NEXT i

LEFT JOIN (WE_Versionen)
LOAD Distinct
	*
Resident KAG_NK_Cross_Ver;
DROP TABLE KAG_NK_Cross_Ver;


// FINMA Nebenkategorie Wide-Table
FINMA_NK_Generic_Ver:
Generic
LOAD Distinct
	_KEY_root,
    FINMANebenkategorie,
    '1' as Value
;
// Preceding load
LOAD
	*,
    'FINMA_NK'&'$(vKeySep)'&ApplyMap('MappingFINMANebenKategorie', FINMANebenkategorie) as FINMANebenkategorie
FROM [$(vSourcePath)DS_api_InvestmentData_WE_Versionen.qvd]
(qvd)
WHERE not(isnull(FINMANebenkategorie));

FINMA_NK_Cross_Ver:
LOAD Distinct
	_KEY_root
Resident WE_Versionen;

FOR i = NoOfTables()-1 to 0 STEP -1;
	LET vTable=TableName($(i));
    IF WildMatch('$(vTable)','FINMA_NK_Generic_Ver.*') THEN
    LEFT JOIN ([FINMA_NK_Cross_Ver]) LOAD * RESIDENT [$(vTable)];
	DROP TABLE [$(vTable)];
    ENDIF
NEXT i

LEFT JOIN (WE_Versionen)
LOAD
	*
Resident FINMA_NK_Cross_Ver;
DROP TABLE FINMA_NK_Cross_Ver;


// NK-Konten LIVE Wide-Table
NK_LIVE_Generic_Ver:
Generic
LOAD Distinct
	_KEY_root,
    Konto_NebenkostenLIVE,
    '1' as Value
;
// Preceding load
LOAD Distinct
	*,
    'NK_LIVE'&'$(vKeySep)'&ApplyMap('MappingNebenkostenKonto', Konto_NebenkostenLIVE) as Konto_NebenkostenLIVE
FROM [$(vSourcePath)DS_api_InvestmentData_WE_Versionen.qvd]
(qvd)
WHERE not(isnull(Konto_NebenkostenLIVE));

NK_LIVE_Cross_Ver:
LOAD Distinct
	_KEY_root
Resident WE_Versionen;

FOR i = NoOfTables()-1 to 0 STEP -1;
	LET vTable=TableName($(i));
    IF WildMatch('$(vTable)','NK_LIVE_Generic_Ver.*') THEN
    LEFT JOIN ([NK_LIVE_Cross_Ver]) LOAD * RESIDENT [$(vTable)];
	DROP TABLE [$(vTable)];
    ENDIF
NEXT i

LEFT JOIN (WE_Versionen)
LOAD Distinct
	*
Resident NK_LIVE_Cross_Ver;
DROP TABLE NK_LIVE_Cross_Ver;

END IF

// tbd (are): Rent-Regulations

// Store QVD
Call QvdStore ('WE_Versionen', '$(vStorePath)', 'temp', 'WEVersionen', '*', 1);

END IF

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_WEVer = (now() - vStartTime_WEVer)*86400;
Trace ---------------------------------- WE SCD Dim geladen ----------------------------------;
Trace $(vElapsed_WEVer);
//********************************************************************************************

///$tab 2.2.2  WE_Aktuell
//********************************* Start Zeitmessung *********************************
// SET vStartTime_WEAct = 0;
// Set vElapsed_WEAct = 0;
Let vStartTime_WEAct  = now();

//*************************************************************************************

// WE Actual - Creating the denormalized Table

WE_Aktuell_temp:
NoConcatenate
LOAD Distinct
	*
FROM [$(vSourcePath)DS_api_Wirtschaftseinheit_WE.qvd]
(qvd);

IF Not Isnull(QvdCreateTime('$(vStorePath)temp-WEVersionen.qvd')) Then

LEFT JOIN (WE_Aktuell_temp)
LOAD Distinct
	%WirtschaftseinheitNr as WirtschaftseinheitsID,
    Date(Max(VersionDate)) as MaxVersionDate
    
//Resident WE_Versionen
FROM [$(vStorePath)temp-WEVersionen.qvd] (qvd)
GROUP BY %WirtschaftseinheitNr;

ELSE

LEFT JOIN (WE_Aktuell_temp)
LOAD Distinct
	WirtschaftseinheitsID,
    Date(Floor(MonthEnd($(vCurrentDate)))) as MaxVersionDate
    
FROM [$(vSourcePath)DS_api_Wirtschaftseinheit_WE.qvd]
(qvd);

END IF


WE_Aktuell:
NoConcatenate
LOAD Distinct
    WirtschaftseinheitsID as %WirtschaftseinheitNr,
    Name as WEName,
    'Actual' as WirtschaftseinheitsVersionID,
    WirtschaftseinheitsID & '$(vKeySep)' & 'Actual' as %WirtschaftseinheitSCDID,
    PortfolioId, //as %PortfolioID,	// Alias has to be removed for the live model
//    ApplyMap('Map_Portfolio_to_Portfolio', PortfolioId) as ParentPortfolio,
    Eigentumsanteil,
    KommentarWirtschaftseinheit,
    Eigentuemer as WEEigentuemer, 
    Eigentum as WEEigentum,
    Liegenschaftstyp,
   	LiegenschaftRGB,
    Spezialitaet,
    %WERN,
    ReferenzNrWirtschaftseinheit2,
     BasisURL,
     WEURL,
    _KEY_content,
	TimeStamp(Bearbeitungsdatum) as Bearbeitungsdatum,
    VersionDate_temp as VersionDate,
    ValidFromDate_temp as ValidFromDate,
    ValidToDate_temp as ValidToDate,
   '1' as CurrentFlag,
   WirtschaftseinheitsID & '$(vKeySep)' & VersionKey as %WEVersion,
   VersionKey as WE_Version
//   WirtschaftseinheitsID & '$(vKeySep)' & Version as %WE_Version
;    
// Preceding load
LOAD Distinct
	*,
    Date(ValidFromDate_temp, 'MMM-YY') as VersionKey
//    Dual(Month(VersionDate_temp) & '-' & Year(VersionDate_temp), Year(VersionDate_temp) & Num(Month(VersionDate_temp), '00')) as VersionKey,
//    'Ver' & '-' & 'Actual' as Version
//    Dual('Ver' & '-' & Num(Month(VersionDate), '00') & '-' & Year(VersionDate), Year(VersionDate) & Num(Month(VersionDate), '00'))  as Version
;
// Preceding LOAD
LOAD Distinct
    *,
    Coalesce(Date(Floor(MonthStart(AddMonths(MaxVersionDate, 1)))), Date(Floor(MonthStart(Date(Bearbeitungsdatum))))) as ValidFromDate_temp,
    Coalesce(Date(Floor(MonthEnd(AddMOnths(MaxVersionDate, 1)))), Date(Floor(MonthEnd(Date(Bearbeitungsdatum))))) as VersionDate_temp,
	Date(Floor(MonthEnd($(vFormatDate('2099-12-31'))))) as ValidToDate_temp,
    Applymap('MappingEigentum',Eigentum, null())as Eigentum,
    Applymap('MappingLiegenschaft',Liegenschaftstyp, null()) as Liegenschaftstyp,
   	Applymap('MappingLiegenschaftRGB',Liegenschaftstyp, null()) as LiegenschaftRGB,
    Left( BasisURL, Len( Trim( BasisURL) ) -3)&'/#/'&subfield(WirtschaftseinheitsID,'-',1)&'/val/property-units/'&subfield(WirtschaftseinheitsID,'-',2)&'/property-data/basic-data' as WEURL,
    ReferenzNrWirtschaftseinheit as %WERN

Resident WE_Aktuell_temp;
DROP TABLE WE_Aktuell_temp;

//Store WE_Aktuell Into [lib://$(vStore)/03_Refinement/01_qvd/Ruby_new_DM\WE_Aktuell.qvd];

LEFT JOIN(WE_Aktuell)
LOAD Distinct
//    _KEY_content,
    Adresse1,
    Adresse2,
    Land,
    Land as %CountryCode2,
    '$(vOGStand)' as vOGStand,
    Ort,
    Kanton,
    PLZ,
	%WirtschaftseinheitNr
;
//Preceding load
LOAD Distinct
	*,
	WirtschaftseinheitsID as %WirtschaftseinheitNr
FROM [$(vSourcePath)DS_api_Adresse_WE.qvd]
(qvd);

LEFT JOIN(WE_Aktuell)
LOAD Distinct
//    _KEY_content,
    Breitengrad,
    Laengengrad,
    Geokey,
    'WGS84' as KoordinatenTyp,
	%WirtschaftseinheitNr
;
//Preceding load
LOAD Distinct
	*,
    GeoMakePoint(Breitengrad, Laengengrad) as Geokey,
	WirtschaftseinheitsID as %WirtschaftseinheitNr
FROM [$(vSourcePath)DS_api_Koordinaten_WE.qvd]
(qvd);


LEFT JOIN (WE_Aktuell)
LOAD Distinct
    %WirtschaftseinheitNr,
//    '' as InvestmentDataID,			// not available for non-versioned WE
    Währung as Waehrung,    
    Optierungsgrad,
    if(Optierungsgrad = 1, 'optiert', if ( Optierungsgrad > 0, 'teiloptiert', if ( Optierungsgrad <= 0, 'nicht optiert', null() ))) as Optierungstyp,
    KAGKategorie_temp as KAGKategorie,
    KommentarKAGKategorie,
    KAGKategorieRGB_temp as KAGKategorieRGB,
    FiskalischeKategorie_temp as FiskalischeKategorie,
    FiskalischeKategorieRGB_temp as FiskalischeKategorieRGB,
    KommentarFiskalischeKategorie,
    NKAuslagerungGueltigAb_temp as NKAuslagerungGueltigAb,
	FINMAKategorie_temp as FINMAKategorie,
    MSCILiegenschaftsTyp_temp as MSCILiegenschaftsTyp,
    MSCIsekundaererLiegenschaftsTyp_temp as MSCIsekundaererLiegenschaftsTyp,
	LiegenschaftsverwaltungsId,
	Liegenschaftsverwaltung,
    LiegenschaftsverwaltungManager,
    LIVE_HauptsitzId,
    LIVE_HauptsitzName,
	KontaktName,
	Telefon,
	BueroTelefon,
	Mobile,		
	Email,
    Assetmanager,
    AssetManagerName,
    AssetmanagerStv,
    AssetManagerStvName,
	Bauleiter,
    BauleiterName,
    BauleiterStv,
    BauleiterStvName,
    DatumLetzteUeberpruefung_temp as DatumLetzteUeberpruefung
;
// Preceding load
LOAD Distinct
	*,
    WirtschaftseinheitsID as %WirtschaftseinheitNr,
    ApplyMap('MappingKAG',KAGKategorie, null()) as KAGKategorie_temp,
    ApplyMap('MappingKAGRGB',KAGKategorie, null()) as KAGKategorieRGB_temp,
    ApplyMap('MappingFiskalischeKategorie', FiskalischeKategorie, null()) as FiskalischeKategorie_temp,
    ApplyMap('MappingFiskalischeKategorieRGB', FiskalischeKategorie, null()) as FiskalischeKategorieRGB_temp,
    ApplyMap('MappingFINMAHauptKategorie', FINMAKategorie, null()) as FINMAKategorie_temp,
    ApplyMap('MappingMSCIKategorie', MSCILiegenschaftsTyp, null()) as MSCILiegenschaftsTyp_temp,
    ApplyMap('MappingMSCIKategorie', MSCIsekundaererLiegenschaftsTyp, null()) as MSCIsekundaererLiegenschaftsTyp_temp,
    ApplyMap('Map_Users', Assetmanager, null()) as AssetManagerName,
    ApplyMap('Map_Users', AssetmanagerStv, null()) as AssetManagerStvName,
    ApplyMap('Map_Users', Bauleiter, null()) as BauleiterName,
    ApplyMap('Map_Users', BauleiterStv, null()) as BauleiterStvName,
    ApplyMap('Map_Stakeholders_Parent', LiegenschaftsverwaltungsId, null()) as LIVE_HauptsitzId,
    ApplyMap('Map_Stakeholders_Name', ApplyMap('Map_Stakeholders_Parent', LiegenschaftsverwaltungsId, null()), null()) as LIVE_HauptsitzName,
    ApplyMap('Map_LIVE_Name', LiegenschaftsverwaltungsId, null()) as KontaktName,
    ApplyMap('Map_LIVE_Tel', LiegenschaftsverwaltungsId, null()) as Telefon,
    ApplyMap('Map_LIVE_OfficeTel', LiegenschaftsverwaltungsId, null()) as BueroTelefon,
    ApplyMap('Map_LIVE_Mobile', LiegenschaftsverwaltungsId, null()) as Mobile,
    ApplyMap('Map_LIVE_Email', LiegenschaftsverwaltungsId, null()) as Email,
    Date(NKAuslagerungGueltigAb) as NKAuslagerungGueltigAb_temp,
    Date(DatumLetzteUeberpruefung) as DatumLetzteUeberpruefung_temp
FROM [$(vSourcePath)DS_api_InvestmentData.qvd]
(qvd);


LEFT JOIN (WE_Aktuell)
LOAD Distinct
//    PortfolioId,
//    _KEY_root,
	WirtschaftseinheitsID as %WirtschaftseinheitNr,
    KontenplanAnzeigeModus,
    VomPortfolioVererben,
    Abschlussdatum,
    Abschlussperiodizitaet,
    AbschlussMonatNum,
    AbschlussMonatName ,
    WirtschaftseinheitGueltigAb,
    WirtschaftseinheitGueltigBis
;
// Preceding load
LOAD Distinct
	*,
    Num(Month(Date(Date#(ApplyMap('Map_Months_EnDe', capitalize(lower(Abschlussdatum))), 'MMMM'), '$(DateFormat)'))) as AbschlussMonatNum,
    Date(Date#(ApplyMap('Map_Months_EnDe', capitalize(lower(Abschlussdatum))), 'MMMM'), 'MMMM') as AbschlussMonatName,
    Date(GueltigVon) as WirtschaftseinheitGueltigAb,
    Date(GueltigBis) as WirtschaftseinheitGueltigBis
FROM [$(vSourcePath)DS_api_EinstellungenInvestmentDataWE.qvd]
(qvd);


LEFT JOIN (WE_Aktuell)
LOAD Distinct
    %WirtschaftseinheitNr,
    CapexBuildingToken,
    CapExModelVerwenden,
    LebenszyklusFokus,
    RisikoAkzeptanz
;
// Preceding load
LOAD Distinct
	*,
    Left(_KEY_root, 7) as %WirtschaftseinheitNr,
    ApplyMap('MappingLebenszyklusFokus', LebenszyklusFokus, null()) as LebenszyklusFokus,
    ApplyMap('MappingRisikoAkzeptanz', RisikoAkzeptanz, null()) as RisikoAkzeptanz
FROM [$(vSourcePath)DS_api_CapexSettingsInvestmentDataWE.qvd]
(qvd);


LEFT JOIN (WE_Aktuell)
LOAD Distinct
	%WirtschaftseinheitNr,
    Adresse1 & ' $(vKeySep) ' &  PLZ &' '& Ort & ' $(vKeySep) LG-Nr. ' & if('$(vModuleCloud)'= '0220_Baloise' or '$(vModuleCloud)'= '0237_PK_BS', num(Num#(%WERN),'0000'), %WERN) as Liegenschaft
Resident WE_Aktuell;

// KAG Nebenkategorie Wide-Table

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_NebenkategorieKAG_WE.qvd')) Then

KAG_NK_Generic_Act:
Generic
LOAD Distinct
	%WirtschaftseinheitNr,
 	KAGNebenkategorie,
	'1' as Value
;
//Preceding load
LOAD Distinct
	*,
    Left(_KEY_root, 7) as %WirtschaftseinheitNr,
    ApplyMap('MappingKAGNebenkategorie', KAGNebenkategorie) as KAGNebenkategorie
FROM [$(vSourcePath)DS_api_NebenkategorieKAG_WE.qvd]
(qvd)
WHERE not(isnull(KAGNebenkategorie));

KAG_NK_Cross_Act:
LOAD Distinct
	%WirtschaftseinheitNr
Resident WE_Aktuell;

FOR i = NoOfTables()-1 to 0 STEP -1;
	LET vTable=TableName($(i));
    IF WildMatch('$(vTable)','KAG_NK_Generic_Act.*') THEN
    LEFT JOIN ([KAG_NK_Cross_Act]) LOAD * RESIDENT [$(vTable)];
	DROP TABLE [$(vTable)];
    ENDIF
NEXT i

LEFT JOIN (WE_Aktuell)
LOAD
	*
Resident KAG_NK_Cross_Act;
DROP TABLE KAG_NK_Cross_Act;

END IF

// FINMA Nebenkategorie Wide-Table

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_FINMA_Nebenkategorie_WE.qvd')) Then

FINMA_NK_Generic_Act:
Generic
LOAD Distinct
	%WirtschaftseinheitNr,
    FINMANebenkategorie,
    '1' as Value
;
// Preceding load
LOAD Distinct
    *,
    Left(_KEY_root, 7) as %WirtschaftseinheitNr,
    'FINMA_NK'&'$(vKeySep)'&ApplyMap('MappingFINMANebenKategorie', FINMANebenkategorie, null()) as FINMANebenkategorie
FROM [$(vSourcePath)DS_api_FINMA_Nebenkategorie_WE.qvd]
(qvd)
WHERE not(isnull(FINMANebenkategorie));

FINMA_NK_Cross_Act:
LOAD Distinct
	%WirtschaftseinheitNr
Resident WE_Aktuell;

FOR i = NoOfTables()-1 to 0 STEP -1;
	LET vTable=TableName($(i));
    IF WildMatch('$(vTable)','FINMA_NK_Generic_Act.*') THEN
    LEFT JOIN ([FINMA_NK_Cross_Act]) LOAD * RESIDENT [$(vTable)];
	DROP TABLE [$(vTable)];
    ENDIF
NEXT i

LEFT JOIN (WE_Aktuell)
LOAD Distinct
	*
Resident FINMA_NK_Cross_Act;
DROP TABLE FINMA_NK_Cross_Act;

END IF

// NK-Konten LIVE Wide-Table

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_NebenkostenWE.qvd')) Then

NK_LIVE_Generic_Act:
Generic
LOAD Distinct
	%WirtschaftseinheitNr,
    Konto_NebenkostenLIVE,
    '1' as Value
;
// Preceding load
LOAD Distinct
    *,
    Left(_KEY_root, 7) as %WirtschaftseinheitNr,
    'NK_LIVE'&'$(vKeySep)'&ApplyMap('MappingNebenkostenKonto', Konto_NebenkostenLIVE) as Konto_NebenkostenLIVE
FROM [$(vSourcePath)DS_api_NebenkostenWE.qvd]
(qvd)
WHERE not(isnull(Konto_NebenkostenLIVE));

NK_LIVE_Cross_Act:
LOAD Distinct
	%WirtschaftseinheitNr
Resident WE_Aktuell;

FOR i = NoOfTables()-1 to 0 STEP -1;
	LET vTable=TableName($(i));
    IF WildMatch('$(vTable)','NK_LIVE_Generic_Act.*') THEN
    LEFT JOIN ([NK_LIVE_Cross_Act]) LOAD * RESIDENT [$(vTable)];
	DROP TABLE [$(vTable)];
    ENDIF
NEXT i

LEFT JOIN (WE_Aktuell)
LOAD Distinct
	*
Resident NK_LIVE_Cross_Act;
DROP TABLE NK_LIVE_Cross_Act;

END IF

//tbd (are): Rent-Regulations




// Store QVD
Call QvdStore ('WE_Aktuell', '$(vStorePath)', 'temp', 'WEAktuell', '*', 1);

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_WEAct = (now() - vStartTime_WEAct)*86400;
Trace ---------------------------------- WE Act Dim geladen ----------------------------------;
Trace $(vElapsed_WEAct);
//********************************************************************************************
///$tab 2.2.3 Concatenate WE
//********************************* Start Zeitmessung *********************************
// SET vStartTime_WEConc = 0;
// Set vElapsed_WEConc = 0;
Let vStartTime_WEConc  = now();

//*************************************************************************************

IF Not Isnull(QvdCreateTime('$(vStorePath)temp-WEVersionen.qvd')) Then

  WE_temp:
  NoConcatenate
  LOAD Distinct
      *
  FROM [$(vStorePath)temp-WEAktuell.qvd] (qvd);

  Concatenate(WE_temp)
  LOAD Distinct
      *
  //Resident WE_Versionen;
  FROM [$(vStorePath)temp-WEVersionen.qvd] (qvd);

  // RENAME TABLE WE_Aktuell to WE_temp;
  // DROP TABLE WE_Versionen;

ELSE

  WE_temp:
  NoConcatenate
  LOAD Distinct
      *
  FROM [$(vStorePath)temp-WEAktuell.qvd] (qvd);

END IF


//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_WEConc = (now() - vStartTime_WEConc)*86400;
Trace ---------------------------------- WE Concat geladen ----------------------------------;
Trace $(vElapsed_WEConc);


//********************************* Start Zeitmessung *********************************
// SET vStartTime_KagKomm = 0;
// Set vElapsed_KagKomm = 0;
Let vStartTime_KagKomm  = now();

//*************************************************************************************

/// KAG Kommentare erzeugen
KAG_Kommentar_temp:
NoConcatenate
 LOAD Distinct

	%WEVersion,
    %WirtschaftseinheitNr,
    %WirtschaftseinheitSCDID,
    KAGKategorie,
    FiskalischeKategorie,
    ValidFromDate,
      Year(ValidFromDate) as VersionYear,
	  If(Len(Trim(KommentarKAGKategorie)) > 0, KommentarKAGKategorie, 'n/a') as KommentarKAGKategorie,
      If(Len(Trim(KommentarFiskalischeKategorie)) > 0, KommentarFiskalischeKategorie, 'n/a')  as KommentarFiskalischeKategorie
 
 Resident WE_temp
 Order by %WirtschaftseinheitNr, ValidFromDate;


LEFT JOIN (KAG_Kommentar_temp)
 LOAD Distinct

    %WEVersion,
//     %WirtschaftseinheitNr,
    Only(if(%WirtschaftseinheitNr =Previous([%WirtschaftseinheitNr]) and date#(ValidFromDate,'DD.MM.YYYY')>Previous(date#(ValidFromDate,'DD.MM.YYYY')), Previous(KommentarKAGKategorie), Null())) as Previous_KommentarKAGKategorie,
	Only(if(date#(ValidFromDate,'DD.MM.YYYY')>Previous(date#(ValidFromDate,'DD.MM.YYYY')), Previous(date#(ValidFromDate,'DD.MM.YYYY')),Null())) as Previous_ValidFromDate,
    Only(if(%WirtschaftseinheitNr =Previous([%WirtschaftseinheitNr]) and date#(ValidFromDate,'DD.MM.YYYY')>Previous(date#(ValidFromDate,'DD.MM.YYYY')), Previous(KommentarFiskalischeKategorie),Null())) as Previous_KommentarFiskalischeKategorie


 Resident KAG_Kommentar_temp
  where KommentarKAGKategorie>0 or KommentarFiskalischeKategorie>0
 Group By [%WEVersion] 
 Order by %WirtschaftseinheitNr, ValidFromDate; 

   
Left Join(KAG_Kommentar_temp)	
Load Distinct

	%WirtschaftseinheitNr,
    %WEVersion,
    if (Match(KommentarKAGKategorie , Previous_KommentarKAGKategorie), 'Nein', 'Ja') as Abweichung_KommentarKAGKategorie,
    if (Match (KommentarFiskalischeKategorie, Previous_KommentarFiskalischeKategorie),'Nein', 'Ja') as Abweichung_KommentarFiskalischeKategorie
   
Resident KAG_Kommentar_temp
Order by  %WirtschaftseinheitNr, ValidFromDate;  


LEFT JOIN (KAG_Kommentar_temp)	
   LOAD Distinct

      %WEVersion,
    // %WirtschaftseinheitNr,
        Only(if(Abweichung_KommentarKAGKategorie='Ja', date#(ValidFromDate,'DD.MM.YYYY'),Null() )) as NewVersionDateKAG,
        Only(if(Abweichung_KommentarFiskalischeKategorie='Ja', date#(ValidFromDate,'DD.MM.YYYY'),Null() )) as NewVersionDateFisk

   Resident KAG_Kommentar_temp
   Group By  %WEVersion 
   Order by %WirtschaftseinheitNr, ValidFromDate; 
  
    LEFT JOIN (KAG_Kommentar_temp)	
   LOAD Distinct

      %WEVersion,
      %WirtschaftseinheitNr,
        If(Abweichung_KommentarKAGKategorie='Nein' and Len(Trim(NewVersionDateKAG)=''), peek(NewVersionDate_KAG),NewVersionDateKAG) AS NewVersionDate_KAG,
        If(Abweichung_KommentarFiskalischeKategorie='Nein' and Len(Trim(NewVersionDateFisk)=''), peek(NewVersionDate_Fisk),NewVersionDateFisk) AS NewVersionDate_Fisk
      

   Resident KAG_Kommentar_temp

   Order by %WirtschaftseinheitNr, ValidFromDate; 
   

LEFT JOIN (WE_temp)
LOAD Distinct
	%WirtschaftseinheitSCDID,
    NewVersionDate_KAG,
    NewVersionDate_Fisk
    
Resident KAG_Kommentar_temp;
DROP TABLE KAG_Kommentar_temp;  

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_KagKomm = (now() - vStartTime_KagKomm)*86400;
Trace ---------------------------------- KAG Kommentar-Abweichung geladen ----------------------------------;
Trace $(vElapsed_KagKomm);


// Reverse Geocoding

//********************************* Start Zeitmessung *********************************
// SET vStartTime_RevGeo = 0;
// Set vElapsed_RevGeo = 0;
Let vStartTime_RevGeo = now();
//*************************************************************************************

// Dieser Abschnitt verursacht die Probleme und verlangsamt das Skript um 65% !!!
// **** Ab hier

// Reverse Geocoding Gemeinde und Stadtviertel
// $(Must_Include=lib://0100_Global/01_Include\01_qvs\ReverseGeocoding_WE_ql.qvs);


// RevGeo_temp2:
// NoConcatenate
// LOAD Distinct
// 	Geokey_temp as Geokey,
//     Gemeinde_rev_geo,
//     %M_Gemeindecode,
//     Stadtviertelcode,
// 	%Benchmark,
//     %geo_ID,
//     Gemeindecode,
//     Kantonscode
// ;
// // Preceding load
// LOAD Distinct
// 	*,
//     GeoMakePoint(Breitengrad, Laengengrad) as Geokey_temp,
//     %M_Gemeindecode  & '$(vKeySep)'& Stadtviertelcode as %Benchmark,
//     If(IsNull(%M_Gemeindecode) = -1 or Len(Trim(%M_Gemeindecode))=0, 'NA', %M_Gemeindecode) as  Gemeindecode,  
//     IF (Stadtviertelcode > 1, Stadtviertelcode, %M_Gemeindecode)as %geo_ID,
// 	Applymap('Mapping_gemcode_kantcode',%M_Gemeindecode) as Kantonscode

// Resident RevGeo_temp;			// comes from the external script...
// DROP TABLE RevGeo_temp;

// // Join Geodata to WE-Table
// LEFT JOIN (WE_temp)
// LOAD Distinct
// 	Geokey,
//     Gemeinde_rev_geo,
//     Stadtviertelcode,
// 	%Benchmark,
//     %geo_ID,
//     Gemeindecode,
//     Kantonscode

// Resident RevGeo_temp2;
// DROP TABLE RevGeo_temp2;   

// **** Bis hier

// Mapping_RegName_temp:							are: in die 02 transferiert
// //neueste internationales Gemeindemapping
// NoConcatenate
// LOAD Distinct
//     If(Len(Trim(Stadtviertelcode)) = 0, %M_Gemeindecode, Stadtviertelcode) as %geo_ID,
//     %gemeindeCode as %Gemeinde,
//     gemeinde,
//     %Kantonscode as %Kanton,
//     kanton,
//     land,
//     MonitCode,
//     MonitReg as %MonitReg,
//     ms_region,
//     %MSCode as %MS_Region,
//     Stadtviertelcode as %stadtkreise,
//     stadtkreise,
//     [%M_Gemeindecode] as %GemCode_Bench,
//     [%landCode],
//     typ00code as Gemeindetyp00code,
//     typ00name as Gemeindetyp00name,
//     gemeindetyp_9code as Gemeindetyp9code,
//     gemeindetyp_9name as Gemeindetyp9name
// FROM [lib://0100_Global/04_Datasource/02_qvd_Source/mapping_Union.qvd]
// (qvd)
// WHERE Match(%landCode, 'CH')>0;

// INNER JOIN (Mapping_RegName_temp)
// LOAD Distinct
// 	%CountryCode2 as [%landCode] 
// Resident WE_temp;

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_RevGeo = (now() - vStartTime_RevGeo)*86400;
Trace ---------------------------------- RevGeocoding geladen ----------------------------------;
Trace $(vElapsed_RevGeo);
//********************************************************************************************

// Store QVD
Call QvdStore ('WE_temp', '$(vStorePath)', 'temp', 'WE_temp', '*', 1);  	// final Table stored in "WE_Bridge_Table"

// Store QVD
// Call QvdStore ('Mapping_RegName_temp', '$(vStorePath)', 'RF_MD', 'Mapping_RegName', '*', 1); 

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_WETotal = (now() - vStartTime_WETotal)*86400;
Trace ---------------------------------- WE Total Dim geladen ----------------------------------;
Trace $(vElapsed_WETotal);
//********************************************************************************************
///$tab 2.3 Grundstücke (WE)

///$tab 2.3.1 Grundstck. / Rechte - Versioniert
//********************************* Start Zeitmessung *********************************
// SET vStartTime_LandTotal = 0;
// SET vStartTime_LandVer = 0;
// Set vElapsed_LandTotal = 0;
// Set vElapsed_LandVer = 0;
Let vStartTime_LandTotal  = now();
Let vStartTime_LandVer  = now();

//*************************************************************************************

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Grundstuecke_WE_Versionen.qvd')) Then


// Versionierte Daten

// LandPlots
Grundstuecke_WE_Versions:
LOAD Distinct
    _KEY_root,
    %WirtschaftseinheitSCDID,
    WirtschaftseinheitsID,
    %GrundstuecksSCDID,
    Anmerkung,
    NameGrundstueck,
    EigentuemerGrundstueck,
    Eigentum as EigentumGrundstueck,
    Eigentumsanteil,
    GS_Referenz_Nr,
    GrundstuecksID,
	BemerkungGrundstueck,
    Bauzone,
    Ausnutzung,
    AusnutzungsZiffer,
    Gebaeudeflaechenanteil,
    Vormerkung,
    Altlastenkataster,
    Sondernutzungsplan,
    Flurname,
    Grundbuchblattnummer,
    Grundstuecksflaeche,
    GrundstueckWertquoteEigentum,
    GrundstueckWertquoteTotal,
    Grundbuchgemeinde,
    Grundbucheintragung,
    Katasternummer,
    Grundbuchauszugsdatum,
    Grundbuchamt,
    Denkmalschutz,
    Plannummer,
    BemerkungPlanungsrecht,
    Lfd_Eintragungsnumme,
    Dienstbarkeit,
    '' as EGRID,		// EGRID to be added through the API on 29/11
//    _KEY_buildingConnections,
    WirtschaftseinheitsVersionID,
    istMasterGrundstueck,
    RefGebaudeID,
//    MiteigentumTyp
;
// Preceding load
LOAD
	*,
    ApplyMap('MappingAusnutzung', Ausnutzung, null()) as Ausnutzung,
    ApplyMap('MappingEigentum', EigentumGrundstueck, null()) as Eigentum,
//    ApplyMap('MappingMiteigentumsTyp', MiteigentumTyp, null()) as MiteigentumTyp,
	WirtschaftseinheitsID & '$(vKeySep)' & WirtschaftseinheitsVersionID as %WirtschaftseinheitSCDID,
    GrundstuecksID & '$(vKeySep)' & WirtschaftseinheitsVersionID as %GrundstuecksSCDID
FROM [$(vSourcePath)DS_api_Grundstuecke_WE_Versionen.qvd]
(qvd);			// should only be the ismaster=True?


// Miteigentum Crosstab-Link
MET_Generic_Ver:
Generic
LOAD Distinct
    _KEY_root,
    MiteigentumTyp,
    '1' as Value
;
// Preceding load
LOAD
	*,
    'Miteigentum'&'$(vKeySep)'&ApplyMap('MappingMiteigentumsTyp', MiteigentumTyp) as MiteigentumTyp
FROM [$(vSourcePath)DS_api_Grundstuecke_WE_Versionen.qvd]
(qvd)
WHERE not(isnull(MiteigentumTyp));

MET_Generic_Cross_Ver:
LOAD Distinct
	_KEY_root
Resident Grundstuecke_WE_Versions;

FOR i = NoOfTables()-1 to 0 STEP -1;
	LET vTable=TableName($(i));
    IF WildMatch('$(vTable)','MET_Generic_Ver.*') THEN
    LEFT JOIN ([MET_Generic_Cross_Ver]) LOAD * RESIDENT [$(vTable)];
	DROP TABLE [$(vTable)];
    ENDIF
NEXT i

LEFT JOIN (Grundstuecke_WE_Versions)
LOAD
	*
Resident MET_Generic_Cross_Ver;
DROP TABLE MET_Generic_Cross_Ver;


//Rights
Rechte_WE_Versions:
NoConcatenate
LOAD Distinct
//    %WirtschaftseinheitSCDID,
    %GrundstuecksSCDID,
    RechtName,
    Rolle,
    BaurechtGegenpartei as Gegenpartei,
    BeginnDatum,
    AblaufDatum,
    BaurechtAusuebungsdauer as Ausuebungsfrist,
    FaelligkeitsDatum,
    AnpassungsDatumBaurechtszins,
    BaurechtAnpassungIntervall as AnpassungsrythumsBaurechtszins,
    NaechsteAnpassungBaurechtszins,
    '' as Kaufpreis,
    BaurechtKommentar as Bemerkung
; 
// Preceding load
LOAD
	*,
    Date(BaurechtAnpassungsDatum) as AnpassungsDatumBaurechtszins,
    Date(BaurechtNaechsteAnpassung) as NaechsteAnpassungBaurechtszins,
    Date(BaurechtStartdatum) as BeginnDatum,
    Date(BaurechtEnddatum) as AblaufDatum,
    AddMonths(BaurechtEnddatum, num(BaurechtAusuebungsdauer)*(-1)) as FaelligkeitsDatum,
    'Baurecht' as RechtName,
    ApplyMap('MappingRolle', BaurechtRolle, null()) as Rolle,
    GrundstuecksID & '$(vKeySep)' & WirtschaftseinheitsVersionID as %GrundstuecksSCDID
//    WirtschaftseinheitsID & '$(vKeySep)' & WirtschaftseinheitsVersionID as %WirtschaftseinheitSCDID
FROM [$(vSourcePath)DS_api_Grundstuecke_WE_Versionen.qvd]
(qvd)
WHERE BaurechtVorhanden = 'True';


Concatenate (Rechte_WE_Versions)
LOAD Distinct
//	%WirtschaftseinheitSCDID,
    %GrundstuecksSCDID,
    RechtName,
    Rolle,
    VorkaufsrechtGegenpartei as Gegenpartei,
    '' as BeginnDatum,
    AblaufDatum,
    VorkaufsrechtAusuebungsdauer as Ausuebungsfrist,
    '' as FaelligkeitsDatum,
    '' as AnpassungsDatumBaurechtszins,
    '' as AnpassungsrythumsBaurechtszins,
    '' as NaechsteAnpassungBaurechtszins,
    '' as Kaufpreis,
    VorkaufsrechtBemerkung as Bemerkung,
;
// Preceding load    
LOAD
	*,
    Date(VorkaufsrechtAusuebungsdatum) as AblaufDatum,
    'Vorkaufsrecht' as RechtName,
    ApplyMap('MappingRolle', VorkaufsrechtRolle, null()) as Rolle,
    GrundstuecksID & '$(vKeySep)' & WirtschaftseinheitsVersionID as %GrundstuecksSCDID
//    WirtschaftseinheitsID & '$(vKeySep)' & WirtschaftseinheitsVersionID as %WirtschaftseinheitSCDID
FROM [$(vSourcePath)DS_api_Grundstuecke_WE_Versionen.qvd]
(qvd)
WHERE VorkaufsrechtVorhanden = 'True';

Concatenate (Rechte_WE_Versions)
LOAD Distinct
//	%WirtschaftseinheitSCDID,
    %GrundstuecksSCDID,
    RechtName,
    Rolle,
    KaufrechtGegenpartei as Gegenpartei,
    '' as BeginnDatum,
    AblaufDatum,
    KaufrechtAusuebungsdauer as Ausuebungsfrist,
    '' as FaelligkeitsDatum,
    '' as AnpassungsDatumBaurechtszins,
    '' as AnpassungsrythumsBaurechtszins,
    '' as NaechsteAnpassungBaurechtszins,
    DefinitiverKaufpreis as Kaufpreis,
    KaufrechtBemerkung as Bemerkung,
;
// Preceding load
LOAD
	*,
    Date(KaufrechtAusuebungsdatum) as AblaufDatum,
    'Kaufrecht' as RechtName,
    ApplyMap('MappingRolle', KaufrechtRolle, null()) as Rolle,
    GrundstuecksID & '$(vKeySep)' & WirtschaftseinheitsVersionID as %GrundstuecksSCDID
//    WirtschaftseinheitsID & '$(vKeySep)' & WirtschaftseinheitsVersionID as %WirtschaftseinheitSCDID    
FROM [$(vSourcePath)DS_api_Grundstuecke_WE_Versionen.qvd]
(qvd)
WHERE KaufrechtVorhanden = 'True';

// Join the Rights to the Landplots (1-to-1)
LEFT JOIN (Grundstuecke_WE_Versions)
LOAD Distinct
	*
Resident Rechte_WE_Versions;
DROP TABLE Rechte_WE_Versions;

// Store QVD
Call QvdStore ('Grundstuecke_WE_Versions', '$(vStorePath)', 'temp', 'Grundstuecke_WE_Versions', '*', 1);

END IF

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_LandVer = (now() - vStartTime_LandVer)*86400;
Trace ---------------------------------- Grundstücke SCD Dim geladen ----------------------------------;
Trace $(vElapsed_LandVer);
//********************************************************************************************

///$tab 2.3.2 Grundstck. / Rechte - Aktuell
//********************************* Start Zeitmessung *********************************
// SET vStartTime_LandAct = 0;
// Set vElapsed_LandAct = 0;
Let vStartTime_LandAct  = now();

//*************************************************************************************

// Land Plots Actual
Grundstuecke_Aktuell:
LOAD Distinct
    _KEY_content,
//    _KEY_root,
    %WirtschaftseinheitSCDID,
    WirtschaftseinheitsID,
    %GrundstuecksSCDID,
    Anmerkung,     
	NameGrundstueck,
    EigentuemerGrundstueck,
    EigentumGrundstueck,        
    Eigentumsanteil,    
    GS_Referenz_Nr,
    GrundstuecksID,
    BemerkungGrundstueck,
    Bauzone,
    Ausnutzung,
    AusnutzungsZiffer,
    Vormerkung,
    Altlastenkataster,
    Sondernutzungsplan,
    Flurname,
    Grundbuchblattnummer,
    Grundstuecksflaeche,
    GrundstueckWertquoteEigentum,
    GrundstueckWertquoteTotal,
    Grundbuchgemeinde,
    Grundbucheintragung,
    Katasternummer,
    Grundbuchauszugsdatum,
    Grundbuchamt,
    Denkmalschutz,
    Plannummer,
    BemerkungPlanungsrecht,
    Lfd_Eintragungsnumme,
    Dienstbarkeit,
    EGRID,    // not yet available in the Versioned data, will be there with the next load
    'Actual' as WirtschaftseinheitsVersionID,
    istMasterGrundstueck,
    '' as RefGebeudeID,  // only in the Versioned data, reference to the Buildings
    '' as Gebaeudeflaechenanteil,   // only in the Versioned data, reference to the Buildings
;
// Preceding load
LOAD
	*,
    ApplyMap('MappingAusnutzung', Ausnutzung, null()) as Ausnutzung,
    ApplyMap('MappingEigentum', EigentumGrundstueck, null()) as EigentumGrundstueck,
    WirtschaftseinheitsID & '$(vKeySep)' & 'Actual' as %WirtschaftseinheitSCDID,
    GrundstuecksID & '$(vKeySep)' & 'Actual' as %GrundstuecksSCDID
;    
// Preceding load
LOAD
	*,
    SubField(_KEY_content,'$(vKeySep)',1) as WirtschaftseinheitsID
FROM [$(vSourcePath)DS_api_Grundstuecke_WE.qvd]
(qvd); // should only be the ismaster=True?

If  not Isnull(QvdCreateTime('$(vSourcePath)DS_api_MiteigentumTyp_WE.qvd')) then

// Miteigentum Crosstab-Link
MET_Generic_Act:
Generic
LOAD Distinct
    _KEY_content,
    MiteigentumTyp,
    '1' as Value
;
// Preceding load
LOAD
	*,
    'Miteigentum'&'$(vKeySep)'&ApplyMap('MappingMiteigentumsTyp', MiteigentumTyp) as MiteigentumTyp
FROM [$(vSourcePath)DS_api_MiteigentumTyp_WE.qvd]
(qvd)
WHERE not(isnull(MiteigentumTyp));

END IF

MET_Generic_Cross_Act:
LOAD Distinct
	_KEY_content
Resident Grundstuecke_Aktuell;

FOR i = NoOfTables()-1 to 0 STEP -1;
	LET vTable=TableName($(i));
    IF WildMatch('$(vTable)','MET_Generic_Act.*') THEN
    LEFT JOIN ([MET_Generic_Cross_Act]) LOAD * RESIDENT [$(vTable)];
	DROP TABLE [$(vTable)];
    ENDIF
NEXT i

LEFT JOIN (Grundstuecke_Aktuell)
LOAD
	*
Resident MET_Generic_Cross_Act;
DROP TABLE MET_Generic_Cross_Act;


// Rechte
Rechte_Aktuell:
NoConcatenate
LOAD Distinct
    _KEY_content,
    RechtName,
    Rolle,
    BaurechtGegenpartei as Gegenpartei,
    BeginnDatum,
    AblaufDatum,
    BaurechtAusuebungsdauer as Ausuebungsfrist,
    FaelligkeitsDatum,
    AnpassungsDatumBaurechtszins,
    BaurechtAnpassungIntervall as AnpassungsrythumsBaurechtszins,
    NaechsteAnpassungBaurechtszins,
    '' as Kaufpreis,
    BaurechtKommentar as Bemerkung
;    
// Preceding load    
LOAD
	*,
    Date(BaurechtAnpassungsDatum) as AnpassungsDatumBaurechtszins,
    Date(BaurechtNaechsteAnpassung) as NaechsteAnpassungBaurechtszins,
    Date(BaurechtStartdatum) as BeginnDatum,
    Date(BaurechtEnddatum) as AblaufDatum,
    AddMonths(BaurechtEnddatum, num(BaurechtAusuebungsdauer)*(-1)) as FaelligkeitsDatum,
    'Baurecht' as RechtName,
    ApplyMap('MappingRolle', BaurechtRolle, null()) as Rolle
//    GrundstuecksID & '$(vKeySep)' & WirtschaftseinheitsVersionID as %GrundstuecksSCDID
//    WirtschaftseinheitsID & '$(vKeySep)' & WirtschaftseinheitsVersionID as %WirtschaftseinheitSCDID
FROM [$(vSourcePath)DS_api_Baurecht_WE.qvd]
(qvd)
WHERE BaurechtVorhanden = 'True';

Concatenate (Rechte_Aktuell)
LOAD Distinct
    _KEY_content,
    RechtName,
    Rolle,
    VorkaufsrechtGegenpartei as Gegenpartei,
    '' as BeginnDatum,
    AblaufDatum,
    VorkaufsrechtAusuebungsdauer as Ausuebungsfrist,
    '' as FaelligkeitsDatum,
    '' as AnpassungsDatumBaurechtszins,
    '' as AnpassungsrythumsBaurechtszins,
    '' as NaechsteAnpassungBaurechtszins,
    '' as Kaufpreis,
    VorkaufsrechtBemerkung as Bemerkung,
;
// Preceding load
LOAD
	*,
     Date(VorkaufsrechtAusuebungsdatum) as AblaufDatum,
    'Vorkaufsrecht' as RechtName,
    ApplyMap('MappingRolle', VorkaufsrechtRolle, null()) as Rolle
//    GrundstuecksID & '$(vKeySep)' & WirtschaftseinheitsVersionID as %GrundstuecksSCDID
//    WirtschaftseinheitsID & '$(vKeySep)' & WirtschaftseinheitsVersionID as %WirtschaftseinheitSCDID
    
FROM [$(vSourcePath)DS_api_Vorkaufsrecht_WE.qvd]
(qvd)
WHERE VorkaufsrechtVorhanden = 'True';

Concatenate (Rechte_Aktuell)
LOAD Distinct
    _KEY_content,
    RechtName,
    Rolle,
    KaufrechtGegenpartei as Gegenpartei,
    '' as BeginnDatum,
    AblaufDatum,
    KaufrechtAusuebungsdauer as Ausuebungsfrist,
    '' as FaelligkeitsDatum,
    '' as AnpassungsDatumBaurechtszins,
    '' as AnpassungsrythumsBaurechtszins,
    '' as NaechsteAnpassungBaurechtszins,
    DefinitiverKaufpreis as Kaufpreis,
    KaufrechtBemerkung as Bemerkung,
;
// Preceding load
LOAD
	*,
     Date(KaufrechtAusuebungsdatum) as AblaufDatum,
    'Kaufrecht' as RechtName,
    ApplyMap('MappingRolle', KaufrechtRolle, null()) as Rolle
//    GrundstuecksID & '$(vKeySep)' & WirtschaftseinheitsVersionID as %GrundstuecksSCDID
//    WirtschaftseinheitsID & '$(vKeySep)' & WirtschaftseinheitsVersionID as %WirtschaftseinheitSCDID

FROM [$(vSourcePath)DS_api_Kaufrecht_WE.qvd]
(qvd)
WHERE KaufrechtVorhanden = 'True';

// Join the rights into the Actual Land plots
LEFT JOIN (Grundstuecke_Aktuell)
LOAD Distinct
	*
Resident Rechte_Aktuell;
DROP TABLE Rechte_Aktuell;

DROP FIELD [_KEY_content] FROM Grundstuecke_Aktuell;

// Store QVD
Call QvdStore ('Grundstuecke_Aktuell', '$(vStorePath)', 'temp', 'Grundstuecke_Aktuell', '*', 1);

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_LandAct = (now() - vStartTime_LandAct)*86400;
Trace ---------------------------------- Grundstücke Act Dim geladen ----------------------------------;
Trace $(vElapsed_LandAct);
//********************************************************************************************

///$tab 2.3.3 Concatenate Grundstck. / Rechte
//********************************* Start Zeitmessung *********************************
// SET vStartTime_LandConc = 0;
// Set vElapsed_LandConc = 0;
Let vStartTime_LandConc  = now();

//*************************************************************************************

IF Not Isnull(QvdCreateTime('$(vStorePath)temp-Grundstuecke_WE_Versions.qvd')) Then

  Grundstuecke_temp:
  NoConcatenate
  LOAD Distinct
      *
  FROM [$(vStorePath)temp-Grundstuecke_Aktuell.qvd] (qvd);


  Concatenate(Grundstuecke_temp)
  LOAD Distinct
      *
  // Resident Grundstuecke_WE_Versions;
  FROM [$(vStorePath)temp-Grundstuecke_WE_Versions.qvd] (qvd);

  // RENAME TABLE Grundstuecke_Aktuell to Grundstuecke_temp;
  // DROP TABLE Grundstuecke_WE_Versions;

ELSE

  Grundstuecke_temp:
  NoConcatenate
  LOAD Distinct
      *
  FROM [$(vStorePath)temp-Grundstuecke_Aktuell.qvd] (qvd);

END IF

// Store QVD
Call QvdStore ('Grundstuecke_temp', '$(vStorePath)', 'RF_MD', 'GrundstueckeUndRechte', '*', 1);

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_LandConc = (now() - vStartTime_LandConc)*86400;
Let vElapsed_LandTotal = (now() - vStartTime_LandTotal)*86400;
Trace ---------------------------------- Grundstücke Cons geladen ----------------------------------;
Trace $(vElapsed_LandConc);
Trace ---------------------------------- Grundstücke Total geladen ----------------------------------;
Trace $(vElapsed_LandTotal);
//********************************************************************************************
///$tab 2.4 Gebäude (WE)

///$tab 2.4.1 Gebaeude Versioniert & Aktuell
//********************************* Start Zeitmessung *********************************
// SET vStartTime_BuildingConc = 0;
// Set vElapsed_BuildingConc = 0;
Let vStartTime_BuildingConc  = now();

//*************************************************************************************

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Gebaeude_WE_Versionen.qvd')) Then

// Load Building with Versions
Gebaeude_Versionen:
LOAD Distinct
    %WirtschaftseinheitSCDID,
    WirtschaftseinheitsID,
    %GebaudeSCDID,
    GebaeudeID,
    NameGebaeude,
    ReferenzNrGebaeude,
    EGID_Gebaeude,
    Gebaeudetyp,
    BemerkungGebaeude,
    Minergiezertifikat, 
    istMasterGebaeude,    
    TypGebaeudevolumen,
    Gebaeudevolumen,    
    TypGebaeudegeschossflaeche,
    Gebaeudegeschossflaeche,
    TypGebaeudegrundflaeche,
    Gebaeudegrundflaeche,    
    TypGebaeudenutzflaeche,
    Gebaeudenutzflaeche,
    RefGrundstuecksID,   // in or out of scope? as this is not available in the API for the non-versioned buildings
    Gebaeudeflaechenanteil,
    istHauptparzelle,
//     Baujahr,
//     KommentarBaujahr,
//     TotaleLebensdauer,
//     Sanierungsjahr,
//     KommentarSanierung,
//    RelLinkName,
//    _KEY_landPlotConnections,
//    _KEY_root,
    WirtschaftseinheitsVersionID
;
// // Preceding load
// LOAD
// 	*,
//     Max(Baujahr) as Baujahr,
//     Max(Sanierungsjahr) as Sanierungsjahr,
//     FirstSortedValue(KommentarBaujahr,-Baujahr) as KommentarBaujahr,
//     FirstSortedValue(TotaleLebensdauer,-Baujahr) as TotaleLebensdauer,
//     FirstSortedValue(KommentarSanierungsjahr,-Sanierungsjahr) as KommentarSanierung
// ;
// Preceding load
LOAD
	*,
    ApplyMap('MappingGebaeudetyp', Gebaeudetyp, null()) as Gebaeudetyp,
    GebaeudeID & '$(vKeySep)' & WirtschaftseinheitsVersionID as %GebaudeSCDID,
    WirtschaftseinheitsID & '$(vKeySep)' & WirtschaftseinheitsVersionID as %WirtschaftseinheitSCDID,
    ApplyMap('MappingMinergiezertifikat', Minergiezertifikat, null()) as Minergiezertifikat
FROM [$(vSourcePath)DS_api_Gebaeude_WE_Versionen.qvd]
(qvd);   // should be istMaster = True?

BauSanierungsjahre_temp:
LOAD Distinct
	GebaeudeID & '$(vKeySep)' & WirtschaftseinheitsVersionID as %GebaudeSCDID,
    Baujahr,
    Sanierungsjahr,
    KommentarBaujahr,
    TotaleLebensdauer,
    KommentarSanierungsjahr
FROM [$(vSourcePath)DS_api_Gebaeude_WE_Versionen.qvd]
(qvd);   // should be istMaster = True?

LEFT JOIN (Gebaeude_Versionen)
LOAD Distinct
    %GebaudeSCDID,
    Max(Baujahr) as Baujahr,
    Max(Sanierungsjahr) as Sanierungsjahr,
    FirstSortedValue(KommentarBaujahr,-Baujahr) as KommentarBaujahr,
    FirstSortedValue(TotaleLebensdauer,-Baujahr) as TotaleLebensdauer,
    FirstSortedValue(KommentarSanierungsjahr,-Sanierungsjahr) as KommentarSanierung
Resident BauSanierungsjahre_temp
GROUP BY %GebaudeSCDID;

DROP TABLE BauSanierungsjahre_temp;

END IF


// Load Actual Buildings
Gebaeude_Aktuell:
LOAD Distinct
	_KEY_content,
	%WirtschaftseinheitSCDID,
    WirtschaftseinheitsID,
    %GebaudeSCDID,
    GebaeudeID,
    NameGebaeude,
    ReferenzNrGebaeude,
	EGID_Gebaeude,
    Gebaeudetyp,
    KommentarGebaeude as BemerkungGebaeude,
    Minergiezertifikat,
    istMasterGebaeude,
    '' as RefGrundstuecksID,	// not available in the non-Versioned
    '' as Gebaeudeflaechenanteil,  // not available in the non-Versioned
    '' as istHauptparzelle,     // not available in the non-Versioned
    'Actual' as WirtschaftseinheitsVersionID
//    _KEY_root,
;
// Preceding load
LOAD
	*,
    GebaeudeID & '$(vKeySep)' & 'Actual' as %GebaudeSCDID,
    WirtschaftseinheitsID & '$(vKeySep)' & 'Actual' as %WirtschaftseinheitSCDID
;
// Preceding load
LOAD
	*,
    SubField(_KEY_content,'$(vKeySep)',1) as WirtschaftseinheitsID,
    ApplyMap('MappingMinergiezertifikat', Minergiezertifikat, null()) as Minergiezertifikat
FROM [$(vSourcePath)DS_api_Gebaeude_WE.qvd]
(qvd)
/*where istMasterGebaeude = 'True'*/;


Left Join(Gebaeude_Aktuell)
LOAD Distinct
    _KEY_content,
    TypGebaeudevolumen,
    Gebaeudevolumen
FROM [$(vSourcePath)DS_api_Gebaeudevolumen_WE.qvd]
(qvd);

Left Join(Gebaeude_Aktuell)
LOAD Distinct
    _KEY_content,
    TypGeschossflaeche,
    Geschossflaeche
FROM [$(vSourcePath)DS_api_Geschossflaeche_WE.qvd]
(qvd);

Left Join(Gebaeude_Aktuell)
LOAD Distinct
    _KEY_content,
    TypGebaeudegrundflaeche,
    Gebaeudegrundflaeche
FROM [$(vSourcePath)DS_api_Gebaeudegrundflaeche_WE.qvd]
(qvd);

Left Join(Gebaeude_Aktuell)
LOAD Distinct
    _KEY_content,
    TypNutzflaeche,
    Nutzflaeche
FROM [$(vSourcePath)DS_api_Nutzflaeche_WE.qvd]
(qvd);

Left Join(Gebaeude_Aktuell)
LOAD Distinct
    _KEY_content,
    max(Baujahr) as Baujahr,		// Only Max Construction Year taken
    FirstSortedValue(KommentarBaujahr,-Baujahr) as KommentarBaujahr,
    FirstSortedValue(TotaleLebensdauer,-Baujahr) as TotaleLebensdauer  
FROM [$(vSourcePath)DS_api_Baujahre_WE.qvd]
(qvd)
group by [_KEY_content];


If not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Sanierungen_WE.qvd')) Then

Left Join(Gebaeude_Aktuell)
LOAD Distinct

    _KEY_content,
//    Max(Year(Date(StartSanierung))) as Sanierungsjahr,
	max(StartSanierung) as Sanierungsjahr,
    FirstSortedValue(Bemerkung,-StartSanierung) as KommentarSanierung
//    Bemerkung
//     max(Sanierungsjahr) as Sanierungsjahr, 		// Only Max Refurbishment Year taken
//    FirstSortedValue(KommentarBaujahr,-Sanierungsjahr) as KommentarSanierung

FROM [$(vSourcePath)DS_api_Sanierungen_WE.qvd]
(qvd)
group by [_KEY_content];

//are: not working 13/10/22
// Left Join(Gebaeude_Aktuell)
// LOAD Distinct
//     _KEY_content,
//      max(Sanierungsjahr) as Sanierungsjahr, 		// Only Max Refurbishment Year taken
//      FirstSortedValue(KommentarBaujahr,-Sanierungsjahr) as KommentarSanierung
// FROM [$(vSourcePath)DS_api_Sanierungen_WE.qvd]
// (qvd)
// group by [_KEY_content];

End If


Drop Field [_KEY_content] from Gebaeude_Aktuell;

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Gebaeude_WE_Versionen.qvd')) Then

  // Concatenate Buildings
  Concatenate (Gebaeude_Aktuell)
  LOAD Distinct
      *
  Resident Gebaeude_Versionen;

  RENAME TABLE Gebaeude_Aktuell to Gebaeude_temp;
  DROP TABLE Gebaeude_Versionen;

ELSE

  RENAME TABLE Gebaeude_Aktuell to Gebaeude_temp;

END IF


// Store QVD
Call QvdStore ('Gebaeude_temp', '$(vStorePath)', 'RF_MD', 'Gebaeude', '*', 1);

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_BuildingConc = (now() - vStartTime_BuildingConc)*86400;
Trace ---------------------------------- Gebäude Cons geladen ----------------------------------;
Trace $(vElapsed_BuildingConc);
//********************************************************************************************
///$tab 2.5 Referenzwerte (WE)

///$tab 2.5.1 Referenzwerte Versioniert & Aktuell
//********************************* Start Zeitmessung *********************************
// SET vStartTime_RefWert = 0;
// Set vElapsed_RefWert = 0;
Let vStartTime_RefWert  = now();

//*************************************************************************************

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Referenzwerte_WE_Versionen.qvd')) Then

// Referenzwerte Versioniert
Referenzwerte_Versionen:
NoConcatenate
LOAD Distinct
    %WirtschaftseinheitSCDID,
    WirtschaftseinheitsID,
//    %ReferenzwertSCDID,
    ReferenzwertID as %ReferenzwertID,
    NameReferenzwert,
    ReferenzwertTyp,
    ReferenzwertDatum,
    BemerkungReferenzwert,
    Referenzwert,
    ReferenzwertDetails,
	Transaktionstyp,
    Transaktionskosten,
    NettoTransaktionspreis,
    Vertragsdatum,
    UngewoehnterFusswegrecht,
    Transaktionsmethode,
    GrundbuchamtAnmeldung,
    TransaktionsdetailTyp,
    Transaktionsmotiv,
    Zielnutzung,
    DealStruktur,
    Kaufpreis_Erstellungskosten,
    Sanierungskosten,
    KostenParkierungVerfügbar,
    KostenParkierung,
    KostenBastelraumVerfügbar,
    KostenBastelraum,
    AndereKostenVerfügbar,
    AndereKosten,
    Verkauf,
    IndexStand,
    IndexJahr
//    RelLinkName,
;
// Preceding load
LOAD
	*,
    if(Transaktionstyp='Verkauf','1','0') as Verkauf
;
// Preceding load
LOAD
	*,
    WirtschaftseinheitsID & '$(vKeySep)' & WirtschaftseinheitsVersionID as %WirtschaftseinheitSCDID,
//    ReferenzwertID & '$(vKeySep)' &  WirtschaftseinheitsVersionID as %ReferenzwertSCDID,
    Date(Vertragsdatum) as Vertragsdatum,
    Date(ReferenzwertDatum) as ReferenzwertDatum,
    Date(GrundbuchamtAnmeldung) as GrundbuchamtAnmeldung,
    ApplyMap('MappingReferenzwertTyp', ReferenzwertTyp, null()) as ReferenzwertTyp,
    ApplyMap('MappingTransaktionstyp', Transaktionstyp, null()) as Transaktionstyp,
    ApplyMap('MappingTransaktionsdetailTyp', TransaktionsdetailTyp, null()) as TransaktionsdetailTyp,
    ApplyMap('MappingTransaktionsmotiv', Transaktionsmotiv, null()) as Transaktionsmotiv,
    ApplyMap('MappingTransaktionsmethode', Transaktionsmethode, null()) as Transaktionsmethode,
    ApplyMap('MappingZielnutzung', Zielnutzung, null()) as Zielnutzung,
    ApplyMap('MappingDealStruktur', DealStruktur, null()) as DealStruktur
FROM [$(vSourcePath)DS_api_Referenzwerte_WE_Versionen.qvd]
(qvd);

Gestaffelte_TR_Versionen:
LOAD Distinct
//	%ReferenzwertSCDID,
    ReferenzwertID as %ReferenzwertID,
	ReferenzwertGestaffelt,
    BemerkungGestaffelteTR,
    DatumGestaffelteTR,
    PreisGestaffelteTR,
    Erwerbsnebenkosten,
    Einkaeufer,
    EinkaeuferCombName,
    Verkaeufer,
    VerkaeuferCombName,
;    
// Preceding load
LOAD
	*,
    Date(DatumGestaffelteTR) as DatumGestaffelteTR,
//    ReferenzwertID & '$(vKeySep)' &  WirtschaftseinheitsVersionID as %ReferenzwertSCDID,
    ReferenzwertTyp & ' ' & ReferenzwertDatum & ' ' & BemerkungReferenzwert as ReferenzwertGestaffelt,
    EinkaeuferName & ' ' & EinkaeuferAddress as EinkaeuferCombName,
    VerkaeuferName & ' ' & VerkaeuferAddress as VerkaeuferCombName
;
// Preceding load
LOAD
    *,
    ApplyMap('Map_Stakeholders_Name', Einkaeufer, null()) as EinkaeuferName,
    ApplyMap('Map_Stakeholders_Address', Einkaeufer, null()) as EinkaeuferAddress,
    ApplyMap('Map_Stakeholders_Name', Verkaeufer, null()) as VerkaeuferName,
    ApplyMap('Map_Stakeholders_Address', Verkaeufer, null()) as VerkaeuferAddress
FROM [$(vSourcePath)DS_api_Referenzwerte_WE_Versionen.qvd]
(qvd)
WHERE not(isnull(_KEY_referenceValueDetails));

END IF

// Referenzwerte Aktuell
Referenzwerte_Aktuell:
NoConcatenate
LOAD Distinct
	[_KEY_content],
    %WirtschaftseinheitSCDID,
    WirtschaftseinheitsID,
//    %ReferenzwertSCDID,
    ReferenzwertID as %ReferenzwertID,
    NameReferenzwert,
    ReferenzwertTyp,
    ReferenzwertDatum,
    BemerkungReferenzwert,
    Referenzwert,
//	ReferenzwertBenutzt,
//  ReferenzwertDetails, // not available anymore
;
// Preceding load
LOAD
	*,
    WirtschaftseinheitsID & '$(vKeySep)' & WirtschaftseinheitsVersionID as %WirtschaftseinheitSCDID,
//    ReferenzwertID & '$(vKeySep)' &  WirtschaftseinheitsVersionID as %ReferenzwertSCDID,
    ApplyMap('MappingReferenzwertTyp', ReferenzwertTyp, null()) as ReferenzwertTyp,
    Date(ReferenzwertDatum) as ReferenzwertDatum
;
// Preceding load
LOAD
	*,
    Left(_KEY_root, 7) as WirtschaftseinheitsID,
    'Actual' as WirtschaftseinheitsVersionID
FROM [$(vSourcePath)DS_api_Referenzwerte_WE.qvd]
(qvd)
WHERE not(isnull(ReferenzwertID));

LEFT JOIN(Referenzwerte_Aktuell)
LOAD Distinct
    [_KEY_content],
	Transaktionstyp,
    Transaktionskosten,
    NettoTransaktionspreis,
    Vertragsdatum,
    UngewoehnterFusswegrecht,
    Transaktionsmethode,
    GrundbuchamtAnmeldung,
    TransaktionsdetailTyp,
    Transaktionsmotiv,
    Zielnutzung,
    DealStruktur,
    Kaufpreis_Erstellungskosten,
    Sanierungskosten,
    KostenParkierungVerfügbar,
    KostenParkierung,
    KostenBastelraumVerfügbar,
    KostenBastelraum,
    AndereKostenVerfügbar,
    AndereKosten,
    Verkauf,
    IndexStand,
    IndexJahr
;    
// Preceding load
LOAD
	*,
    if(Transaktionstyp='Verkauf','1','0') as Verkauf
;
// Preceding load   
LOAD
	*,
    Date(Vertragsdatum) as Vertragsdatum,
    Date(GrundbuchamtAnmeldung) as GrundbuchamtAnmeldung,
    ApplyMap('MappingTransaktionstyp', Transaktionstyp, null()) as Transaktionstyp,
    ApplyMap('MappingTransaktionsdetailTyp', TransaktionsdetailTyp, null()) as TransaktionsdetailTyp,
    ApplyMap('MappingTransaktionsmotiv', Transaktionsmotiv, null()) as Transaktionsmotiv,
    ApplyMap('MappingTransaktionsmethode', Transaktionsmethode, null()) as Transaktionsmethode,
    ApplyMap('MappingZielnutzung', Zielnutzung, null()) as Zielnutzung,
    ApplyMap('MappingDealStruktur', DealStruktur, null()) as DealStruktur
FROM [$(vSourcePath)DS_api_ReferenzwerteDetails_WE.qvd]
(qvd)
WHERE not(isnull(_KEY_referenceValueDetails));


Gestaffelte_TR_Aktuell:
LOAD Distinct
	[_KEY_content],
    _KEY_referenceValueDetails,
    EinkaeuferName,
    EinkaeuferAddress,
	VerkaeuferName,
	VerkaeuferAddress,
    EinkaeuferName & ' ' & EinkaeuferAddress as EinkaeuferCombName,
    VerkaeuferName & ' ' & VerkaeuferAddress as VerkaeuferCombName
;
// Preceding load
LOAD    
    *,
    ApplyMap('Map_Stakeholders_Name', Einkaeufer, null()) as EinkaeuferName,
    ApplyMap('Map_Stakeholders_Address', Einkaeufer, null()) as EinkaeuferAddress,
    ApplyMap('Map_Stakeholders_Name', Verkaeufer, null()) as VerkaeuferName,
    ApplyMap('Map_Stakeholders_Address', Verkaeufer, null()) as VerkaeuferAddress
FROM [$(vSourcePath)DS_api_ReferenzwerteDetails_WE.qvd]
(qvd)
WHERE not(isnull(_KEY_referenceValueDetails));

If not Isnull(QvdCreateTime('$(vSourcePath)DS_api_RefWertGestaffelteTR_WE.qvd')) Then

LEFT JOIN (Gestaffelte_TR_Aktuell)
LOAD Distinct
    _KEY_referenceValueDetails,
    BemerkungGestaffelteTR,
    DatumGestaffelteTR,
    PreisGestaffelteTR,
    Erwerbsnebenkosten,
;
// Preceding load
LOAD
	*,
    Date(DatumGestaffelteTR) as DatumGestaffelteTR
FROM [$(vSourcePath)DS_api_RefWertGestaffelteTR_WE.qvd]
(qvd)
WHERE not(isnull(_KEY_referenceValueDetails));

LEFT JOIN (Gestaffelte_TR_Aktuell)
LOAD Distinct
	[_KEY_content],
    %ReferenzwertID,
    ReferenzwertTyp & ' ' & ReferenzwertDatum & ' ' & BemerkungReferenzwert as ReferenzwertGestaffelt
Resident Referenzwerte_Aktuell;
DROP FIELDS [_KEY_content], [_KEY_referenceValueDetails] FROM Referenzwerte_Aktuell;

END IF

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Referenzwerte_WE_Versionen.qvd')) Then

  // Concatenate
  Concatenate (Referenzwerte_Aktuell)
  LOAD Distinct
      *
  Resident Referenzwerte_Versionen;

  RENAME TABLE Referenzwerte_Aktuell to Referenzwerte_temp;
  DROP TABLE Referenzwerte_Versionen;


  Concatenate (Gestaffelte_TR_Aktuell)
  LOAD Distinct
      *
  Resident Gestaffelte_TR_Versionen;

  RENAME TABLE Gestaffelte_TR_Aktuell to Gestaffelte_TR_temp;
  DROP TABLE Gestaffelte_TR_Versionen;

ELSE

  RENAME TABLE Referenzwerte_Aktuell to Referenzwerte_temp;
  RENAME TABLE Gestaffelte_TR_Aktuell to Gestaffelte_TR_temp;
  
END IF

// Anpassung pfr
Referenzwerte_tmp_flag:
Load Distinct
	%WirtschaftseinheitSCDID,
    ReferenzwertTyp,
    max(ReferenzwertDatum,1) as LastDatum,
    max(ReferenzwertDatum,2) as SecondLastDatum
Resident Referenzwerte_temp
	where ReferenzwertTyp ='GVA-Wert'
    group by %WirtschaftseinheitSCDID,
    	ReferenzwertTyp;
    
left join (Referenzwerte_temp)
Load Distinct
	%WirtschaftseinheitSCDID,
    ReferenzwertTyp,
    LastDatum as ReferenzwertDatum,
    '1' as ReferenzwerteLastDatum_1
resident Referenzwerte_tmp_flag;

left join (Referenzwerte_temp)
Load Distinct
	%WirtschaftseinheitSCDID,
 	ReferenzwertTyp,
    SecondLastDatum as ReferenzwertDatum,
    '1' as ReferenzwerteSecondLastDatum_1
resident Referenzwerte_tmp_flag;

Drop table Referenzwerte_tmp_flag;


// Store QVD
Call QvdStore ('Referenzwerte_temp', '$(vStorePath)', 'RF_MD', 'Referenzwerte', '*', 1);

// Store QVD
Call QvdStore ('Gestaffelte_TR_temp', '$(vStorePath)', 'RF_MD', 'Gestaffelte_TR', '*', 1);


//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_RefWert = (now() - vStartTime_RefWert)*86400;
Trace ---------------------------------- Referenzwerte geladen ----------------------------------;
Trace $(vElapsed_RefWert);
//********************************************************************************************

///$tab 2.6 Projekte
//********************************* Start Zeitmessung *********************************
// SET vStartTime_Proj = 0;
// Set vElapsed_Proj = 0;
Let vStartTime_Proj  = now();

//*************************************************************************************

// Load Projects
Projekte_temp:
NoConcatenate
LOAD Distinct
    ProjektId as %ProjektID,
    If(Len(Trim(ReferenzPortfolioId))>0, ReferenzPortfolioId, Left(ApplyMap('Map_BewToProj', ProjektId, Null()),7)) as %PortfolioID,
//    _KEY_root,
    BemerkungProjekt,
    Standardprojekt,
    ProjektRefNr,
    ProjektRefNr2,
    ProjektGesperrt,
    ProjektAenderungsdatum,
    ProjektName,
    ProjektReleaseStatus,
    ProjektReleaseDatum,
    ProjektStatus,
    ProjektstatusAenderungsdatum,
    Date(Bewertungsstichtag) as ProjektBewertungsstichtag,
    Bewertungsgrund as ProjektBewertungsgrund
FROM [$(vSourcePath)DS_api_Projekte.qvd]
(qvd);

// Store QVD
Call QvdStore ('Projekte_temp', '$(vStorePath)', 'RF_MD', 'Projekte', '*', 1);

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_Proj = (now() - vStartTime_Proj)*86400;
Trace ---------------------------------- Projekte geladen ----------------------------------;
Trace $(vElapsed_Proj);
//********************************************************************************************
///$tab 2.7 Bewertungen
//********************************* Start Zeitmessung *********************************
// SET vStartTime_Bew = 0;
// Set vElapsed_Bew = 0;
Let vStartTime_Bew  = now();

//*************************************************************************************

// Load Bewertungen
Bew_temp:
NoConcatenate
LOAD Distinct
    BasisURL,
    BewertungURL,
	ProjektID,
//    PortfolioId as %PortfolioID,
    _KEY_root,
    BerechnungDatum,
    BewertungsID as %BewertungsID,
    %WirtschaftseinheitNr,
    %PortfolioID,
    IstMaster,
    Bewertungsmethode,
    BewertungsDateiName,
    BewertungStatus
;
// Preceding load
LOAD
	*,
    Left( BasisURL, Len( Trim( BasisURL) ) -3)&'/#/'&subfield(%WirtschaftseinheitNr,'-',1)&'/val/valuations/dcf/'&BewertungsID&'/valuation' as BewertungURL,
    ApplyMap('Map_Project_to_Bew', _KEY_root, '') as ProjektID,
    ApplyMap('Map_WE_to_Portfolio', %WirtschaftseinheitNr, '') as %PortfolioID
;
// Preceding load
LOAD
	*,
    left(BewertungsID, 7) as %WirtschaftseinheitNr
FROM [$(vSourcePath)DS_api_Root.qvd]
(qvd);


Left Join(Bew_temp)
LOAD Distinct
	%ProjektID as ProjektID,
    ProjektReleaseStatus as ReleaseStatus,
    Date(ProjektReleaseDatum) as ReleaseDatum,
    ProjektStatus
//Resident Projekte_temp;
//DROP TABLE Projekte_temp;
FROM [$(vStorePath)RF_MD-Projekte.qvd] (qvd);

LEFT JOIN(Bew_temp)
LOAD Distinct
    _KEY_root,
    _KEY_settings,
    Waehrung,
    CHF_Currency,
    Currency_CHF,
    BesichtigungDatum,
    BesichtigtDurch,
    Bewertungsstichtag,
    Transaktionskosten,
    Bewertungsgrund
;
// Preceding load
LOAD
	*,
    if (len(trim(CHF_Currency_tmp)) = 0,1, CHF_Currency_tmp) as CHF_Currency,
	if (len(trim(Currency_CHF_tmp)) = 0,1, Currency_CHF_tmp) as Currency_CHF,
	if (len(trim(Waehrung_tmp)) = 0,'CHF', Waehrung_tmp) as Waehrung
;
// Preceding load
LOAD
	*,
    Waehrung as Waehrung_tmp,
	Date(Bewertungsstichtag) as Bewertungsstichtag,
    ApplyMap('MappingBewertungsgrund', Bewertungsgrund, null()) as Bewertungsgrund,
    ApplyMap('Map_Currency', Waehrung, null()) as CHF_Currency_tmp,
    ApplyMap('Map_Inverse_Currency', Waehrung, null()) as Currency_CHF_tmp
FROM [$(vSourcePath)DS_api_Einstellungen.qvd]
(qvd);


LEFT JOIN(Bew_temp)
LOAD Distinct
	[_KEY_settings],
	Date([Teuerungsstichtag]) as Teuerungsstichtag
FROM [$(vSourcePath)DS_api_Teuerungsstichtag.qvd]
(qvd);


LEFT JOIN(Bew_temp)
LOAD Distinct
    _KEY_root,
    Parzellenflaeche,
    Marktwert100_ungerundet,
    MarktwertManuell,
    MarktwertTyp,
    Marktwert,
    MarktwertKorrektur
FROM [$(vSourcePath)DS_api_Hauptkennzahlen.qvd]
(qvd);

temp3:
LOAD Distinct
	_KEY_root,
    if(sum([Eigentumanteil])=0 or FirstValue(Eigentum) <> 'CO_OWNERSHIP',1,sum([Eigentumanteil])) as [Miteigentumsanteil],
    if(sum([Eigentumanteil])=0 or FirstValue(Eigentum) <> 'CO_OWNERSHIP',1,sum([Eigentumanteil])) as [Eigentumanteil]
FROM [$(vSourcePath)DS_api_Bewertung.qvd]
(qvd)
WHERE not(isnull(Eigentum))
GROUP BY _KEY_root;


LEFT JOIN (Bew_temp)
LOAD Distinct
    _KEY_root,
    Miteigentumsanteil,
    Eigentumanteil
Resident temp3;
DROP TABLE temp3;
    
    
LEFT JOIN (Bew_temp)
LOAD Distinct
	_KEY_root,    
    _KEY_value,
    HNF_manuell,
//    StichtagMieterspiegel,
//    Eigentumanteil,
    Bemerkungen as BewBemerkungen,
    Standardprojekt,
    DiskontierungNominalGesamt,
    DiskontierungRealGesamt,
//    Email,
    ExterneID as BewExtID,
//    Vorname,
    NoteTotalQualiprofil,
//    ID,
//    Teuerung,
//    KontoNameKonto,
//    Nachname,
    Anzeigemodus,
    Name as BewName,
    Eigentuemer as BewEigentuemer,
//    Eigentum,
//    AbrechnungEndePeriode,
//    AbrechnungStartPeriode,
//    LiegenschaftsNrKunde,
    ReferenzNrBWS,
    Bezeichnung as BewBezeichnung
//    LiegenschaftTyp,
//    AbrechnungTyp,
//    AnzahlMietobjekte,
//    Username,
//    STWEWertquoteEigentum,
//    STWEWertquoteTotal
FROM [$(vSourcePath)DS_api_Bewertung.qvd]
(qvd);

LEFT JOIN (Bew_temp)
LOAD Distinct
    _KEY_location,
    _KEY_value
FROM [$(vSourcePath)DS_api_Ort.qvd]
(qvd);

LEFT JOIN (Bew_temp)
LOAD Distinct
    _KEY_location,
    Adresse1,
    Adresse2,
    Land,
    Ort,
    Kanton,
    PLZ
FROM [$(vSourcePath)DS_api_Adresse.qvd]
(qvd);

LEFT JOIN (Bew_temp)
LOAD Distinct
    _KEY_location,
    Breitengrad,
    Laengengrad,
    GeoMakePoint(Breitengrad, Laengengrad) as Geokey
FROM [$(vSourcePath)DS_api_Koordinaten.qvd]
(qvd)
WHERE not(isnull(Breitengrad));

LEFT JOIN (Bew_temp)
LOAD Distinct
	SubField([_KEY_value],'$(vKeySep)',1) as %BewertungsID,
    DiskontierungReal,
    DiskontierungRealBerechnet, 
    if(IsNull(DiskontierungRealManuell),'CALCULATED','MANUAL') as BerechnungTyp
FROM [$(vSourcePath)DS_api_Diskontierung.qvd]
(qvd);

LEFT JOIN (Bew_temp)
LOAD Distinct
    Country as Land,
    CountryCode2 as %ContryCode2
FROM [lib://0100_Global/04_Datasource/01_qvd/CountryCodeMapping.qvd]
(qvd);


IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_GeschaetzterMarktwertVO_WE.qvd')) Then

// Add Marktwert VO
LEFT JOIN (Bew_temp)
LOAD Distinct
//	RefBewId as %BewertungsID,
	BewertungsId as %BewertungsID,
    MarktwertVO as MarktwertGeschaetzt,
    Marktwert as MarktwertAktuell,
//    Date(SchaetztungsDatum) as SchaetztungsDatum,
//    Bemerkung as Bemerkung_MWVO,
//    Date(BesichtigungDatum) as BesichtigungDatum_MWVO,
//    Date(BesichtigungDatumBewertung) as BesichtigungDatumBewertung_MWVO
	Date(Datum) as SchaetztungsDatum,
    Kommentar as Bemerkung_MWVO,
    Date(Besichtigungsdatum) as BesichtigungDatum_MWVO,
    Date(BesichtigungsdatumBewertung) as BesichtigungDatumBewertung_MWVO

FROM [$(vSourcePath)DS_api_GeschaetzterMarktwertVO_WE.qvd]
(qvd);


Bewertung_Dimension:
NoConcatenate
LOAD Distinct
//	%BewertungsID,
	%BewertungsID as BewertungsID,
    %BewertungsID as %RefBewID,
//     %WirtschaftseinheitNr as %WERefKey,
    %WirtschaftseinheitNr as WirtschaftseinheitID,
    ProjektID,
//    ProjektID as %ProjektID,
    BerechnungDatum,
    IstMaster,
    ReleaseStatus,
    ReleaseDatum,
    ProjektStatus,
    Bewertungsmethode,
    BewertungsDateiName,
    BewertungStatus,
	Waehrung,
    BesichtigungDatum,
    BesichtigtDurch,
    Transaktionskosten,
    Bewertungsstichtag,
	Bewertungsgrund,
    Teuerungsstichtag,
    HNF_manuell,
    Miteigentumsanteil,
    Eigentumanteil,
	BewBemerkungen,
    Standardprojekt,
    DiskontierungNominalGesamt,
    DiskontierungRealGesamt,
    DiskontierungReal,
    DiskontierungRealBerechnet, 
    BerechnungTyp,
	BewExtID,
    NoteTotalQualiprofil,
    Anzeigemodus,
    BewName,
    BewEigentuemer,
    ReferenzNrBWS,
    BewBezeichnung,
    Adresse1,
    Adresse2,
    Land,
    %ContryCode2,
    Ort,
    Kanton,
    PLZ,
    Breitengrad,
    Laengengrad,
    Geokey,
    BasisURL,
    BewertungURL,
    MarktwertGeschaetzt,
    MarktwertAktuell,
    SchaetztungsDatum,
    Bemerkung_MWVO,
    BesichtigungDatum_MWVO,
    BesichtigungDatumBewertung_MWVO,
    Coalesce(If(ReleaseStatus='RELEASED' and ProjektStatus='CLOSED' and IstMaster='True', '1', '0'), '0') as BewFinal
    
Resident Bew_temp;

ELSE

Bewertung_Dimension:
NoConcatenate
LOAD Distinct
//	%BewertungsID,
	%BewertungsID as BewertungsID,
    %BewertungsID as %RefBewID,
//     %WirtschaftseinheitNr as %WERefKey,
    %WirtschaftseinheitNr as WirtschaftseinheitID,
    ProjektID,
//    ProjektID as %ProjektID,
    BerechnungDatum,
    IstMaster,
    ReleaseStatus,
    ReleaseDatum,
    ProjektStatus,
    Bewertungsmethode,
    BewertungsDateiName,
    BewertungStatus,
	Waehrung,
    BesichtigungDatum,
    BesichtigtDurch,
    Transaktionskosten,
    Bewertungsstichtag,
	Bewertungsgrund,
    Teuerungsstichtag,
    HNF_manuell,
    Miteigentumsanteil,
    Eigentumanteil,
	BewBemerkungen,
    Standardprojekt,
    DiskontierungNominalGesamt,
    DiskontierungRealGesamt,
    DiskontierungReal,
    DiskontierungRealBerechnet, 
    BerechnungTyp,
	BewExtID,
    NoteTotalQualiprofil,
    Anzeigemodus,
    BewName,
    BewEigentuemer,
    ReferenzNrBWS,
    BewBezeichnung,
    Adresse1,
    Adresse2,
    Land,
    %ContryCode2,
    Ort,
    Kanton,
    PLZ,
    Breitengrad,
    Laengengrad,
    Geokey,
    BasisURL,
    BewertungURL,
//     MarktwertGeschaetzt,
//     MarktwertAktuell,
//     SchaetztungsDatum,
//     Bemerkung_MWVO,
//     BesichtigungDatum_MWVO,
//     BesichtigungDatumBewertung_MWVO,
    Coalesce(If(ReleaseStatus='RELEASED' and ProjektStatus='CLOSED' and IstMaster='True', '1', '0'), '0') as BewFinal
    
Resident Bew_temp;


END IF


// Store QVD
//temporary File
Call QvdStore ('Bew_temp', '$(vStorePath)', 'temp', 'Bew_temp', '*', 1);
// final Dimension-File
Call QvdStore ('Bewertung_Dimension', '$(vStorePath)', 'RF_MD', 'Bewertung', '*', 1);


//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_Bew = (now() - vStartTime_Bew)*86400;
Trace ---------------------------------- Bewertungen geladen ----------------------------------;
Trace $(vElapsed_Bew);
//********************************************************************************************

///$tab Ende Dimensionen 2. <<
//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_DIM = (now() - vStartTime_DIM)*86400;
Trace ---------------------------------- Dimensionen geladen ----------------------------------;
Trace $(vElapsed_DIM);
//********************************************************************************************
///$tab >> 3. Fakten
//********************************* Start Zeitmessung *********************************
// SET vStartTime_FACT = 0;
// Set vElapsed_FACT = 0;
Let vStartTime_FACT  = now();

//*************************************************************************************
///$tab > 3.1 Bewertungen/Abrechnungen
//********************************* Start Zeitmessung *********************************
// SET vStartTime_FACTBewAbr = 0;
// Set vElapsed_FACTBewAbr = 0;
Let vStartTime_FACTBewAbr  = now();

//*************************************************************************************
///$tab 3.1.1 Budget Anpassungen
//********************************* Start Zeitmessung *********************************
// SET vStartTime_BdgAnpassungen = 0;
// Set vElapsed_BdgAnpassungen = 0;
Let vStartTime_BdgAnpassungen  = now();

//*************************************************************************************

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_BudgetAnpassungen.qvd')) Then
  
  // *** Mapping
  MappingKontonameAngepasst:
  Mapping Load distinct
      ReferenzNrKonto,
      Kontoname
  FROM [$(vSourcePath)DS_api_Kontoplan.qvd]
  (qvd)
//   where Kontoplan = 'SIA';
  WHERE Match(Aktiv, 'True')>0;

  NoConcatenate
  Struktur_tmp:
  LOAD Distinct
      %PortfolioID,
      AbschlussMonatNum as AbschlussMonat
  FROM [$(vStorePath)$(vqvdPrefixMD)-Portfolios.qvd](qvd);

  Left Join(Struktur_tmp)
  LOAD Distinct
      PortfolioId,
      %WirtschaftseinheitNr
  FROM [$(vStorePath)temp-WEAktuell.qvd](qvd);

  // *** Mapping
  MappingPeriodenende:
  Mapping LOAD Distinct
      %WirtschaftseinheitNr,
      AbschlussMonat
  Resident Struktur_tmp;
  Drop table Struktur_tmp;
  
  NoConcatenate
  Abrechnungen_WE_tmp:
  LOAD
    Aktiv,
    Kontoplan,
    Kommentar,
    Waehrung,
    ReferenzNrKonto,
    Filter,
    Id,
    ImportDatum,
    Kontoname_Kunde,
    Name,
    Periodenende,
    Periodenstart,
    Status,
    Art,
    Typ,
    istReferenz,
    WirtschaftseinheitsID,
    Wert
  FROM [$(vSourcePath)DS_api_Abrechnungen_WE.qvd]
  (qvd)
  // where WirtschaftseinheitsID='106-167' // for testing
  ;

  concatenate(Abrechnungen_WE_tmp)
  LOAD
      Visum as Aktiv,
      '' as Kontoplan, 
      Kommentar,
      '' as Waehrung,
      Zielkonto as ReferenzNrKonto, //      Quellkonto as ReferenzNrKonto,
      '' as Filter,
      'BA-'& Id as Id,    
      Bearbeitungsdatum as ImportDatum,
      ApplyMap('MappingKontonameAngepasst', Zielkonto) as Kontoname_Kunde, //      ApplyMap('MappingKontoname', Quellkonto) as Kontoname_Kunde, 
      '' as Name,
//       date(MonthEnd(AddMonths(date(MakeDate(Geschäftsjahr, 		// Jahr
//       	12, // ApplyMap('MappingPeriodenende', ZielWE), 			// Monat -> at the momennt only KalendarJahr
//         1)),0)),'YYYY-MM-DD') as Periodenende,
//       date(MonthStart(AddMonths(date(MakeDate(Geschäftsjahr,  	// Jahr
//       	1, //ApplyMap('MappingPeriodenende', ZielWE),			// Monat -> at the momennt only KalendarJahr
//         1)),0) //-11)											// Tag
//         ),'YYYY-MM-DD') as Periodenstart,
      date(MakeDate(Geschäftsjahr,12,31),'YYYY-MM-DD') as Periodenende,
      date(MakeDate(Geschäftsjahr,1,1),'YYYY-MM-DD') as Periodenstart,  
      Status,
      '' as Art,
      Typ,
      '' as istReferenz,
      ZielWE as WirtschaftseinheitsID,   // QuellWE as WirtschaftseinheitsID,
      Zielbetrag as Wert // Quellbetrag as Wert    
  FROM [$(vSourcePath)DS_api_BudgetAnpassungen.qvd]
  (qvd);

  concatenate(Abrechnungen_WE_tmp)
  LOAD
      Visum as Aktiv,
      '' as Kontoplan, 
      Kommentar,
      '' as Waehrung,
      Quellkonto as ReferenzNrKonto,  
      '' as Filter,
      'BA-'& Id as Id,     
      Bearbeitungsdatum as ImportDatum,
      ApplyMap('MappingKontonameAngepasst', Quellkonto) as Kontoname_Kunde,
      '' as Name,
//       date(MonthEnd(AddMonths(date(MakeDate(Geschäftsjahr, 		// Jahr
//       	12, //ApplyMap('MappingPeriodenende', ZielWE), 	// Monat -> at the momennt only KalendarJahr
//         1)),0)),'YYYY-MM-DD') as Periodenende,
//       date(MonthStart(AddMonths(date(MakeDate(Geschäftsjahr,  	// Jahr
//       	1, // ApplyMap('MappingPeriodenende', ZielWE),			// Monat -> at the momennt only KalendarJahr
//         1)),0) //-11)											// Tag
//         ),'YYYY-MM-DD') as Periodenstart,
      date(MakeDate(Geschäftsjahr,12,31),'YYYY-MM-DD') as Periodenende,
      date(MakeDate(Geschäftsjahr,1,1),'YYYY-MM-DD') as Periodenstart,  
      Status,
      '' as Art,
      Typ,
      '' as istReferenz,
      QuellWE as WirtschaftseinheitsID,
      Quellbetrag as Wert
  FROM [$(vSourcePath)DS_api_BudgetAnpassungen.qvd]
  (qvd)
  where Typ ='COMPENSATION';

//   LET vLoadTable = TableName(0);
//   Store $(vLoadTable) Into [lib://$(vModule)/03_Refinement\01_qvd\$(vqvdPrefixMD)_$(vLoadTable).qvd](qvd);
//   Drop Table $(vLoadTable);


  Set vAbrechnungenTable = 'Resident Abrechnungen_WE_tmp';
  
  else
  
  Set vAbrechnungenTable = 'FROM [$(vSourcePath)DS_api_Abrechnungen_WE.qvd](qvd)';

end if


//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_BdgAnpassungen = (now() - vStartTime_BdgAnpassungen)*86400;
Trace ---------------------------------- BdgAnpassungen geladen ----------------------------------;
Trace $(vElapsed_BdgAnpassungen);
//********************************************************************************************



///$tab 3.1.2 Abrechnungen / Budget
//********************************* Start Zeitmessung *********************************
// SET vStartTime_Abr = 0;
// Set vElapsed_Abr = 0;
Let vStartTime_Abr  = now();

//*************************************************************************************

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Abrechnungen_WE.qvd')) Then

AbrBdg_temp:
NoConcatenate
LOAD Distinct
	Aktiv,
    Kontoplan,
    Kommentar,
    ReferenzNrKonto_temp as ReferenzNrKonto,
    Kontolevel,
    Faktor,
    Filter,
    Id as %AbrechnungBudgetID,
    ImportDatum,
    Kontoname_Kunde,
    Name,
    PeriodenStart,
    PeriodenEnde,
    Status,
    Art,
    Typ,
    TypNum,
    istReferenz,
    WirtschaftseinheitsID as %WirtschaftseinheitNr,
    %PortfolioID,
    if (len(trim(CHF_Currency_tmp)) = 0,1, CHF_Currency_tmp) as CHF_Currency,
	if (len(trim(Currency_CHF_tmp)) = 0,1, Currency_CHF_tmp) as Currency_CHF,
	if (len(trim(Waehrung_tmp)) = 0,'CHF', Waehrung_tmp) as Waehrung,
    Wert_temp as Wert,
    AbrechnungsJahr,
    JahrMonat,
    Left(Id,7) &'-'&ReferenzNrKonto_temp&'-'&TypNum&'-'&JahrMonat as %SumKey,
    Left(Id,7) &'-'&ReferenzNrKonto_temp&'-'&TypNum as %CalcKey,
    $(vMonthDiff(PeriodenStart, PeriodenEnde)) as AnzahlMonate
 WHERE (Match(Kontolevel, '4')>0 AND Left(ReferenzNrKonto_temp, 1)='6') OR (Match(Kontolevel, '3')>0 AND Left(ReferenzNrKonto_temp, 1)<>'6')
;
//Preceding load
LOAD Distinct
	*,
    ApplyMap('Map_AbrBdgTyp', Typ, '3') as TypNum,
    ApplyMap('Map_WE_to_Portfolio', WirtschaftseinheitsID, null()) as %PortfolioID,
    ApplyMap('Map_AccountLevel', ReferenzNrKonto, Null()) as Kontolevel,
    If(Match(Left(ReferenzNrKonto,1), '1', '4')>0, -1, 1) as Faktor,
    Waehrung as Waehrung_tmp,
    If(IsNull(Wert), 0, Wert) as Wert_temp,
    ApplyMap('Map_Currency', Waehrung, null()) as CHF_Currency_tmp,
    ApplyMap('Map_Inverse_Currency', Waehrung, null()) as Currency_CHF_tmp,
    Date(ImportDatum) as ImportDatum,
    Date(Periodenstart) as PeriodenStart,
    Date(Periodenende) as PeriodenEnde,
    Year(Date(Periodenende)) as AbrechnungsJahr,
    Dual(Year(Periodenstart) & '-'& Num(Month(Periodenstart)), Year(Periodenstart) & Num(Month(Periodenstart), '00')) as JahrMonat,
//    Dual(Month(Periodenstart) & '-' & Year(Periodenstart), Year(Periodenstart) & Num(Month(Periodenstart), '00')) as MonatJahr,
    if(WildMatch(ReferenzNrKonto, '*Moved*'),left(ReferenzNrKonto,5), ReferenzNrKonto) as ReferenzNrKonto_temp    // are 13/01/22: Text vom tiefsten Kontolevel zu entfernen

// FROM [$(vSourcePath)DS_api_Abrechnungen_WE.qvd]
// (qvd)
$(vAbrechnungenTable) // tpl: fehler ignorieren
WHERE Status<>'IMPORTED' AND Len(Trim(Id))>0;

IF NOT ISNULL(TableNumber('Abrechnungen_WE_tmp')) THEN
	Let vNoRowsDropTable=NoOfRows('Abrechnungen_WE_tmp');
    TRACE DROP EMPTY TABLE: DROP Table 'Abrechnungen_WE_tmp'  CONTAINS: $(vNoRowsDropTable) Rows ;
    DROP Table 'Abrechnungen_WE_tmp';
ENDIF

// Calculating Differences for the Balance Sheet Accounts
temp4:
LOAD
	Min(AbrechnungsJahr) as MinAbrJahr
Resident AbrBdg_temp;

LET vMinAbrJahr = Peek('MinAbrJahr', 0, 'temp4');
DROP TABLE temp4;

   
AbrBdg_WertDiff:
NoConcatenate
LOAD Distinct
	%SumKey,
    %CalcKey,
    If(%CalcKey=Previous(%CalcKey), Wert-Previous(Wert),Wert) as WertDiff

Resident AbrBdg_temp
WHERE left(ReferenzNrKonto, 1) = '1'
ORDER BY %SumKey Asc;

Concatenate(AbrBdg_WertDiff)
LOAD Distinct
	%SumKey,
    %CalcKey,
    Wert as WertDiff

Resident AbrBdg_temp
WHERE left(ReferenzNrKonto, 1) <> '1'
ORDER BY %SumKey Asc;

INNER JOIN (AbrBdg_temp)
LOAD Distinct
	%SumKey,
    Sum(WertDiff) as WertDiff_temp
Resident AbrBdg_WertDiff
GROUP BY %SumKey;
DROP TABLE AbrBdg_WertDiff;


// Calculating monthly balances

AbrBdg_temp_LongerThanaMonth:
NoConcatenate
LOAD Distinct
	%AbrechnungBudgetID,
    Kontoplan,
    ReferenzNrKonto,
    Kontoname_Kunde,
    AnzahlMonate, 
    %WirtschaftseinheitNr,
    %PortfolioID,
    PeriodenStart,
    PeriodenEnde,    
    WertDiff_temp as Wert,    
    Waehrung,
    CHF_Currency,
	Currency_CHF,    
    Typ,    
    TypNum,
    Art,
    istReferenz,
    Status,    
    Aktiv,
    Kommentar,   
    Filter,
    ImportDatum, 
    Name,
	%SumKey,
    AbrechnungsJahr,
    JahrMonat,   
    Date(AddMonths(PeriodenStart, IterNo()-1)) as NewPeriodenStart,
    Date(Floor(MonthEnd(Date(AddMonths(PeriodenStart, IterNo()-1))))) as NewPeriodenEnde,
    If(IsNull(WertDiff_temp),0,WertDiff_temp/AnzahlMonate) as newWert,
    Kontolevel,
    Faktor

Resident AbrBdg_temp
While AddMonths(PeriodenStart , IterNo() - 1) <= PeriodenEnde AND AnzahlMonate > 1
;


AbrBdg_temp_Month:
NoConcatenate
LOAD Distinct
	%AbrechnungBudgetID,
    Kontoplan,
    ReferenzNrKonto,
    Kontoname_Kunde,
    AnzahlMonate,
    %WirtschaftseinheitNr,
    %PortfolioID,
    PeriodenStart,
    PeriodenEnde,
    WertDiff_temp as Wert,
    Waehrung,
    CHF_Currency,
    Currency_CHF,
    Typ,
    TypNum,
    Art,
    istReferenz,
    Status,
    Aktiv,
    Kommentar,
    Filter,
    ImportDatum,
    Name,
    %SumKey,
    AbrechnungsJahr,
    JahrMonat,
    Kontolevel,
    Faktor
Resident AbrBdg_temp
WHERE AnzahlMonate = 1;
DROP TABLE AbrBdg_temp;

Concatenate(AbrBdg_temp_Month)
LOAD Distinct
	%AbrechnungBudgetID,
    Kontoplan,
    ReferenzNrKonto,
    Kontoname_Kunde,
    AnzahlMonate,
    %WirtschaftseinheitNr,
    %PortfolioID,
    NewPeriodenStart as PeriodenStart,
    NewPeriodenEnde as PeriodenEnde,
    newWert as Wert,
    Waehrung,
    CHF_Currency,
    Currency_CHF,    
    Typ,
    Art,
    istReferenz,
    Status,
    Aktiv,
    Kommentar,
    Filter,
    ImportDatum,
    Name,
    %SumKey,
    AbrechnungsJahr,
    JahrMonat,
    Kontolevel,
    Faktor
Resident AbrBdg_temp_LongerThanaMonth;
DROP TABLE AbrBdg_temp_LongerThanaMonth;

// Specify the AsOfDate for the Expenses / Budget (one Period Start per ID)
temp5:
LOAD Distinct
    %AbrechnungBudgetID,
    Date(Min(PeriodenStart)) as MinPeriodStart,
    Date(Max(PeriodenEnde)) as MaxPeriodEnd
Resident AbrBdg_temp_Month
GROUP BY %AbrechnungBudgetID;

LEFT JOIN (AbrBdg_temp_Month)
LOAD Distinct
	%AbrechnungBudgetID,
    MinPeriodStart,
    MaxPeriodEnd
Resident temp5;
DROP TABLE temp5;

// Final Expense / Budget Table with new Key (containing the Month)
AbrechnungBudget_temp:
NoConcatenate
LOAD Distinct
	%AbrechnungBudgetID & '$(vKeySep)' & JahrMonat as AbrechnungBudgetKey,
    %AbrechnungBudgetID as AbrechnungBudgetID,
// 	AbrechnungBudgetID,
    Kontoplan,
    ReferenzNrKonto,
    Kontoname_Kunde,
    AnzahlMonate,
    %WirtschaftseinheitNr,
//     PortfolioID,
    %PortfolioID as PortfolioID,
    PeriodenStart,
    PeriodenEnde,
    MinPeriodStart,
    MaxPeriodEnd,
    Wert,
    Waehrung,
    CHF_Currency,
    Currency_CHF,    
    Typ,
    Art,
    istReferenz,
    Status,
    Aktiv,
    Kommentar,
    Filter,
    ImportDatum,
    Name,
    %SumKey as SumKey,
    AbrechnungsJahr,
    JahrMonat,
    Kontolevel,
    Faktor
// ;
// // Preceding load
// LOAD
// 	*,
//     Dual(Year(PeriodenEnde)& '-' &Month(PeriodenEnde), Year(PeriodenEnde) & Num(Month(PeriodenEnde), '00')) as MonthYear
Resident AbrBdg_temp_Month;
DROP TABLE AbrBdg_temp_Month;

// // Link back the Konto-Hierarchy to the Abrechnungen Fact-Table
// LEFT JOIN (AbrechnungBudget_temp)
// LOAD Distinct
// 	%ReferenzNrKonto as ReferenzNrKonto,
//     UeberKonto,
//     UeberKontoName,
//     ParentKonto,
//     ParentKontoName,
//     ParentOfParentKonto,
//     ParentofParentName,
//     KeyFiguresKontoName,
//     KeyFiguresFaktor,
//     KeyFiguresSort,
//     Kontolevel,
//     Konto_SIA,
//     Konto_VermgsRechn,
//     Faktor
// //Resident Kontostruktur_Custom_temp;
// FROM [$(vStorePath)RF_TR-KontostrukturCustom.qvd] (qvd);


// // Dimension to the Expenses / Budget
// AbrechnungenBudget_Dimension:
// NoConcatenate
// LOAD Distinct
// 	%AbrechnungBudgetID,
//     Aktiv,
//     Kommentar,
//     Filter,
//     ImportDatum,
//     Name,
//     MinPeriodStart,
//     MaxPeriodEnd,
//     AnzahlMonate,
//     Waehrung,
//     Status,
//     Art,
//     Typ,
//     istReferenz
// Resident AbrechnungBudget_temp;

// Store QVD
//temporary File
 Call QvdStore ('AbrechnungBudget_temp', '$(vStorePath)', 'temp', 'AbrechnungBudget_temp', '*', 1);
// // final Dimension-File
// Call QvdStore ('AbrechnungenBudget_Dimension', '$(vStorePath)', 'RF_MD', 'AbrechnungenBudget', '*', 1); are: not needed anymore
//Call QvdStore ('AbrechnungBudget_temp', '$(vStorePath)', 'RF_MD', 'AbrechnungenBudget', '*', 1); are: not needed anymore


END IF

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_Abr = (now() - vStartTime_Abr)*86400;
Trace ---------------------------------- Abrechnungen geladen ----------------------------------;
Trace $(vElapsed_Abr);
//********************************************************************************************
///$tab 3.1.3 Einzelbuchungen
//********************************* Start Zeitmessung *********************************
// SET vStartTime_Buchungen = 0;
// Set vElapsed_Buchungen = 0;
Let vStartTime_Buchungen  = now();

//*************************************************************************************

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Einzelbuchungen.qvd')) Then

Einzelbuchungen_temp:
NoConcatenate
LOAD Distinct
    BuchungRefPFId as %PortfolioID,
//  Coalesce(BuchungRefPFId, BuchungsRefPF) as %PortfolioID,
    BuchungsRefWE as %WirtschaftseinheitNr,
    BuchungsRefCDP as BauprojekteID,
    BuchungsRefDIV as DivisionID,
    BuchungsId as %BuchungsID,
    %BuchungKey,
    %DateKeyBuchung,
    BuchungsDatum_temp as AsOfDate,
    BuchungsKonto as %BuchungKontoKey,
    'Einzelbuchung' as FaktenTyp,
    'Einzelbuchung' as SubTyp,
    BuchungsKonto as Konto,
	BuchungsBetrag,
    BuchungsBetrag_woFaktor,
    Waehrung,
    CHF_Currency,
    JahrMonat,
    SubField(JahrMonat,'-',1)&' - Q' & Ceil(SubField(JahrMonat,'-',2)/3) as JahrQuartal, // tpl
    BuchungValidFrom,
    BuchungValidTo,
    BuchungsKommentar,
    BuchungsDatum_temp as BuchungsDatum,
    BuchungsExterneId,
	Currency_CHF,
    Faktor,
    Kontolevel
//    _KEY_content,
//    _KEY_root
 WHERE (Match(Kontolevel, '4')>0 AND Left(BuchungsKonto, 1)='6') OR (Match(Kontolevel, '3')>0 AND Left(BuchungsKonto, 1)<>'6')
;
// Preceding load
LOAD Distinct
	*,
    num(Wert_temp)*CHF_Currency*Faktor as BuchungsBetrag,
    Wert_temp as BuchungsBetrag_woFaktor,
    Date(YearStart(BuchungsDatum_temp)) as BuchungValidFrom,
    Date(YearEnd(BuchungsDatum_temp)) as BuchungValidTo
;
// Preceding load
LOAD Distinct
	*,
    if (len(trim(CHF_Currency_tmp)) = 0,1, CHF_Currency_tmp) as CHF_Currency,
	if (len(trim(Currency_CHF_tmp)) = 0,1, Currency_CHF_tmp) as Currency_CHF,
	if (len(trim(Waehrung_tmp)) = 0,'CHF', Waehrung_tmp) as Waehrung,
    If(Len(Trim(BuchungRefPFId))>0, BuchungRefPFId, 'All') & '$(vKeySep)' & BuchungsRefWE & '$(vKeySep)' & BuchungsId & '$(vKeySep)' & 'All' & '$(vKeySep)' & JahrMonat & '$(vKeySep)' & %DateKeyBuchung as %BuchungKey
;
// Preceding load
LOAD Distinct
	*,
    ApplyMap('Map_WE_to_Portfolio', BuchungsRefWE, null()) as BuchungRefPFId,
    Date(BuchungsDatum) as BuchungsDatum_temp,
    Floor(Date(BuchungsDatum)) as %DateKeyBuchung,
	Dual(Year(BuchungsDatum)& '-' &Num(Month(BuchungsDatum), '00'), Year(BuchungsDatum) & Num(Month(BuchungsDatum), '00')) as JahrMonat,
    BuchungsWaehrung as Waehrung_tmp,
    If(IsNull(BuchungsBetrag), 0, BuchungsBetrag) as Wert_temp,
    ApplyMap('Map_Currency', BuchungsWaehrung, null()) as CHF_Currency_tmp,
    ApplyMap('Map_Inverse_Currency', BuchungsWaehrung, null()) as Currency_CHF_tmp,
    ApplyMap('Map_AccountLevel', BuchungsKonto, Null()) as Kontolevel,
    If(Match(Left(BuchungsKonto,1), '1', '4')>0, -1, 1) as Faktor
    
FROM [$(vSourcePath)DS_api_Einzelbuchungen.qvd]
(qvd);



// LEFT JOIN (Einzelbuchungen_temp)
// LOAD Distinct
//     %ReferenzNrKonto as Konto,
// 	UeberKonto,
//     ParentKonto,
//     ParentOfParentKonto as ElternKontoTop,
//     Kontolevel,
//     KeyFiguresKontoName,
//     KeyFiguresFaktor,
//     KeyFiguresSort
// FROM [$(vStorePath)RF_TR-KontostrukturCustom.QVD] (qvd);

// // Dimension to the Expenses / Budget
// Einzelbuchungen_Dimension:
// NoConcatenate
// LOAD Distinct
//     %BuchungsID,
//     Konto,
//     Waehrung,
//     CHF_Currency,
//     BuchungsKommentar,
// 	BuchungsDatum,
//     BuchungsExterneId,
// 	Currency_CHF,
//     Faktor
// Resident Einzelbuchungen_temp;

// Store QVD
//temporary File
Call QvdStore ('Einzelbuchungen_temp', '$(vStorePath)', 'temp', 'Einzelbuchungen_temp', '*', 1);
// // final Dimension-File
// Call QvdStore ('Einzelbuchungen_Dimension', '$(vStorePath)', 'RF_MD', 'Einzelbuchungen', '*', 1);

END IF

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_Buchungen = (now() - vStartTime_Buchungen)*86400;
Trace ---------------------------------- Einzelbuchungen geladen ----------------------------------;
Trace $(vElapsed_Buchungen);
//********************************************************************************************
///$tab 3.1.4 Liegenschaftswerte
//********************************* Start Zeitmessung *********************************
// SET vStartTime_Liegenschaftswerte = 0;
// Set vElapsed_Liegenschaftswerte = 0;
Let vStartTime_Liegenschaftswerte  = now();

//*************************************************************************************

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Liegenschaftswerte.qvd')) Then


for each vAbrBdgField in 'LSWAbrechnung','LSWBudget','LSWBuchung','LSWDiffAbrBdg','LSWDiffBuchBdg'

Liegenschaftswerte_temp:
LOAD Distinct
    LSWRefPFId as %PortfolioID,
//  Coalesce(BuchungRefPFId, BuchungsRefPF) as %PortfolioID,
    LSWRefWE as %WirtschaftseinheitNr,
    LSWId as %LSWID,
    %LSWKey,
    %DateKeyLSW,
    LSWDatum_temp as AsOfDate,
  //  LSWKonto as %LSWKontoKey,
    If(Len(Trim(LSWKontoNum))>0, LSWKontoNum, LSWKontoTechName) as %LSWKontoKey,  //are: KKV and OR do not have ExternalID (Account number, only Technical Name)
    'Liegenschaftswerte' as FaktenTyp,
	'$(vAbrBdgField)' as SubTyp,
 //   LSWKonto as Konto,
    If(Len(Trim(LSWKontoNum))>0, LSWKontoNum, LSWKontoTechName) as Konto,   //are: KKV and OR do not have ExternalID (Account number, only Technical Name)
    LSWKontoTechName,
	LSWBetrag,
    LSWBetrag_woFaktor,
    Waehrung,
    CHF_Currency,
    JahrMonat,
    SubField(JahrMonat,'-',1)&' - Q' & Ceil(SubField(JahrMonat,'-',2)/3) as JahrQuartal, // tpl
//     LSWValidFrom as LSWValidFrom_tmp,
//     LSWValidTo as LSWValidTo_tmp,
    LSWDatum_temp, // as LSWDatum,
	Currency_CHF,
    Faktor,
    Kontolevel,
    Kontolevel_orig,
    KontoTyp
 WHERE NOT Match(Kontolevel, '0')>0
;
// Preceding load
LOAD Distinct
	*,
    num(Wert_temp)*CHF_Currency*Faktor as LSWBetrag,
    Wert_temp as LSWBetrag_woFaktor
                  // ****** NOTE
                  // ****** They are YTD, so they are valid inside a January-December range, but multiple version inside a year can exist
                  // ****** Valid FROM is always YearStart -> must be recalculated based on previous version
                  // ****** Valid TO is EndDatum YearEnd
                  // ******
//     Date(YearStart(LSWDatum_temp)) as LSWValidFrom,  
//     Date(YearEnd(LSWDatum_temp)) as LSWValidTo
;
// Preceding load
LOAD Distinct
	*,
    ApplyMap('Map_CombSIAToType', LSWKontoTechName, Null()) as KontoTyp,
//    ApplyMap('Map_AccountLevelSIA', LSWKonto, Null()) as Kontolevel,
	ApplyMap('Map_CombSIAToLevel_mod', LSWKontoTechName, Null()) as Kontolevel,   //are: KKV and OR do not have ExternalID (Account number, only Technical Name)
    ApplyMap('Map_CombSIAToLevel_orig', LSWKontoTechName, Null()) as Kontolevel_orig,
//    If(Match(ApplyMap('Map_AccountFaktorStandard', LSWKonto, Null()), 'COSTS')>0, -1, 1) as Faktor,
	If(Match(ApplyMap('Map_CombSIAToGroup', LSWKontoTechName, Null()), 'COSTS')>0, -1, 1) as Faktor,   //are: KKV and OR do not have ExternalID (Account number, only Technical Name)
    if (len(trim(CHF_Currency_tmp)) = 0,1, CHF_Currency_tmp) as CHF_Currency,
	if (len(trim(Currency_CHF_tmp)) = 0,1, Currency_CHF_tmp) as Currency_CHF,
	if (len(trim(Waehrung_tmp)) = 0,'CHF', Waehrung_tmp) as Waehrung,
    If(Len(Trim(LSWRefPFId))>0, LSWRefPFId, 'All') & '$(vKeySep)' & LSWRefWE & '$(vKeySep)' & LSWId & '$(vKeySep)' & 'All' & '$(vKeySep)' & JahrMonat & '$(vKeySep)' & %DateKeyLSW as %LSWKey
;
// Preceding load
LOAD Distinct
	*,
//    ApplyMap('Map_WE_to_Portfolio', subfield(LSWRefWE,'/',-1), null()) as LSWRefPFId,
//    subfield(LSWRefWE,'/',-1) as LSWRefWE,
	WirtschaftseinheitsID as LSWRefWE,
    ApplyMap('Map_WE_to_Portfolio', WirtschaftseinheitsID, null()) as LSWRefPFId,
    Date(LSWDatum) as LSWDatum_temp,
    Floor(Date(LSWDatum)) as %DateKeyLSW,
	Dual(Year(LSWDatum)& '-' &Num(Month(LSWDatum), '00'), Year(LSWDatum) & Num(Month(LSWDatum), '00')) as JahrMonat,
    'CHF' as Waehrung_tmp,
    If(IsNull($(vAbrBdgField)), 0, $(vAbrBdgField)) as Wert_temp,
    '1' as CHF_Currency_tmp,
    '1' as Currency_CHF_tmp,   
    ApplyMap('Map_Kontobaum', LSWKonto) as LSWKontoNum,
    LSWKonto as LSWKontoTechName
    
FROM [$(vSourcePath)DS_api_Liegenschaftswerte.qvd]
(qvd);

next vAbrBdgField

NoConcatenate
Liegenschaftswerte_temp1:
LOAD Distinct
	%PortfolioID,
    %LSWID,
	LSWDatum_temp
Resident Liegenschaftswerte_temp
ORDER BY %PortfolioID, 
	%LSWID,
	LSWDatum_temp ASC
;

MinDateLSWerte:
Mapping LOAD
	%PortfolioID,
    Date(Floor(Min(LSWDatum_temp))) as MinDateLSW

Resident Liegenschaftswerte_temp1
GROUP BY %PortfolioID;

// drop table Liegenschaftswerte_temp;


NoConcatenate
Liegenschaftswerte_temp2:
LOAD Distinct
	%PortfolioID,
    %LSWID,
    NewStartDate as LSWValidFrom,
    LSWDatum_temp as LSWValidTo,
    LSWDatum_temp,
    Num(LSWDatum_temp) as NumDate,
    ApplyMap('MinDateLSWerte', %PortfolioID) as MinDateLSW,
    Num(Floor(ApplyMap('MinDateLSWerte', %PortfolioID))) as NumMinDateLSW,
;
// Preceding load
LOAD
	*,
    Date(
     If(%PortfolioID = Previous(%PortfolioID), 
      If(Num(LSWDatum_temp) > Num(Floor(ApplyMap('MinDateLSWerte', %PortfolioID))), 
       If(LSWDatum_temp <= Previous(LSWDatum_temp), MonthStart(Previous(LSWDatum_temp)), Previous(LSWDatum_temp)+1),
      YearStart(LSWDatum_temp)), YearStart(LSWDatum_temp)))
     as NewStartDate


Resident Liegenschaftswerte_temp1
ORDER BY %PortfolioID, LSWDatum_temp ASC;
DROP TABLE Liegenschaftswerte_temp1;

// Join Back the From/To Dates
LEFT JOIN (Liegenschaftswerte_temp)
LOAD Distinct
	%PortfolioID,
    %LSWID,
    LSWValidFrom,
    LSWValidTo

Resident Liegenschaftswerte_temp2;
DROP TABLE Liegenschaftswerte_temp2;


 
//      Date(
//      	If(MietvertragID = Previous(MietvertragID), 
//      		If(	StartDatum_temp = Previous(StartDatum_temp), 
//             	StartDatum_temp, 
//             	Previous(StartDatum_temp)-1
//             ), 
//       		If(	YearEnd($(vCurrentDate))<StartDatum_temp, 
//             	YearEnd(AddYears(StartDatum_temp, 5)), 
//                 YearEnd(AddYears($(vCurrentDate),5))
//             )
//         )
//      )
   
// NoConcatenate
// Liegenschaftswerte_temp1:
// LOAD Distinct
// 	%WirtschaftseinheitNr,
//     %LSWID,
// 	LSWDatum_temp
// Resident Liegenschaftswerte_temp
// ORDER BY %WirtschaftseinheitNr, 
// 	%LSWID,
// 	LSWDatum_temp ASC
// ;


// //drop table Liegenschaftswerte_temp;

// // Valid FROM
// NoConcatenate
// Liegenschaftswerte_temp2:
// LOAD Distinct
// 	%WirtschaftseinheitNr,
//     %LSWID,
    
// //     Date(YearStart(LSWDatum_temp)) as LSWValidFrom,  
// //     Date(
// //     	If(	rowno()=1 ,
// //         	Date(YearStart(LSWDatum_temp)),
// //         	Previous(LSWDatum_temp)+1)
// //         )
// 	LSWDatum_temp as LSWValidTo,
// // 	If(	rowno()=1 ,
// //     	Date(YearStart(LSWDatum_temp)),
//       if(%WirtschaftseinheitNr=previous(%WirtschaftseinheitNr),      
//           Date(rangemax(previous(LSWDatum_temp)+1,YearStart(LSWDatum_temp))),
//           Date(YearStart(LSWDatum_temp))
// //           )
//           ) as LSWValidFrom
//         ,
//    	previous(%WirtschaftseinheitNr) as Previous%WirtschaftseinheitNr
    
// Resident Liegenschaftswerte_temp1
// // FOR TESTING
// // where %WirtschaftseinheitNr ='106-167'
// ORDER BY %WirtschaftseinheitNr,
// // 	%LSWID, 
// 	LSWDatum_temp ASC
// ;
// drop table Liegenschaftswerte_temp1;

// //zum testen
// left join(Liegenschaftswerte_temp)
// Load Distinct
// 	%WirtschaftseinheitNr,
//     %LSWID,
//     LSWValidTo,
//     LSWValidFrom
// resident Liegenschaftswerte_temp2;

// drop table Liegenschaftswerte_temp2;



// Date(If(MietobjektID = Previous(MietobjektID), If(StartDatum_temp = Previous(StartDatum_temp), StartDatum_temp, Previous(StartDatum_temp)-1), 

// Store QVD
//temporary File
 Call QvdStore ('Liegenschaftswerte_temp', '$(vStorePath)', 'temp', 'Liegenschaftswerte_temp', '*', 1);


endif
    

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_Liegenschaftswerte = (now() - vStartTime_Liegenschaftswerte)*86400;
Trace ----------------------------- Liegenschaftswerte geladen ------------------------------;
Trace $(vElapsed_Liegenschaftswerte);
//********************************************************************************************
///$tab 3.1.5 FinanzwertePF
//********************************* Start Zeitmessung *********************************
// SET vStartTime_FinanzwertePF = 0;
// Set vElapsed_FinanzwertePF = 0;
Let vStartTime_FinanzwertePF  = now();

//*************************************************************************************

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_FinanzwertePF.qvd')) Then


FOR EACH vPFAbrBdgField IN 'FWAbrechnung','FWBudget','FWBuchung','FWDiffAbrBdg','FWDiffBuchBdg'

FinanzwertePF_temp:
LOAD Distinct
//	SubField(link_portfolio, '/', -1) as %PortfolioID,
	PortfolioId as %PortfolioID,
    FWId as %FWID,
    %FWKey,
    %DateKeyFW,
    FWDatum_temp as AsOfDate,
    If(Len(Trim(FWKontoNum))>0, FWKontoNum, FWKontoTechName) as %FWKontoKey,
    'PF_Finanzwerte' as FaktenTyp,
	'$(vPFAbrBdgField)' as SubTyp,
    If(Len(Trim(FWKontoNum))>0, FWKontoNum, FWKontoTechName) as Konto,
    FWKontoTechName,
	FWBetrag,
    FWBetrag_woFaktor,
    Waehrung,
    CHF_Currency,
    JahrMonat,
    SubField(JahrMonat,'-',1)&' - Q' & Ceil(SubField(JahrMonat,'-',2)/3) as JahrQuartal, // tpl
    FWDatum_temp, // as FWDatum,
	Currency_CHF,
    Faktor,
    Kontolevel,
    Kontolevel_orig,
    KontoTyp
 WHERE NOT Match(Kontolevel, '0')>0
;
// Preceding load
LOAD Distinct
	*,
    num(Wert_temp)*CHF_Currency*Faktor as FWBetrag,
    Wert_temp as FWBetrag_woFaktor
                  // ****** NOTE
                  // ****** They are YTD, so they are valid inside a January-December range, but multiple version inside a year can exist
                  // ****** Valid FROM is always YearStart -> must be recalculated based on previous version
                  // ****** Valid TO is EndDatum YearEnd
                  // ******
//     Date(YearStart(FWDatum_temp)) as FWValidFrom,  
//     Date(YearEnd(FWDatum_temp)) as FWValidTo
;
// Preceding load
LOAD Distinct
	*,
    ApplyMap('Map_CombSIAToType', FWKontoTechName, Null()) as KontoTyp,
//    ApplyMap('Map_AccountLevelSIA', FWKonto_temp, Null()) as Kontolevel,
	ApplyMap('Map_CombSIAToLevel_mod', FWKontoTechName, Null()) as Kontolevel,   //are: KKV and OR do not have ExternalID (Account number, only Technical Name)
    ApplyMap('Map_CombSIAToLevel_orig', FWKontoTechName, Null()) as Kontolevel_orig,
//    If(Match(ApplyMap('Map_AccountFaktorStandard', FWKonto_temp, Null()), 'COSTS')>0, -1, 1) as Faktor,
	If(Match(ApplyMap('Map_CombSIAToGroup', FWKontoTechName, Null()), 'COSTS')>0, -1, 1) as Faktor,   //are: KKV and OR do not have ExternalID (Account number, only Technical Name)
    if (len(trim(CHF_Currency_tmp)) = 0,1, CHF_Currency_tmp) as CHF_Currency,
	if (len(trim(Currency_CHF_tmp)) = 0,1, Currency_CHF_tmp) as Currency_CHF,
	if (len(trim(Waehrung_tmp)) = 0,'CHF', Waehrung_tmp) as Waehrung,
    If(Len(Trim(FWRefPFId))>0, FWRefPFId, 'All') & '$(vKeySep)' & 'All' & '$(vKeySep)' & FWId & '$(vKeySep)' & 'All' & '$(vKeySep)' & JahrMonat & '$(vKeySep)' & %DateKeyFW as %FWKey
;
// Preceding load
LOAD Distinct
	*,
//    SubField(link_portfolio, '/', -1) as FWRefPFId,
	PortfolioId as FWRefPFId,
    Date(FWDatum) as FWDatum_temp,
    Floor(Date(FWDatum)) as %DateKeyFW,
	Dual(Year(FWDatum)& '-' &Num(Month(FWDatum), '00'), Year(FWDatum) & Num(Month(FWDatum), '00')) as JahrMonat,
    'CHF' as Waehrung_tmp,
    If(IsNull($(vPFAbrBdgField)), 0, $(vPFAbrBdgField)) as Wert_temp,
    '1' as CHF_Currency_tmp,
    '1' as Currency_CHF_tmp,   
    ApplyMap('Map_Kontobaum', FWKonto, Null()) as FWKontoNum,
    FWKonto as FWKontoTechName
    
FROM [$(vSourcePath)DS_api_FinanzwertePF.qvd]
(qvd);


next vPFAbrBdgField

NoConcatenate
FinanzwertePF_temp1:
LOAD Distinct
	%PortfolioID,
    %FWID,
	FWDatum_temp
Resident FinanzwertePF_temp
ORDER BY %PortfolioID, 
	%FWID,
	FWDatum_temp ASC
;

MinDateFinWertePF:
Mapping LOAD
	%PortfolioID,
    Date(Floor(Min(FWDatum_temp))) as MinDateFW

Resident FinanzwertePF_temp1
GROUP BY %PortfolioID;

// drop table FinanzwertePF_temp;


NoConcatenate
FinanzwertePF_temp2:
LOAD Distinct
	%PortfolioID,
    %FWID,
    NewStartDate as FWValidFrom,
    FWDatum_temp as FWValidTo,
    FWDatum_temp,
    Num(FWDatum_temp) as NumDate,
    ApplyMap('MinDateFinWertePF', %PortfolioID) as MinDateFW,
    Num(Floor(ApplyMap('MinDateFinWertePF', %PortfolioID))) as NumMinDateFW,
;
// Preceding load
LOAD
	*,
    Date(
     If(%PortfolioID = Previous(%PortfolioID), 
      If(Num(FWDatum_temp) > Num(Floor(ApplyMap('MinDateFinWertePF', %PortfolioID))), 
       If(FWDatum_temp <= Previous(FWDatum_temp), MonthStart(Previous(FWDatum_temp)), Previous(FWDatum_temp)+1),
      YearStart(FWDatum_temp)), YearStart(FWDatum_temp)))
     as NewStartDate


Resident FinanzwertePF_temp1
ORDER BY %PortfolioID, FWDatum_temp ASC;
DROP TABLE FinanzwertePF_temp1;

// Join Back the From/To Dates
LEFT JOIN (FinanzwertePF_temp)
LOAD Distinct
	%PortfolioID,
    %FWID,
    FWValidFrom,
    FWValidTo

Resident FinanzwertePF_temp2;
DROP TABLE FinanzwertePF_temp2;


// // Valid FROM
// // are: as the Endpoint gives back the Finanzwerte with a Line-By-Line ID, only the MinDate has to be identified and the ValidTo set to the beginning of the year, otherwise MonthStart...
// NoConcatenate
// FinanzwertePF_temp2:
// LOAD Distinct
// 	%PortfolioID,
//     %FWID,
// 	FWDatum_temp as FWValidTo,
// //       if(%PortfolioID=previous(%PortfolioID),      
// //           Date(rangemax(previous(FWDatum_temp)+1,YearStart(FWDatum_temp))),
// //           Date(YearStart(FWDatum_temp))
// //           ) as FWValidFrom,
          
//       if(%PortfolioID=previous(%PortfolioID), Date(RangeMin(Date(MonthStart(FWDatum_temp)), YearStart(FWDatum_temp))) ,  
//          YearStart(FWDatum_temp) ) as FWValidFrom    
//         ,
//    	previous(%PortfolioID) as Previous%PortfolioID
    
// Resident FinanzwertePF_temp1
// // FOR TESTING
// // where %PortfolioID ='106-102'
// ORDER BY %PortfolioID,
// // 	%FWID, 
// 	FWDatum_temp ASC
// ;
// drop table FinanzwertePF_temp1;

// //zum testen
// left join(FinanzwertePF_temp)
// Load Distinct
// 	%PortfolioID,
//     %FWID,
//     FWValidTo,
//     FWValidFrom
// resident FinanzwertePF_temp2;

// drop table FinanzwertePF_temp2;

// Store QVD
//temporary File
 Call QvdStore ('FinanzwertePF_temp', '$(vStorePath)', 'temp', 'FinanzwertePF_temp', '*', 1);


END IF
    

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_FinanzwertePF = (now() - vStartTime_FinanzwertePF)*86400;
Trace ----------------------------- FinanzwertePF geladen ------------------------------;
Trace $(vElapsed_FinanzwertePF);
//********************************************************************************************

///$tab 3.1.6 Cash Flows
//********************************* Start Zeitmessung *********************************
// SET vStartTime_CF = 0;
// Set vElapsed_CF = 0;
Let vStartTime_CF  = now();

//*************************************************************************************

DCF_temp:
NoConcatenate
LOAD Distinct
	_KEY_dcfAccount,
    _KEY_value,
    BewertungsID as %BewertungsID,
    Bewertungsstichtag,
    Typ,
	Annuaitaet,
    AnnuitaetP1bis10,
    AnnuitaetP11bis100,
    Barwert,
    DRreal,
    DRreal_inv,
;
// Preceding load
LOAD
    *,
    AnnuitaetReal as Annuaitaet,
    AnnuitaetP11bis100Real as AnnuitaetP1bis10,
    AnnuitaetP1bis10Real as AnnuitaetP11bis100,
    BarwertReal as Barwert,
    DiskontierungRealBerechnet as DRreal,
    1/DiskontierungRealBerechnet as DRreal_inv,
    'DCFReal' as Typ,
    ApplyMap('Map_BewStichtag_to_BewID', BewertungsID, null()) as Bewertungsstichtag
;
// Preceding load
LOAD
	*,
    left(_KEY_value, 11) as BewertungsID
FROM [$(vSourcePath)DS_api_KontoDCF.qvd]
(qvd);


LEFT JOIN (DCF_temp)
LOAD Distinct
	%BewertungsID,
	Eigentumanteil,
    Waehrung,
    CHF_Currency
//Resident Bew_temp;
FROM [$(vStorePath)temp-Bew_temp.qvd] (qvd);

LEFT JOIN (DCF_temp)
LOAD Distinct
    _KEY_value,
    ZahlungenProPeriode,
    Schuessigkeit,
    pick(match(Schuessigkeit, 'IN_ADVANCE', 'MIDTERM', 'ARREAR'), 0, 0.5, 1) as FaktorSchuessigkeit,
    EinstellungUnendlichkeit
FROM [$(vSourcePath)DS_api_Kontoeinstellungen.qvd]
(qvd);

LEFT JOIN (DCF_temp)
LOAD Distinct
//    _KEY_root,
    _KEY_value,
    KontoNameKonto
FROM [$(vSourcePath)DS_api_StandardKonti.qvd]
(qvd);

LEFT JOIN (DCF_temp)
LOAD Distinct
    _KEY_dcfAccount,
    Annuitaet%Soll
FROM [$(vSourcePath)DS_api_AnnuitaetExitAnteilSoll.qvd]
(qvd);

LEFT JOIN (DCF_temp)
LOAD Distinct
    _KEY_dcfAccount,
    AnnuitaetProM2
FROM [$(vSourcePath)DS_api_AnnuitaetExitproM2.qvd]
(qvd);

LEFT JOIN (DCF_temp)
LOAD Distinct
    _KEY_dcfAccount,
    Annuitaet%GVA
FROM [$(vSourcePath)DS_api_AnnuitaetExitAnteilGVA.qvd]
(qvd);

LEFT JOIN (DCF_temp)
LOAD Distinct
    _KEY_dcfAccount,
    _KEY_exitPeriodValue,
//    BarwertExitNominal,
    BarwertExitReal
FROM [$(vSourcePath)DS_api_ExitWert.qvd]
(qvd);

LEFT JOIN (DCF_temp)
LOAD Distinct
    _KEY_exitPeriodValue,
    AnnuitaetExit
FROM [$(vSourcePath)DS_api_AnnuitaetExitReal.qvd]
(qvd);


// Drop the _KEY fields
LET vTable = 'DCF_temp';
  FOR vF= 0 TO nooffields('$(vTable)')-1
    LET vField=fieldname(vF,'$(vTable)');
    IF wildmatch('$(vField)','_K*') THEN
      DROP FIELD "$(vField)";
    ENDIF
NEXT

//Füge Periodenwerte 1 - n hinzu (Interation über Anzahl Perioden), jeweils real + nominal 
FOR i=1 TO $(nPeriods)
LET j = $(i); 

LEFT JOIN (DCF_temp)
LOAD Distinct
	[_KEY_dcfAccount],
	[Periode$(i)Real] as Periode$(j),
    'DCFReal' as Typ  
FROM [$(vSourcePath)DS_api_Periode$(j).qvd]
(qvd);

NEXT;


// Make a Cross Table
DCF_Cross:
CrossTable(KPI, Wert, 14)
LOAD Distinct
    %BewertungsID,
    WirtschaftseinheitID,
    Bewertungsstichtag,
    ZahlungenProPeriode,
    Schuessigkeit,
    FaktorSchuessigkeit,
    EinstellungUnendlichkeit,
    Typ,
    Eigentumanteil,
    Waehrung,
    CHF_Currency,
    KontoNameKonto,
    Faktor,
    Kontolevel,
	Annuaitaet,
    AnnuitaetP1bis10,
    AnnuitaetP11bis100,
//    Annuitaet%Soll,
//    AnnuitaetProM2,
//    Annuitaet%GVA,
    AnnuitaetExit,
    Barwert,
    BarwertExitReal,   
//    DRreal,
//    DRreal_inv,
    Periode1,
    Periode2,
    Periode3,
    Periode4,
    Periode5,
    Periode6,
    Periode7,
    Periode8,
    Periode9,
    Periode10,
    Periode11,
    Periode12
 WHERE Match(Kontolevel, '2', '3')>0
;
// Preceding load
LOAD
	*,
    Left(%BewertungsID, 7) as WirtschaftseinheitID,
    ApplyMap('Map_DimAccountFactor', KontoNameKonto, '1') as Faktor,
    ApplyMap('Map_DimAccountLevel', KontoNameKonto, '3') as Kontolevel
Resident DCF_temp;

// Marktwerte aus CF-Perioden hinzufügen
MW_temp:
NoConcatenate
LOAD Distinct
	[_KEY_dcfAccount],
    left(_KEY_dcfAccount,11) as %BewertungsID,
    Bewertungsstichtag,
    ZahlungenProPeriode,
    Schuessigkeit,
    FaktorSchuessigkeit,
    EinstellungUnendlichkeit,
    Typ,
    Eigentumanteil,
    Waehrung,
    CHF_Currency,
    KontoNameKonto
Resident DCF_temp
WHERE Typ='DCFReal' and EinstellungUnendlichkeit='P_100';
DROP TABLE DCF_temp;


FOR i=1 TO $(nPeriods)
LET j = $(i); 

LEFT JOIN (MW_temp)
LOAD
	[_KEY_dcfAccount],
	[Periode$(i)MarktwertReal] as MarktwertPeriode$(j),
    'DCFReal' as Typ
FROM [$(vSourcePath)DS_api_Periode$(j).qvd]
(qvd);

NEXT;

MW_Cross_temp:
CrossTable(KPI, Wert,14)
LOAD Distinct
	%BewertungsID,
    WirtschaftseinheitID,
    Bewertungsstichtag,
    ZahlungenProPeriode,
    Schuessigkeit,
    FaktorSchuessigkeit,
    EinstellungUnendlichkeit,
    Typ,
    Eigentumanteil,
    Waehrung,
    CHF_Currency,
    'Marktwert' as KontoNameKonto,
    Faktor,
    Kontolevel,
    MarktwertPeriode1 as Periode1,
    MarktwertPeriode2 as Periode2,
    MarktwertPeriode3 as Periode3,
    MarktwertPeriode4 as Periode4,
    MarktwertPeriode5 as Periode5,
    MarktwertPeriode6 as Periode6,
    MarktwertPeriode7 as Periode7,
    MarktwertPeriode8 as Periode8,
    MarktwertPeriode9 as Periode9,
    MarktwertPeriode10 as Periode10,
    MarktwertPeriode11 as Periode11,
    MarktwertPeriode12 as Periode12,
;
// Preceding load
LOAD
	*,
    Left(%BewertungsID, 7) as WirtschaftseinheitID,
    '1' as Faktor,
    '3' as Kontolevel
Resident MW_temp
WHERE KontoNameKonto = 'INCOME-NET';
DROP TABLE MW_temp;

// // Add Account Information for the Facttable
// LEFT JOIN (DCF_Cross)
// LOAD
// 	KontoName as KontoNameKonto,
//     ElternKonto,
//     Bezeichnung2 as ElternKontoname,
//     Bezeichnung1 as ElternVonEltern,
//     %BewKontoKey,
//     KeyFiguresKontoName,
//     KeyFiguresFaktor,
//     KeyFiguresSort,
//     Depth,
//     Faktor

// //Resident Kontostruktur_Dimensions_temp;
// FROM [$(vStorePath)RF_TR-KontostrukturDimensions.qvd] (qvd);

// Store QVD
//temporary File
Call QvdStore ('DCF_Cross', '$(vStorePath)', 'temp', 'DCFCross', '*', 1);

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_CF = (now() - vStartTime_CF)*86400;
Trace ---------------------------------- Cash Flows geladen ----------------------------------;
Trace $(vElapsed_CF);
//********************************************************************************************
///$tab 3.1.7 Separate Fakten
//********************************* Start Zeitmessung *********************************
// SET vStartTime_SepFact = 0;
// Set vElapsed_SepFact = 0;
Let vStartTime_SepFact  = now();

//*************************************************************************************

// Bewertungen for Facts
Bewertungen_Fakten:
NoConcatenate
LOAD Distinct
	%PortfolioID,
    %WirtschaftseinheitNr,
    %BewertungsID,
    %BewertungKey,
    %DateKeyBew,
	Bewertungsstichtag as AsOfDate,
//    '9-99' as %BewKontoKey,
    'Marktwert' as FaktenTyp,
    'Marktwert' as SubTyp,
    'Marktwert' as Konto,
    'Marktwert' as KontoDim,
    '99-9' as KontoCustom,
//    '99-9' as KontoCombSIA,
    '99-9' as KontoSIA,
    '99-9' as KontoKKV,
    '99-9' as KontoOR,
// 	'Marktwert' as UeberKonto,
// 	'Marktwert' as ParentKonto,
//     'Marktwert' as ElternKontoTop,
//     'Marktwert' as KeyFiguresKontoName,
//     'A999' as KeyFiguresSort,
    MarktWert,
    MarktWert_woFaktor,
    Waehrung,
    CHF_Currency,
    JahrMonat,
    SubField(JahrMonat,'-',1)&' - Q' & Ceil(SubField(JahrMonat,'-',2)/3) as JahrQuartal, // tpl
    '1' as Faktor,
    '3' as Kontolevel,
    'Marktwert' as Kontotyp
;
// Preceding load
LOAD
	*,
    If(Len(Trim(%PortfolioID))>0, %PortfolioID, 'All') & '$(vKeySep)' & %WirtschaftseinheitNr & '$(vKeySep)' & %BewertungsID & '$(vKeySep)' & 'All' & '$(vKeySep)' & JahrMonat & '$(vKeySep)' & %DateKeyBew as %BewertungKey //PF+WE+FactId+Sthold+MthYr+AsOfDate
//    If(Len(Trim(%PortfolioID))>0, %PortfolioID, 'All') & '$(vKeySep)' & %WirtschaftseinheitNr & '$(vKeySep)' & %BewertungsID & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & MonatJahr & '$(vKeySep)' & %DateKeyBew as %BewertungKey //PF+WE+Bew+Abr+CD+InvPlan+Hyp+RK+MonJhr+Date
;
// Preceding Load
LOAD
	*,
    num(Bewertungsstichtag) as %DateKeyBew,
//    num(Marktwert)*Eigentumanteil*CHF_Currency*1 as MarktWert,
	num(Marktwert)*CHF_Currency*1 as MarktWert,
    Marktwert as MarktWert_woFaktor,
    Dual(Year(Bewertungsstichtag)& '-' &Num(Month(Bewertungsstichtag), '00'), Year(Bewertungsstichtag) & Num(Month(Bewertungsstichtag), '00')) as JahrMonat

// Resident Bew_temp;
// DROP TABLE Bew_temp;
FROM [$(vStorePath)temp-Bew_temp.qvd] (qvd);

//CashFlow_Fakten:
//NoConcatenate
Concatenate (Bewertungen_Fakten)
LOAD Distinct
	%PortfolioID,
    %WirtschaftseinheitNr,
    %BewertungsID,
    %BewertungKey,
    %DateKeyBew,
	Bewertungsstichtag as AsOfDate,
//    %BewKontoKey,
    'CashFlow' as FaktenTyp,
    KPI as SubTyp,
    KontoNameKonto as Konto,
    KontoNameKonto as KontoDim,
    ApplyMap('Map_DimtoCustom', KontoNameKonto, Null()) as KontoCustom,
//    ApplyMap('Map_DimtoCombSIA', KontoNameKonto, Null()) as KontoCombSIA,
	ApplyMap('Map_DimtoSIA', KontoNameKonto, Null()) as KontoSIA,
	ApplyMap('Map_DimtoKKV', KontoNameKonto, Null()) as KontoKKV,
	ApplyMap('Map_DimtoOR', KontoNameKonto, Null()) as KontoOR,
//     ElternKonto as UeberKonto,
//     ElternKonto as ParentKonto,
//     ElternVonEltern as ElternKontoTop,
//     KeyFiguresKontoName,
//     KeyFiguresSort,
    CashFlowWert,
    Wert as CashFlowWert_woFaktor,
    Waehrung,
    CHF_Currency,
    JahrMonat,
    SubField(JahrMonat,'-',1)&' - Q' & Ceil(SubField(JahrMonat,'-',2)/3) as JahrQuartal, // tpl
    Faktor,
    Kontolevel,
    'DimAccounts' as Kontotyp
;
// Preceding load
LOAD Distinct
	*,
    If(Len(Trim(%PortfolioID))>0, %PortfolioID, 'All') & '$(vKeySep)' & %WirtschaftseinheitNr & '$(vKeySep)' & %BewertungsID & '$(vKeySep)' & 'All' & '$(vKeySep)' & JahrMonat & '$(vKeySep)' & %DateKeyBew as %BewertungKey //PF+WE+FactId+Sthold+MthYr+AsOfDate
//    If(Len(Trim(%PortfolioID))>0, %PortfolioID, 'All') & '$(vKeySep)' & %WirtschaftseinheitNr & '$(vKeySep)' & %BewertungsID & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & MonatJahr & '$(vKeySep)' & %DateKeyBew as %BewertungKey
;
// Preceding load
LOAD Distinct
	*,
    ApplyMap('Map_WE_to_Portfolio', %WirtschaftseinheitNr, '') as %PortfolioID
;
// Preceding load
LOAD Distinct
	*,
//    ApplyMap('Map_Portfolio_to_Bew', BewertungsID) as %PortfolioID,
    WirtschaftseinheitID as %WirtschaftseinheitNr,
    num(Bewertungsstichtag) as %DateKeyBew,
//    num(Wert)*Eigentumanteil*CHF_Currency*KeyFiguresFaktor as CashFlowWert,
	num(Wert)*CHF_Currency*Faktor as CashFlowWert,
    Wert as CashFlowWert_woFaktor,
    Dual(Year(Bewertungsstichtag)& '-' &Num(Month(Bewertungsstichtag), '00'), Year(Bewertungsstichtag) & Num(Month(Bewertungsstichtag), '00')) as JahrMonat

// Resident DCF_Cross;
// DROP TABLE DCF_Cross;
FROM [$(vStorePath)temp-DCFCross.qvd] (qvd);

Fact_Bew_temp3:
NoConcatenate
LOAD Distinct
    %BewertungKey,
    %BewertungsID,
    Left(%BewertungsID, 7) as WEID,
    AsOfDate,
    SubField(%BewertungsID, '-', -1) as BewNo

Resident Bewertungen_Fakten
WHERE Match(FaktenTyp, 'Marktwert', 'CashFlow')>0
ORDER BY %BewertungKey;

LEFT JOIN (Fact_Bew_temp3)
LOAD Distinct
	BewertungsID as %BewertungsID,
    IstMaster
//Resident Bewertung_Dimension;
FROM [$(vStorePath)RF_MD-Bewertung.qvd] (qvd);

Fact_Bew_temp3_master:
NoConcatenate
LOAD Distinct
	*
Resident Fact_Bew_temp3
WHERE Match(IstMaster, 'True');

Fact_Bew_temp3_notmaster:
NoConcatenate
LOAD Distinct
	*
Resident Fact_Bew_temp3
WHERE Not(Match(IstMaster, 'True'));


Fact_Bew_temp4:
NoConcatenate
LOAD Distinct
	%BewertungKey,
    WEID,
    AsOfDate as BewValidFrom,
    NewDate as BewValidTo,
    %BewertungsID,
    IstMaster
//	If(Match(IstMaster, 'True')>0, NewDate, AsOfDate) as BewValidTo
;
// Preceding load
LOAD
	*,
    Date(If(WEID = Previous(WEID), If(AsOfDate = Previous(AsOfDate), AsOfDate, Previous(AsOfDate)-1), If(YearEnd($(vCurrentDate))<AsOfDate, YearEnd(AddYears(AsOfDate, 1)), YearEnd($(vCurrentDate))))) as NewDate

Resident Fact_Bew_temp3_master
ORDER BY WEID, AsOfDate DESC;

Concatenate (Fact_Bew_temp4)
LOAD Distinct
	%BewertungKey,
    WEID,
    AsOfDate as BewValidFrom,
    NewDate as BewValidTo,
    %BewertungsID,
    IstMaster
//	If(Match(IstMaster, 'True')>0, NewDate, AsOfDate) as BewValidTo
;
// Preceding load
LOAD
	*,
    Date(If(WEID = Previous(WEID), If(AsOfDate = Previous(AsOfDate), AsOfDate, Previous(AsOfDate)-1), If(YearEnd($(vCurrentDate))<AsOfDate, YearEnd(AddYears(AsOfDate, 1)), YearEnd($(vCurrentDate))))) as NewDate

Resident Fact_Bew_temp3_notmaster
ORDER BY WEID, AsOfDate DESC;

DROP TABLES Fact_Bew_temp3, Fact_Bew_temp3_master, Fact_Bew_temp3_notmaster;

LEFT JOIN (Bewertungen_Fakten)
LOAD Distinct
	%BewertungKey,
    BewValidFrom,
    BewValidTo
Resident Fact_Bew_temp4;
DROP TABLE Fact_Bew_temp4;


// Store QVD
//temporary File
Call QvdStore ('Bewertungen_Fakten', '$(vStorePath)', 'temp', 'BewertungenFakten', '*', 1);

IF Not Isnull(QvdCreateTime('$(vStorePath)temp-AbrechnungBudget_temp.qvd')) Then

// Abrechnungen & Budgets for Facts
Abrechnungen_Fakten:
NoConcatenate
LOAD Distinct
    %PortfolioID,	
    %WirtschaftseinheitNr,
    %AbrechnungBudgetID,
    %AbrechnungKey,
    %DateKeyAbr,
	AsOfDate,
    KontoCustom,
    KontoCustom as %AbrKontoKey,
    'AbrechnungBudget' as FaktenTyp,
    Typ as SubTyp,
    KontoCustom as Konto,
    ApplyMap('Map_CustomtoDim', KontoCustom, Null()) as KontoDim,
//    ApplyMap('Map_CustomtoCombinedSIA', KontoCustom, Null()) as KontoCombSIA,
	ApplyMap('Map_CustomtoSIA', KontoCustom, Null()) as KontoSIA,
	ApplyMap('Map_CustomtoKKV', KontoCustom, Null()) as KontoKKV,
	ApplyMap('Map_CustomtoOR', KontoCustom, Null()) as KontoOR,
//     UeberKonto,
//     ParentKonto,
//     ParentOfParentKonto as ElternKontoTop,
//     KeyFiguresKontoName,
//     KeyFiguresSort,
    AbrechnungsBudgetWert,
    Wert as AbrechnungsBudgetWert_woFaktor,
	Waehrung,
    CHF_Currency,    
    JahrMonat,
    SubField(JahrMonat,'-',1)&' - Q' & Ceil(SubField(JahrMonat,'-',2)/3) as JahrQuartal, // tpl
    Faktor,
    Kontolevel,
    AbrBdgValidFrom,
    AbrBdgValidTo,
    'CustomAccounts' as Kontotyp
;    
// Preceding load
LOAD
	*,
    // If(Len(Trim(%PortfolioID))>0, %PortfolioID, 'All') & '$(vKeySep)' & %WirtschaftseinheitNr & '$(vKeySep)' & %AbrechnungBudgetID & '$(vKeySep)' & 'All' & '$(vKeySep)' & JahrMonat & '$(vKeySep)' & %DateKeyAbr as %AbrechnungKey //PF+WE+FactId+Sthold+MthYr+AsOfDate
    If(Len(Trim(%PortfolioID))>0, %PortfolioID, 'All') & '$(vKeySep)' & %WirtschaftseinheitNr & '$(vKeySep)' & %AbrechnungBudgetID & '$(vKeySep)' & 'All' & '$(vKeySep)' & KontoCustom & '$(vKeySep)' & JahrMonat & '$(vKeySep)' & %DateKeyAbr as %AbrechnungKey // + Konto
;
// Preceding load
LOAD
	*,
    num(Wert)*CHF_Currency*Faktor as AbrechnungsBudgetWert,
    Wert as AbrechnungsBudgetWert_woFaktor,
    Date(Floor(MonthStart(PeriodenStart))) as AbrBdgValidFrom,
    Date(Floor(MonthEnd(MaxPeriodEnd))) as AbrBdgValidTo
;
// Preceding load
LOAD
	*,
    ReferenzNrKonto as KontoCustom,
    PortfolioID as %PortfolioID,
    AbrechnungBudgetID as %AbrechnungBudgetID,
	num(Date(Floor(MonthStart(MinPeriodStart)))) as %DateKeyAbr,
    Date(Floor(MonthStart(MinPeriodStart))) as AsOfDate,
    Dual(Year(PeriodenStart)& '-' &Num(Month(PeriodenStart), '00'), Year(PeriodenStart) & Num(Month(PeriodenStart), '00')) as JahrMonat
    
// Resident AbrechnungBudget_temp;
// DROP TABLE AbrechnungBudget_temp;
FROM [$(vStorePath)temp-AbrechnungBudget_temp.qvd] (qvd);

// Store QVD
//temporary File
Call QvdStore ('Abrechnungen_Fakten', '$(vStorePath)', 'temp', 'AbrechnungenFakten', '*', 1);

END IF

IF Not Isnull(QvdCreateTime('$(vStorePath)temp-Einzelbuchungen_temp.qvd')) Then

// Abacus Einzelbuchungen
Einzelbuchungen_Fakten:
NoConcatenate
LOAD Distinct
	%PortfolioID,
    %WirtschaftseinheitNr,
    BauprojekteID,
    DivisionID,
    %BuchungsID,
    %BuchungKey,
    %DateKeyBuchung,
    AsOfDate,
    %BuchungKontoKey,
    FaktenTyp,
    SubTyp,
    Konto,
    ApplyMap('Map_CustomtoDim', Konto, Null()) as KontoDim,
    Konto as KontoCustom,
//    ApplyMap('Map_CustomtoCombinedSIA', Konto, Null()) as KontoCombSIA,
	ApplyMap('Map_CustomtoSIA', Konto, Null()) as KontoSIA,
	ApplyMap('Map_CustomtoKKV', Konto, Null()) as KontoKKV,
	ApplyMap('Map_CustomtoOR', Konto, Null()) as KontoOR,
//     UeberKonto,
//     ParentKonto,
//     ElternKontoTop,
//     KeyFiguresKontoName,
//     KeyFiguresSort,
	BuchungsBetrag,
    BuchungsBetrag_woFaktor,
    Waehrung,
    CHF_Currency,
    JahrMonat,
    SubField(JahrMonat,'-',1)&' - Q' & Ceil(SubField(JahrMonat,'-',2)/3) as JahrQuartal, // tpl
    Faktor,
    Kontolevel,
    BuchungValidFrom,
    BuchungValidTo,
    'CustomAccounts' as Kontotyp
    
FROM [$(vStorePath)temp-Einzelbuchungen_temp.qvd] (qvd);

// Store QVD
//temporary File
Call QvdStore ('Einzelbuchungen_Fakten', '$(vStorePath)', 'temp', 'EinzelbuchungenFakten', '*', 1);

END IF

IF Not Isnull(QvdCreateTime('$(vStorePath)temp-Liegenschaftswerte_temp.qvd')) Then
// Liegenschaftswerte
Liegenschaftswerte_Fakten:
NoConcatenate
LOAD Distinct
 	%PortfolioID,
    %WirtschaftseinheitNr,
    %LSWID,
    %LSWKey,
    %DateKeyLSW,
    AsOfDate,
    %LSWKontoKey,
    FaktenTyp,
    SubTyp,
    Konto,
//	ApplyMap('Map_CustomtoDim', ApplyMap('Map_SIAtoCustom', Konto, Null()), Null()) as KontoDim, // it does not work
//    ApplyMap('Map_SIAtoCustom', Konto, Null()) as KontoCustom, // it does not work - but you can take the first given custom conto
	ApplyMap('Map_CustomtoDim', ApplyMap('Map_CombSIAtoCustom', LSWKontoTechName, Null()), Null()) as KontoDim,
	ApplyMap('Map_CombSIAtoCustom', LSWKontoTechName, Null()) as KontoCustom,
//	Konto as KontoCombSIA,
	If(Match(KontoTyp, 'SIA')>0, Konto, Null()) as KontoSIA,
    If(Match(KontoTyp, 'KKV')>0, Konto, Null()) as KontoKKV,
    If(Match(KontoTyp, 'ASSET_STATEMENT_LAW_OF_BONDS')>0, Konto, Null()) as KontoOR,
//     ApplyMap('Map_CustomtoCombinedSIA', Konto, Null()) as KontoCombSIA,
    LSWBetrag,
    LSWBetrag_woFaktor,
    Waehrung,
    CHF_Currency,
    JahrMonat,
    JahrQuartal,
    LSWValidFrom,
    LSWValidTo,
//     LSWDatum,
    Faktor,
    Kontolevel,
    KontoTyp as Kontotyp

FROM [$(vStorePath)temp-Liegenschaftswerte_temp.qvd] (qvd);

// Store QVD
//temporary File
Call QvdStore ('Liegenschaftswerte_Fakten', '$(vStorePath)', 'temp', 'LiegenschaftswerteFakten', '*', 1);

// drop table Liegenschaftswerte_Fakten;
END IF


IF Not Isnull(QvdCreateTime('$(vStorePath)temp-FinanzwertePF_temp.qvd')) Then
// Finanzwerte
FinanzwertePF_Fakten:
NoConcatenate
LOAD Distinct
 	%PortfolioID,
    'ALL' as %WirtschaftseinheitNr,
    %FWID,
    %FWKey,
    %DateKeyFW,
    AsOfDate,
    %FWKontoKey,
    FaktenTyp,
    SubTyp,
    Konto,
//	ApplyMap('Map_CustomtoDim', ApplyMap('Map_SIAtoCustom', Konto, Null()), Null()) as KontoDim, // it does not work
//    ApplyMap('Map_SIAtoCustom', Konto, Null()) as KontoCustom, // it does not work - but you can take the first given custom conto
	ApplyMap('Map_CustomtoDim', ApplyMap('Map_CombSIAtoCustom', FWKontoTechName, Null()), Null()) as KontoDim,
    ApplyMap('Map_CombSIAtoCustom', FWKontoTechName, Null()) as KontoCustom,
//	Konto as KontoCombSIA,
	If(Match(KontoTyp, 'SIA')>0, Konto, Null()) as KontoSIA,
    If(Match(KontoTyp, 'KKV')>0, Konto, Null()) as KontoKKV,
    If(Match(KontoTyp, 'ASSET_STATEMENT_LAW_OF_BONDS')>0, Konto, Null()) as KontoOR,
//     ApplyMap('Map_CustomtoCombinedSIA', Konto, Null()) as KontoCombSIA,
    FWBetrag,
    FWBetrag_woFaktor,
    Waehrung,
    CHF_Currency,
    JahrMonat,
    JahrQuartal,
    FWValidFrom,
    FWValidTo,
//     FWDatum,
    Faktor,
    Kontolevel,
    KontoTyp as Kontotyp

FROM [$(vStorePath)temp-FinanzwertePF_temp.qvd] (qvd);

// Store QVD
//temporary File
Call QvdStore ('FinanzwertePF_Fakten', '$(vStorePath)', 'temp', 'FinanzwertePFFakten', '*', 1);

// drop table FinanzwertePF_Fakten;
END IF


//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_SepFact = (now() - vStartTime_SepFact)*86400;
Trace ---------------------------------- Separate Fakten geladen ----------------------------------;
Trace $(vElapsed_SepFact);
//********************************************************************************************

///$tab 3.1.8 Concatenated Fakten
//********************************* Start Zeitmessung *********************************
// SET vStartTime_ConcatFact = 0;
// Set vElapsed_ConcatFact = 0;
Let vStartTime_ConcatFact  = now();

//*************************************************************************************

// Load Concatenated Facts
Concat_Fakten:
LOAD Distinct
	%PortfolioID,	
    %WirtschaftseinheitNr,
    %BewertungsID,
    'ALL' as %AbrechnungBudgetID,
    'ALL' as %BuchungsID,
    'ALL' as BauprojekteID,
    'ALL' as DivisionID,
    %BewertungKey as %FaktenKey,
    %BewertungKey & '$(vKeySep)' & KontoDim as %FaktKontoDimKey,
    %BewertungKey & '$(vKeySep)' & KontoCustom as %FaktKontoCustomKey,
//    %BewertungKey & '$(vKeySep)' & KontoCombSIA as %FaktKontoCombSIAKey,
    %BewertungKey & '$(vKeySep)' & KontoSIA as %FaktKontoSIAKey,
    %BewertungKey & '$(vKeySep)' & KontoKKV as %FaktKontoKKVKey,
    %BewertungKey & '$(vKeySep)' & KontoOR as %FaktKontoORKey,
//     Hash128(%BewertungKey) as %FaktenKey,
//     Hash128(%BewertungKey & '$(vKeySep)' & KontoDim) as %FaktKontoDimKey,
//     Hash128(%BewertungKey & '$(vKeySep)' & KontoCustom) as %FaktKontoCustomKey,
//     Hash128(%BewertungKey & '$(vKeySep)' & KontoCombSIA) as %FaktKontoCombSIAKey,
//    %BewertungKey as RefFaktenKey,
    %DateKeyBew as %DateKey,
	AsOfDate,
//    %BewKontoKey,
//    'ALL' as %AbrKontoKey,
    FaktenTyp,
    SubTyp,
    Konto as %ReferenzNrKonto,
    KontoDim as %KontoDim,
    KontoCustom as %KontoCustom,
	KontoSIA as %KontoSIA,
	KontoKKV as %KontoKKV,
	KontoOR as %KontoOR,
// 	UeberKonto,
// 	ParentKonto,
//     ElternKontoTop,
//     %KeyFigKontoname as KeyFigKontoname,
//     KeyFiguresSort,
    MarktWert_woFaktor as FaktenWert,
    MarktWert as FaktenWert_Factored,
    Waehrung,
    CHF_Currency,  
    JahrMonat,
    JahrQuartal,
    Kontotyp
    
//    Kontolevel,
//    'no' as SumLevel
// ;
// // Preceding load
// LOAD Distinct
// 	*,
//     MarktWert as FaktenWert_Factored,
//     MarktWert_woFaktor as FaktenWert,
//     KeyFiguresKontoName as %KeyFigKontoname

//Resident Bewertungen_Fakten
FROM [$(vStorePath)temp-BewertungenFakten.qvd] (qvd)
WHERE not(isnull(%BewertungsID)) and FaktenTyp = 'Marktwert' /*and Match(Kontolevel, '3', '4')>0*/;


Concatenate(Concat_Fakten)
LOAD Distinct
	%PortfolioID,	
    %WirtschaftseinheitNr,
    %BewertungsID,
    'ALL' as %AbrechnungBudgetID,
    'ALL' as %BuchungsID,
    'ALL' as BauprojekteID,
    'ALL' as DivisionID,
    %BewertungKey as %FaktenKey,
    %BewertungKey & '$(vKeySep)' & KontoDim as %FaktKontoDimKey,
    %BewertungKey & '$(vKeySep)' & KontoCustom as %FaktKontoCustomKey,
//    %BewertungKey & '$(vKeySep)' & KontoCombSIA as %FaktKontoCombSIAKey,
    %BewertungKey & '$(vKeySep)' & KontoSIA as %FaktKontoSIAKey,
    %BewertungKey & '$(vKeySep)' & KontoKKV as %FaktKontoKKVKey,
    %BewertungKey & '$(vKeySep)' & KontoOR as %FaktKontoORKey,
//     Hash128(%BewertungKey) as %FaktenKey,
//     Hash128(%BewertungKey & '$(vKeySep)' & KontoDim) as %FaktKontoDimKey,
//     Hash128(%BewertungKey & '$(vKeySep)' & KontoCustom) as %FaktKontoCustomKey,
//     Hash128(%BewertungKey & '$(vKeySep)' & KontoCombSIA) as %FaktKontoCombSIAKey,
//    %BewertungKey as RefFaktenKey,
    %DateKeyBew as %DateKey,
	AsOfDate,
//    %BewKontoKey,
//    'ALL' as %AbrKontoKey,
    FaktenTyp,
    SubTyp,
    Konto as %ReferenzNrKonto,
    KontoDim as %KontoDim,
    KontoCustom as %KontoCustom,
	KontoSIA as %KontoSIA,
	KontoKKV as %KontoKKV,
	KontoOR as %KontoOR,
// 	UeberKonto,
// 	ParentKonto,
//     ElternKontoTop,
//     %KeyFigKontoname as KeyFigKontoname,
//     KeyFiguresSort,
    CashFlowWert_woFaktor as FaktenWert,
    CashFlowWert as FaktenWert_Factored,
    Waehrung,
    CHF_Currency,  
    JahrMonat,
    JahrQuartal,
    Kontotyp
//     Kontolevel,
//     'no' as SumLevel
// ;
// // Preceding load
// LOAD Distinct
// 	*,
//     CashFlowWert_woFaktor as FaktenWert,
//     CashFlowWert as FaktenWert_Factored,
//     KeyFiguresKontoName as %KeyFigKontoname

//Resident Bewertungen_Fakten
FROM [$(vStorePath)temp-BewertungenFakten.qvd] (qvd)
WHERE not(isnull(%BewertungsID)) and FaktenTyp = 'CashFlow' /*and Match(Kontolevel, '2', '3')>0*/;

IF Not Isnull(QvdCreateTime('$(vStorePath)temp-AbrechnungenFakten.qvd')) Then

Concatenate (Concat_Fakten)
LOAD Distinct
	%PortfolioID,	
    %WirtschaftseinheitNr,
    'ALL' as %BewertungsID,
    %AbrechnungBudgetID,
    'ALL' as %BuchungsID,
    'ALL' as BauprojekteID,
    'ALL' as DivisionID,
    %AbrechnungKey as %FaktenKey,
    %AbrechnungKey & '$(vKeySep)' & KontoDim as %FaktKontoDimKey,
    %AbrechnungKey & '$(vKeySep)' & KontoCustom as %FaktKontoCustomKey,
//    %AbrechnungKey & '$(vKeySep)' & KontoCombSIA as %FaktKontoCombSIAKey,
    %AbrechnungKey & '$(vKeySep)' & KontoSIA as %FaktKontoSIAKey,
    %AbrechnungKey & '$(vKeySep)' & KontoKKV as %FaktKontoKKVKey,
    %AbrechnungKey & '$(vKeySep)' & KontoOR as %FaktKontoORKey,
//     Hash128(%AbrechnungKey) as %FaktenKey,
//     Hash128(%AbrechnungKey & '$(vKeySep)' & KontoDim) as %FaktKontoDimKey,
//     Hash128(%AbrechnungKey & '$(vKeySep)' & KontoCustom) as %FaktKontoCustomKey,
//     Hash128(%AbrechnungKey & '$(vKeySep)' & KontoCombSIA) as %FaktKontoCombSIAKey,
//    %AbrechnungKey as RefFaktenKey,
    %DateKeyAbr as %DateKey,
	AsOfDate,
//    'ALL' as %BewKontoKey,
//    %AbrKontoKey,
    FaktenTyp,
    SubTyp,
    Konto as %ReferenzNrKonto,
    KontoDim as %KontoDim,
    KontoCustom as %KontoCustom,
	KontoSIA as %KontoSIA,
	KontoKKV as %KontoKKV,
	KontoOR as %KontoOR,
// 	UeberKonto,
// 	ParentKonto,
//     ElternKontoTop,
//     %KeyFigKontoname as KeyFigKontoname,
//     KeyFiguresSort,
    AbrechnungsBudgetWert_woFaktor as FaktenWert,
    AbrechnungsBudgetWert as FaktenWert_Factored,
    Waehrung,
    CHF_Currency,  
    JahrMonat,
    JahrQuartal,
    Kontotyp
//     Kontolevel,
//     'no' as SumLevel
// ;    
// // Preceding load 
// LOAD Distinct
// 	*,
//     AbrechnungsBudgetWert_woFaktor as FaktenWert,
//     AbrechnungsBudgetWert as FaktenWert_Factored,
//     KeyFiguresKontoName as %KeyFigKontoname
    
//Resident Abrechnungen_Fakten
FROM [$(vStorePath)temp-AbrechnungenFakten.qvd] (qvd)
WHERE not(isnull(%AbrechnungBudgetID)) and FaktenTyp = 'AbrechnungBudget' /*and Match(Kontolevel, '3', '4')>0*/;

END IF

IF Not Isnull(QvdCreateTime('$(vStorePath)temp-EinzelbuchungenFakten.qvd')) Then

Concatenate (Concat_Fakten)
LOAD Distinct
	%PortfolioID,
    %WirtschaftseinheitNr,
    'ALL' as %BewertungsID,
    'ALL' as %AbrechnungBudgetID,
    %BuchungsID,
    BauprojekteID,
    DivisionID,
    %BuchungKey as %FaktenKey,
    %BuchungKey & '$(vKeySep)' & KontoDim as %FaktKontoDimKey,
    %BuchungKey & '$(vKeySep)' & KontoCustom as %FaktKontoCustomKey,
//    %BuchungKey & '$(vKeySep)' & KontoCombSIA as %FaktKontoCombSIAKey,
    %BuchungKey & '$(vKeySep)' & KontoSIA as %FaktKontoSIAKey,
    %BuchungKey & '$(vKeySep)' & KontoKKV as %FaktKontoKKVKey,
    %BuchungKey & '$(vKeySep)' & KontoOR as %FaktKontoORKey,
//     Hash128(%BuchungKey) as %FaktenKey,
//     Hash128(%BuchungKey & '$(vKeySep)' & KontoDim) as %FaktKontoDimKey,
//     Hash128(%BuchungKey & '$(vKeySep)' & KontoCustom) as %FaktKontoCustomKey,
//     Hash128(%BuchungKey & '$(vKeySep)' & KontoCombSIA) as %FaktKontoCombSIAKey,
//    %BuchungKey as RefFaktenKey,
    %DateKeyBuchung as %DateKey,
    AsOfDate,
//    %BuchungKontoKey,
    FaktenTyp,
    SubTyp,
    Konto as %ReferenzNrKonto,
    KontoDim as %KontoDim,
    KontoCustom as %KontoCustom,
	KontoSIA as %KontoSIA,
	KontoKKV as %KontoKKV,
	KontoOR as %KontoOR,
//     UeberKonto,
//     ParentKonto,
//     ElternKontoTop,
//     %KeyFigKontoname as KeyFigKontoname,
//     KeyFiguresSort,
    BuchungsBetrag_woFaktor as FaktenWert,
    BuchungsBetrag as FaktenWert_Factored,
    Waehrung,
    CHF_Currency,  
    JahrMonat,
    JahrQuartal,
    Kontotyp
//     Kontolevel,
//     'no' as SumLevel
// ;    
// // Preceding load 
// LOAD Distinct
// 	*,
//     BuchungsBetrag_woFaktor as FaktenWert,
//     BuchungsBetrag as FaktenWert_Factored,
//     KeyFiguresKontoName as %KeyFigKontoname

FROM [$(vStorePath)temp-EinzelbuchungenFakten.qvd] (qvd)
WHERE not(isnull(%BuchungsID)) and FaktenTyp = 'Einzelbuchung' /*and Match(Kontolevel, '3', '4')>0*/;

END IF

IF Not Isnull(QvdCreateTime('$(vStorePath)temp-LiegenschaftswerteFakten.qvd')) Then

Concatenate (Concat_Fakten)
LOAD Distinct
	%PortfolioID,
    %WirtschaftseinheitNr,
    'ALL' as %BewertungsID,
    %LSWID as %AbrechnungBudgetID,
    'ALL' as %BuchungsID,
    'ALL' as BauprojekteID,
    'ALL' as DivisionID,
    %LSWKey as %FaktenKey,
    %LSWKey & '$(vKeySep)' & KontoDim as %FaktKontoDimKey,
    %LSWKey & '$(vKeySep)' & KontoCustom as %FaktKontoCustomKey,
//    %LSWKey & '$(vKeySep)' & KontoCombSIA as %FaktKontoCombSIAKey,
    %LSWKey & '$(vKeySep)' & KontoSIA as %FaktKontoSIAKey,
    %LSWKey & '$(vKeySep)' & KontoKKV as %FaktKontoKKVKey,
    %LSWKey & '$(vKeySep)' & KontoOR as %FaktKontoORKey,
    %DateKeyLSW as %DateKey,
    AsOfDate,
    FaktenTyp,
    SubTyp,
//    ApplyMap('Map_SIAtoCustom', Konto, Null()) as %ReferenzNrKonto, //Custom  //are: why do we map back to Custom Account? for SIA it does exist, for KKV and OR it does not
	Konto as %ReferenzNrKonto,
    KontoDim as %KontoDim,
    KontoCustom as %KontoCustom,
	KontoSIA as %KontoSIA,
	KontoKKV as %KontoKKV,
	KontoOR as %KontoOR,
    LSWBetrag_woFaktor as FaktenWert,
    LSWBetrag as FaktenWert_Factored,
    Waehrung,
    CHF_Currency,  
    JahrMonat,
    JahrQuartal,
    Kontotyp
    
FROM [$(vStorePath)temp-LiegenschaftswerteFakten.qvd] (qvd)
WHERE not(isnull(%LSWID)) and FaktenTyp = 'Liegenschaftswerte' /*and Match(Kontolevel, '3', '4')>0*/;

END IF


IF Not Isnull(QvdCreateTime('$(vStorePath)temp-FinanzwertePFFakten.qvd')) Then

Concatenate (Concat_Fakten)
LOAD Distinct
	%PortfolioID,
    'ALL' as %WirtschaftseinheitNr,
    'ALL' as %BewertungsID,
    %FWID as %AbrechnungBudgetID,
    'ALL' as %BuchungsID,
    'ALL' as BauprojekteID,
    'ALL' as DivisionID,
    %FWKey as %FaktenKey,
    %FWKey & '$(vKeySep)' & KontoDim as %FaktKontoDimKey,
    %FWKey & '$(vKeySep)' & KontoCustom as %FaktKontoCustomKey,
//    %FWKey & '$(vKeySep)' & KontoCombSIA as %FaktKontoCombSIAKey,
    %FWKey & '$(vKeySep)' & KontoSIA as %FaktKontoSIAKey,
    %FWKey & '$(vKeySep)' & KontoKKV as %FaktKontoKKVKey,
    %FWKey & '$(vKeySep)' & KontoOR as %FaktKontoORKey,
    %DateKeyFW as %DateKey,
    AsOfDate,
    FaktenTyp,
    SubTyp,
//    ApplyMap('Map_SIAtoCustom', Konto, Null()) as %ReferenzNrKonto, //Custom
	Konto as %ReferenzNrKonto,
    KontoDim as %KontoDim,
    KontoCustom as %KontoCustom,
	KontoSIA as %KontoSIA,
	KontoKKV as %KontoKKV,
	KontoOR as %KontoOR,
    FWBetrag_woFaktor as FaktenWert,
    FWBetrag as FaktenWert_Factored,
    Waehrung,
    CHF_Currency,  
    JahrMonat,
    JahrQuartal,
    Kontotyp
    
FROM [$(vStorePath)temp-FinanzwertePFFakten.qvd] (qvd)
WHERE not(isnull(%FWID)) and FaktenTyp = 'PF_Finanzwerte' /*and Match(Kontolevel, '3', '4')>0*/;

END IF


//************** In order to have all the KeyFig Accounts "always on" on the Dashboard, we have to add all the accounts as if they had a value (0) ***************//

// // Cartesian Product of WE, PF and Accounts
// Fact_extensions_temp:
// NoConcatenate
// LOAD Distinct
//     PortfolioId as %PortfolioID,
//  	%WirtschaftseinheitNr,
//     Left(%WirtschaftseinheitNr,3) as DataBoxId,
//     Hash128('nofact') as %FaktenKey,
//     'nofact' as RefFaktenKey
// //Resident WE_temp;
// FROM [$(vStorePath)temp-WE_temp.qvd] (qvd);

// Key_Fig_Concat_temp:
// NoConcatenate
// LOAD Distinct
// 	'106' as DataBoxId,
// //    KeyFiguresKontoName as %KeyFigKontoname,
// 	KeyFiguresKontoName as KeyFigKontoname,
//     KeyFiguresSort
// //Resident Kontostruktur_Custom_temp;
// FROM [$(vStorePath)RF_TR-KontostrukturCustom.qvd] (qvd);

// Concatenate (Key_Fig_Concat_temp)
// LOAD Distinct
// 	'106' as DataBoxId,
// //    KeyFiguresKontoName as %KeyFigKontoname,
// 	KeyFiguresKontoName as KeyFigKontoname,
//     KeyFiguresSort
// //Resident Kontostruktur_Dimensions_temp;
// FROM [$(vStorePath)RF_TR-KontostrukturDimensions.qvd] (qvd);


// LEFT JOIN (Fact_extensions_temp)
// LOAD Distinct
// 	'106' as DataBoxId,
// //    %KeyFigKontoname,
// 	KeyFigKontoname,
//     KeyFiguresSort,
//     '0' as FaktenWert,
//     '0' as FaktenWert_Factored  
// Resident Key_Fig_Concat_temp;
// DROP TABLE Key_Fig_Concat_temp;

// // Concatenate Facts-Links
// Concatenate (Fact_extensions_temp)
// LOAD Distinct
//     %PortfolioID,
//     %WirtschaftseinheitNr,
//     %BewertungsID,
//     %AbrechnungBudgetID,
//     %BuchungsID,
//     %FaktenKey,
//     RefFaktenKey,
//     %FaktKontoKey,
//     %DateKey,
// 	AsOfDate,
// //    %BewKontoKey,
// //    %AbrKontoKey,
//     FaktenTyp,
//     SubTyp,
// //    Konto,
// 	%ReferenzNrKonto,
// 	UeberKonto,
// 	ParentKonto,
//     ElternKontoTop,
// //    %KeyFigKontoname,
// 	KeyFigKontoname,  // join on this
//     KeyFiguresSort,
//     FaktenWert,
//     FaktenWert_Factored,
//     Waehrung,
//     CHF_Currency,  
//     JahrMonat,
//     Kontolevel,
//     SumLevel
// ;
// // Preceding load
// LOAD
// 	*,
//     ApplyMap('Map_WE_to_Portfolio', %WirtschaftseinheitNr, Null()) as %PortfolioID
// ;
// // Preceding load
// LOAD Distinct
// 	*,
//     SubField(RefFaktenKey, '$(vKeySep)', 2) as %WirtschaftseinheitNr,
//     SubField(RefFaktenKey, '$(vKeySep)', -1) as %DateKey
// Resident Concat_Fakten;
// DROP TABLE Concat_Fakten;

// *** END FACT extension *** //


// Concat_Fakten:
// NoConcatenate
// LOAD Distinct
// 	*,
//     ApplyMap('Map_CustomtoSIA', %ReferenzNrKonto, Null()) as RefKtoSIA
// Resident Fact_extensions_temp;
// DROP TABLE Fact_extensions_temp;


DROP FIELDS %PortfolioID, %WirtschaftseinheitNr, %DateKey FROM Concat_Fakten;

// Store QVD
Call QvdStore ('Concat_Fakten', '$(vStorePath)', 'RF_TR', 'Fakten', '*', 1);


//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_ConcatFact = (now() - vStartTime_ConcatFact)*86400;
Trace ---------------------------------- Concat Fakten geladen ----------------------------------;
Trace $(vElapsed_ConcatFact);
//********************************************************************************************
///$tab Ende Bew/Abr 3.1 <
//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_FACTBewAbr = (now() - vStartTime_FACTBewAbr)*86400;
Trace ---------------------------------- FACTS Bewertungen / Abrechnungen geladen ----------------------------------;
Trace $(vElapsed_FACTBewAbr);
//********************************************************************************************

///$tab > 3.2 Bauprojekte
//********************************* Start Zeitmessung *********************************
// SET vStartTime_Bauprojekte = 0;
// Set vElapsed_Bauprojekte = 0;
Let vStartTime_Bauprojekte  = now();

//*************************************************************************************
///$tab 3.2.1 Bauprojekte (neu)
//********************************* Start Zeitmessung *********************************
// SET vStartTime_CDProj = 0;
// Set vElapsed_CDProj = 0;
Let vStartTime_CDProj  = now();

//*************************************************************************************


If not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Bauprojekte.qvd')) Then

  Bauprojekte_temp:
  NoConcatenate
  LOAD Distinct
      BasisURL,
//       _KEY_content,
//       _KEY_root,
//       _KEY_settings,
      Projektart_temp as Projektart,
      ExternePhase,
      Projektkategorie,
      ProjektartRGB,
//      link_checklist,
      Bemerkung,
//       link_components,
//       link_constructionInvoiceApprovalProcess,
//       link_contracts,
      ControllingOptionalApprovedDate,
      ApplyMap('Map_Users', controllingOptionalApprovedUser_temp, Null()) as controllingOptionalApprovedUser,
//      link_controllingOptionalApprovedUser,
      ControllingOptionalBegruendung,
      ControllingOptionalStatus,
//       link_conversations,
//       link_costEstimation,
//       link_creditApplications,
      ReferenzNr,
      ReferenzNr2,
      %BauprojekteID,
      BauprojekteID,
      BauprojekteID as %RefCDPID,
      PhaseRechnung,
      StatusRechnung,
      IstAbgebrochen,
      OhneControllingzwang,
      Name,
      Optierungsgrad,
      ApplyMap('Map_Users', phaseDeactivationApprovedUser_temp, Null()) as phaseDeactivationApprovedUser,
//      link_phaseDeactivationApprovedUser,
      Phase_temp as Phase,
      PhaseGroup, 
      Planung,
//      Wirtschaftseinheit as link_WE,
      TotalGenehmigteKredite,
      WirtschaftseinheitsID,
//      WirtschaftseinheitsID as %WERefKey,
      Mehrwertsteuersatz,
      Version,
//      link_versions,
      RefPFID,
     // BauprojekteID & '$(vKeySep)' & PhaseNum as %BPPhaseId,
      PhaseNum as CurrentPhaseNum
   ;
   //Preceding load
   LOAD Distinct
   	   *,
       ApplyMap('MappingProjektArt', Projektart) as Projektart_temp,
       ApplyMap('MappingProjektArtRGB', Projektart) as ProjektartRGB,
       ApplyMap('MappingCdProjectPhase', Phase) as Phase_temp,
       If(SubField(Phase, '_', -1)='5', '4.5', SubField(Phase, '_', -1)) as PhaseNum,
       ApplyMap('Map_PhaseGroup', Phase) as PhaseGroup, 
       Id as %BauprojekteID,
       Id as BauprojekteID,
       ApplyMap('Map_WE_to_Portfolio', WirtschaftseinheitsID,  null()) as RefPFID,
       SubField(link_controllingOptionalApprovedUser, '/', -1) as controllingOptionalApprovedUser_temp,
       SubField(link_phaseDeactivationApprovedUser, '/', -1) as phaseDeactivationApprovedUser_temp
       
  FROM [$(vSourcePath)DS_api_Bauprojekte.qvd]
  (qvd);
 

  If not Isnull(QvdCreateTime('$(vSourcePath)DS_api_BauprojekteProjektDaten.qvd')) Then

  LEFT JOIN (Bauprojekte_temp)
//   BauprojekteKennwerte_temp:
//   NoConcatenate
  LOAD Distinct
    BauprojektID as %BauprojekteID,
  	ProjektBeschreibung as BauprojekteKennwerte_ProjektBeschreibung,
    Date(BeginnBaugarantie) as BeginnBaugarantie,
    Date(AblaufBaugarantie) as AblaufBaugarantie,
    Webcam,
    Website,
//    _KEY_root,
//    _KEY_benchmarkFigures,
    Meilenstein,
    Typ as MeilensteinTyp,
    Date(DatumGeplant) as DatumGeplant,
    Date(DatumAktuell) as DatumAktuell,
    Bemerkung as BauprojekteKennwerte_Bemerkung,
    ExtProjekTeamRolle as BauprojekteKennwerte_ExtProjekTeamRolle,
    ExtProjekTeamName as BauprojekteKennwerte_ExtProjekTeamName,
    Date(ExtProjekTeamSeitDatum) as ExtProjTeamStartDatum,
    AnzahlWohnungen,
    FensteranteilFassade,
    FlaecheAussenhaut,
    Kompaktheit,
    Planungsart,
    Planungsrecht,
    Gebaeudetyp,
    Vorbereitung,
    FuerBenchmarkingGeeignet,
    BemerkungKennwerte,
    BaujahrWertBerechnet,
    BaujahrWertManuell,
    BaujahrWert,
    TypGebaeudevolumenOberirdisch,
    WertGebaeudevolumenOberirdisch,
    TypGebaeudevolumenUnterirdisch,
    WertGebaeudevolumenUnterirdisch,
    TypGeschossflaecheOberirdisch,
    WertGeschossflaecheOberirdisch,
    TypGeschossflaecheUnterirdisch,
    WertGeschossflaecheUnterirdisch
    
  FROM [$(vSourcePath)DS_api_BauprojekteProjektDaten.qvd]
  (qvd);
  
  End If


  If not Isnull(QvdCreateTime('$(vSourcePath)DS_api_BauprojektePhasen.qvd')) Then
  
  BauprojektePhasen_temp:
  NoConcatenate
  LOAD Distinct
      BauprojekteID_temp & '$(vKeySep)' & PhaseNum as %BPPhaseId,
      BauprojekteID_temp as %BauprojekteID,
//      BasisURL,
//       _KEY_phasesConfig,
//       _KEY_settings,
      Aktiv,
//       AblaufBaugarantie_temp as AblaufBaugarantie,
//       BeginnBaugarantie_temp as BeginnBaugarantie,
      DauerInMonaten,
      CDProjectEndDate_temp as CDProjectEndDate,
//      Ende_temp as Ende, // legacy Field, deactivate later
      CDProjectStartDate_temp as CDProjectStartDate,
//      Start_temp as "Start", // legacy Field, deactivate later
      Obligatorisch,
      Phase_temp as Phase_temp2,
      Phase as Phase_TechName,
      PhaseNum,
      DatumGenehmigungPhase_temp as DatumGenehmigungPhase,
      StatusGenehminungPhase,
      Date(StartDesProjekts) as PhaseStartDate,
      Date(Date(StartDesProjekts), 'MMM-YY') as ProjektStart_MonatJahr
    //  WirtschaftseinheitsID,  // already there in the CD Project-Table
   ;
  // Preceding load
  LOAD Distinct
  	 *,
     ApplyMap('map_CD_Projects_Phasen', _KEY_settings) as BauprojekteID_temp,
     ApplyMap('MappingCdProjectPhase', Phase) as Phase_temp,
     If(SubField(Phase, '_', -1)='5', '4.5', SubField(Phase, '_', -1)) as PhaseNum,
     Date(AblaufBaugarantie) as AblaufBaugarantie_temp,
     Date(BeginnBaugarantie) as BeginnBaugarantie_temp,
     Date(Ende) as CDProjectEndDate_temp,
     Date(Ende) as Ende_temp,
     Date(DatumGenehmigungPhase) as DatumGenehmigungPhase_temp,
     Date("Start") as CDProjectStartDate_temp,
     Date("Start") as Start_temp
     
 FROM [$(vSourcePath)DS_api_BauprojektePhasen.qvd]
 (qvd); 

  
  // Define a Valid From and Valid To Date for the CDP-Phasen
  LEFT JOIN (BauprojektePhasen_temp)
  LOAD Distinct
  	%BPPhaseId,
    PhaseStartDate as PhaseValidFrom,
    NewDate as PhaseValidTo
  ;
  // Preceding load
  LOAD Distinct
	*,
    Date(If(%BauprojekteID = Previous(%BauprojekteID), 
    	If(PhaseStartDate = Previous(PhaseStartDate), PhaseStartDate, Previous(PhaseStartDate)-1),
            	If(CDProjectEndDate<PhaseStartDate, PhaseStartDate, CDProjectEndDate))) as NewDate
  Resident BauprojektePhasen_temp
  WHERE Not IsNull(PhaseStartDate)
  ORDER BY %BauprojekteID, PhaseStartDate DESC;
  
  
 // Join the start date to CD-Projects
  LEFT JOIN (Bauprojekte_temp)
  LOAD Distinct
  		%BauprojekteID,
        CDProjectStartDate as AsOfDate,
        CDProjectStartDate as StartDatum,
        CDProjectEndDate as EndDatum
  Resident BauprojektePhasen_temp;
  
  
//   LEFT JOIN (Bauprojekte_temp2)
//   LOAD Distinct 
//       %BPPhaseId,
//       %BauprojekteID,
//       Aktiv,
//       AblaufBaugarantie,
//       BeginnBaugarantie,
//       DauerInMonaten,
//       CDProjectEndDate,
//       Ende, // legacy Field, deactivate later
//       CDProjectStartDate,
//       "Start", // legacy Field, deactivate later
//       Obligatorisch,
//       Phase,
//       Phase_TechName,
//       PhaseNum,
//       DatumGenehmigungPhase,
//       StatusGenehminungPhase,
//       PhaseStartDate,
//       ProjektStart_MonatJahr,
//       PhaseValidFrom,
//       PhaseValidTo
//   Resident BauprojektePhasen_temp;
//   Drop Table BauprojektePhasen_temp;
  
  End If
  
  If not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Checklisten.qvd')) Then
  
  NoConcatenate
  Checklisten_temp:
//  LEFT JOIN (Bauprojekte_temp2)
  LOAD Distinct
//     _KEY_content,
//     _KEY_root,
    DatumGenehmigt as Checklisten_DatumGenehmigt,
    Wahrheitswert as Checklisten_Wahrheitswert,
    Genehmigt as Checklisten_Genehmigt,
    Bemerkung as Checklisten_Bemerkung,
    StatusKreditgenehmigung as Checklisten_STatusKreditgenehmigung,
    Datum as Checklisten_Datum,
    Key as Checklisten_Key,
    Geldwert as Checklisten_Geldwert,
    Anteil as Checklisten_Anteil,
    Phase as Checklisten_Phase,
    Mietzinsanpassung as Checklisten_Mietzinsanpassung,
    "URL" as Checklisten_URL,
    BauprojektID as %BauprojekteID
//    WirtschaftseinheitsID
  FROM [$(vSourcePath)DS_api_Checklisten.qvd]
  (qvd);

  End if
  
  If not Isnull(QvdCreateTime('$(vSourcePath)DS_api_CDBauabrechnungen.qvd')) Then
  
  
  // *** Mapping
  Bauabrechnung_Mapping:
  Mapping Load * Inline [
   Key, Key_de
    WVB, WVB
    CONSTRUCTION_TRUST_ON_ACCOUNT_796, 'Baukreditzinsen Akonto (BKP 742)'
    CONSTRUCTION_TRUST_FINAL, 'Bautreuhand - Schlusszahlung'
    CONSTRUCTION_TRUST_EXTERNAL_SALARY_ON_ACCOUNT_797, 'Bautreuhand Ext. Honorar Akonto (BKP 797)'
  ];
    
   Bauabrechnungen_temp:
  
//  LEFT JOIN (Bauprojekte_temp2)
   NoConcatenate
  LOAD Distinct
//     _KEY_content,
//     _KEY_root,
    DatumGenehmigt as Bauabrechnungen_DatumGenehmigt,
    GenehmigtVon as Bauabrechnungen_GenehmigtVon,
    Wahrheitswert as Bauabrechnungen_Wahrheitswert,
    Bemerkung as Bauabrechnungen_Bemerkung,
    StatusKreditgenehmigung as Bauabrechnungen_StatusKreditgenehmigung,
    Datum as Bauabrechnungen_Datum,
    Key as Bauabrechnungen_Key,
    Geldwert as Bauabrechnungen_Geldwert,
    Anteil as Bauabrechnungen_Anteil,
    Phase as Bauabrechnungen_Phase,
    Mietzinsanpassung as Bauabrechnungen_Mietzinsanpassung,
    "URL" as Bauabrechnungen_URL,
    BauprojektID as %BauprojekteID,
//    WirtschaftseinheitsID,
    ApplyMap('Bauabrechnung_Mapping', Key) as Bauabrechnungen_Kennzahlen
  FROM [$(vSourcePath)DS_api_CDBauabrechnungen.qvd]
  (qvd);

  End If
  
  If not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Zahlungsplaene.qvd')) Then
  
  NoConcatenate
  Kostenvoranschlag10J_temp:
  LOAD Distinct
      SubField(_KEY_content,'$(vKeySep)',1) as %BauprojekteID,
      BudgetBetrag as Betrag,
      Jahr
  FROM [$(vSourcePath)DS_api_Zahlungsplaene.qvd]
  (qvd);
   
  End if;
  
  If not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Kostenvoranschlaege.qvd')) Then
  
  NoConcatenate
  Kostenvoranschlaege_temp:
  LOAD Distinct
      _KEY_costPositions,
      _KEY_root,
      Kommentar as KVKommentar,
      KostenvoranschlagAktuell,
      KVOriginal,
      BKP as BKP_orig,
      right(left(BKP,5),1) as BKP_orig_new,  //Added by nte 28.10.2022 
      SubField(BKP, '_' ,2) as BKP,
      Len(SubField(BKP, '_' ,2)) as BKPHierarchy,
      CrossEntry,
      Datum,
      Entry,
      Bezeichnung,
      BKPTyp,
      TotalKostenvoranschlagAktuell,
      TotalKVOriginal,
      Subtotal,
      Typ,
      BauprojektID as %BauprojekteID,
//      WirtschaftseinheitsID,
      Betrag as KVBetrag
  FROM [$(vSourcePath)DS_api_Kostenvoranschlaege.qvd]
  (qvd);
    
  End if;
  
    If not Isnull(QvdCreateTime('$(vSourcePath)DS_api_CDProjektControllings.qvd')) Then
  
    NoConcatenate
    ProjektControllings_temp:
    LOAD Distinct
//        WirtschaftseinheitsID,
        BauprojektID as %BauprojekteID,
        BemerkungRisiko,
        VersionJahr,
        VersionQuartal,
        VersionDate,
        Dual('Q' & Ceil(Month(VersionDate)/3) & '-' & Year(VersionDate),
         Year(VersionDate) & Ceil(Month(VersionDate)/3)) as VersionQuartalJahr,
        Rechnungsdatum,
        BetragVorhersage,
        ErwZahlungenbisEndeGJ,
        Kredit,
        OffenerKredit,
        BudgetUeberschreitung,
        Kostenschaetzung,
        SumVertraegeundAnhaenge,
        ZahlungenTotal,
        ZahlungenGJAktuell,
        BudgetGJAktuell,
        BemerkungVorhersage,
        AktuellerStand,
        VorhersageNaechtesQuartal,
  //       _KEY_content,
  //       _KEY_root,
        KategorieRisiko,
//         AuswirkungRisiko,
//         Wahrscheinlichkeit,
        AuswirkungRisiko_temp as AuswirkungRisiko, 		//nte
      	Wahrscheinlichkeit_temp as Wahrscheinlichkeit, //nte
        BeschreibungMassnahmen
    ;
    //Preceding load
    LOAD Distinct
      *,
      ApplyMap('MappingWahrscheinlichkeit',Wahrscheinlichkeit) as Wahrscheinlichkeit_temp,	  //nte
      ApplyMap('MappingAuswirkungRisiko',AuswirkungRisiko) as AuswirkungRisiko_temp,  		 //nte
      Makedate(VersionJahr, Num(Right(VersionQuartal,1)*3)) as VersionDate,
      Date(Rechnungsdatum) as Rechnungsdatum
    FROM [$(vSourcePath)DS_api_CDProjektControllings.qvd]
    (qvd);
    
  End if;

  If not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Kreditgesuche.qvd')) Then

    Kreditgesuche_temp:
      NoConcatenate
      LOAD Distinct
      //    _KEY_content,
      //    _KEY_root,
          Kommentar as KGKommentar,
          Kredit as KreditBetrag,
          ZahlungAktuell,
          KreditgesuchID as %KreditgesuchID,
          Investitionsantrag,
          Phase as KGPhase,
          BaukreditPhase_temp as BaukreditPhase,
          VoraussichtlicheGesamtinvestitionen,
          Status as KGStatus,
          BaukreditStatus_temp as BaukreditStatus,
          TotalGenehmigt,
          InvestitionsantragGesamt,
          Typ as KGTyp,
          BaukreditTyp_temp as BaukreditTyp,
          BauprojektID as %BauprojekteID
//          WirtschaftseinheitsID
      ;
      // Preceding load
      LOAD
        *,
        ApplyMap('MappingBaukreditStatus', Status, Null()) as BaukreditStatus_temp,
        ApplyMap('MappingBaukreditTyp', Typ, Null()) as BaukreditTyp_temp,
        ApplyMap('MappingBaukreditPhase', Phase, Null()) as BaukreditPhase_temp
      FROM [$(vSourcePath)DS_api_Kreditgesuche.qvd]
      (qvd);
      
    End If
    
    If not Isnull(QvdCreateTime('$(vSourcePath)DS_api_KreditgesucheGenehmigungen.qvd')) Then

    KreditgesucheGenehmigungen_temp:
      CrossTable(ChecklistEinheit, ChecklistWert, 3)
      LOAD Distinct
          GenehmigungsID as %KreditgesuchID,
          GenehmigungsPhase_temp as GenehmigungsPhase,
          Key_temp as ChecklistenGenehmigung,      
          Status_temp as StatusKreditgenehmigung,    
          GenehmigungsDatum_temp as GenehmigungsDatum,
          GenehmigtVonUser_temp as GenehmigtVonUser,
          Wahrheitswert,      
//           checked, // nicht vorhanden dkr 20.8.2022
          Bemerkung,
          Datumwert,
          Geldwert,
          Anteil as Anteilwert,
          Mietzinsanpassung,
          "Url" as UrlWert      
      ;
      // Preceding load
      LOAD Distinct
        *,
        ApplyMap('MappingBaukreditPhase', GenehmigungsPhase, Null()) as GenehmigungsPhase_temp,
        ApplyMap('MappingBaukreditChecklisten', Key, Null()) as Key_temp,
        ApplyMap('Map_Users', GenehmigtVonUser, Null()) as GenehmigtVonUser_temp,
        Date(Datum) as Datumwert,
        Date(GenehmigungsDatum) as GenehmigungsDatum_temp,
        If(StatusKreditgenehmigung='YES', 'Ja') as Status_temp
    FROM [$(vSourcePath)DS_api_KreditgesucheGenehmigungen.qvd]
    (qvd);

  End If

  
//   NoConcatenate
//   Bauprojekte_temp:
//   LOAD Distinct 
//   	 *,
//      If(Len(Trim(RefPFID))>0, RefPFID, 'All') & '$(vKeySep)' & WirtschaftseinheitsID & '$(vKeySep)' & %BauprojekteID & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & Num(CDProjectStartDate) as %FaktenKey,
// //     Hash128(If(Len(Trim(RefPFID))>0, RefPFID, 'All') & '$(vKeySep)' & WirtschaftseinheitsID & '$(vKeySep)' & %BauprojekteID & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & Num(CDProjectStartDate)) as %FaktenKey, //PF+WE+FactId+Sthold+MthYr+AsOfDate
// // 	 If(Len(Trim(RefPFID))>0, RefPFID, 'All') & '$(vKeySep)' & WirtschaftseinheitsID & '$(vKeySep)' & %BauprojekteID & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & Num(CDProjectStartDate) as RefFaktenKey,
// //     If(Len(Trim(RefPFID))>0, RefPFID, 'All') & '$(vKeySep)' & WirtschaftseinheitsID & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & %BauprojekteID & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & Num(CDProjectStartDate) as %FaktenKey,
//      CDProjectStartDate as AsOfDate,
//      CDProjectStartDate as StartDatum,
//      CDProjectEndDate as EndDatum
// //     WirtschaftseinheitsID & '$(vKeySep)' & Num(CDProjectStartDate) as %WEDateKey
// //     Num(CDProjectStartDate) as RefDateKey
//   Resident Bauprojekte_temp2;
//   DROP TABLE Bauprojekte_temp2;
  
//   DROP FIELD CDProjectStartDate FROM Bauprojekte_temp;


 //Added by nte 03.04.2022 
  LEFT JOIN (Kreditgesuche_temp)
	Load distinct
	%KreditgesuchID,
	date(max(ChecklistWert)) as MaxDatum
    
Resident KreditgesucheGenehmigungen_temp
where match(GenehmigungsPhase,'Portfolio-Management (PM)','Leiter Portfolio-Management (PM)') 
   	and match(ChecklistEinheit,'GenehmigungsDatum')
    group by %KreditgesuchID;


Temp:
Load distinct
	%BauprojekteID,
	date(max(MaxDatum)) as MaxDatumBP
Resident Kreditgesuche_temp
	where BaukreditStatus = 'Genehmigt'
    group by %BauprojekteID;


Left Join(Kreditgesuche_temp)
Load distinct
	%BauprojekteID,
    MaxDatumBP as MaxDatum,
    '1' as MaxDatumFlag
Resident Temp;

Drop Table Temp;



//Added by nte 28.10.2022 
  Left Join(Kreditgesuche_temp)
Load distinct
	%KreditgesuchID,
	date(Min((ChecklistWert))) as MinDatum
    
Resident KreditgesucheGenehmigungen_temp
	where match(ChecklistEinheit,'GenehmigungsDatum')
    group by %KreditgesuchID;


Temp_1:
Load distinct
	%BauprojekteID,
	date(max(MinDatum)) as MinDatumBP
Resident Kreditgesuche_temp
	where match(BaukreditStatus , 'Genehmigt')
    and match(BaukreditTyp , 'Ausführungskredit')
    group by %BauprojekteID;


Left Join(Kreditgesuche_temp)
Load distinct
	%BauprojekteID,
    MinDatumBP as MinDatum,
    '1' as MinDatumFlag
Resident Temp_1;

Drop Table Temp_1;




// Store QVD
Call QvdStore ('Bauprojekte_temp', '$(vStorePath)', 'RF_TR', 'Bauprojekte', '*', 1);

// Store QVD
// Call QvdStore ('BauprojekteKennwerte_temp', '$(vStorePath)', 'RF_TR', 'BauprojekteKennwerte', '*', 1);

// Store QVD
Call QvdStore ('BauprojektePhasen_temp', '$(vStorePath)', 'RF_TR', 'BauprojektePhasen', '*', 1);

// Store QVD
Call QvdStore ('Checklisten_temp', '$(vStorePath)', 'RF_TR', 'Checklisten', '*', 1);

// Store QVD
Call QvdStore ('Bauabrechnungen_temp', '$(vStorePath)', 'RF_TR', 'Bauabrechnungen', '*', 1);

// Store QVD
Call QvdStore ('Kostenvoranschlag10J_temp', '$(vStorePath)', 'RF_TR', 'Kostenvoranschlag10J', '*', 1);

// Store QVD
Call QvdStore ('Kostenvoranschlaege_temp', '$(vStorePath)', 'RF_TR', 'Kostenvoranschlaege', '*', 1);

// Store QVD
Call QvdStore ('ProjektControllings_temp', '$(vStorePath)', 'RF_TR', 'ProjektControllings', '*', 1);

// Store QVD
Call QvdStore ('Kreditgesuche_temp', '$(vStorePath)', 'RF_TR', 'Kreditgesuche', '*', 1);

// Store QVD
Call QvdStore ('KreditgesucheGenehmigungen_temp', '$(vStorePath)', 'RF_TR', 'KreditgesucheGenehmigungen', '*', 1);

End If

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_CDProj = (now() - vStartTime_CDProj)*86400;
Trace ---------------------------------- CD-Projekte geladen ----------------------------------;
Trace $(vElapsed_CDProj);
//********************************************************************************************


///$tab 3.2.2 Verträge (neu)
//********************************* Start Zeitmessung *********************************
// SET vStartTime_Vertraege = 0;
// Set vElapsed_Vertraege = 0;
Let vStartTime_Vertraege  = now();

//*************************************************************************************

If not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Vertraege.qvd')) Then

  Vertraege_temp:
  LOAD Distinct
      _KEY_content,
      _KEY_root,
      BetragBrutto,
      BetragNetto,
      NettobetragExklMWSt,
      BetragNettoGerundet,
      link_cdProject,
      Bemerkung,
      Vertragsform_temp as Vertragsform,
      Vertragstyp,
      BKP,
      Waehrung,
      Vergabedatum,
      Skonto,
      AblaufErfuellungsgarantie,
      ReferenzNr,
      %VertraegeID,
      %HauptvertraegeID,
      Bearbeitungsdatum,
      link_modifiedBy,
//       Zahlungsplan,
      link_paymentPlanModifiedBy,
      Rabatt,
      Status,
      SubUnternehmenID,
      BauprojektID as %BauprojekteID,
      WirtschaftseinheitsID,
      Mehrwertsteuer,
      UnternehmenID
   ;
   // Preceding load
   LOAD
   	  *,
      ApplyMap('MappingVertragsform',Vertragsform) as Vertragsform_temp,
      Pick(Match([Vertragstyp],'ORDER','ADDENDUM'),Id,Right(link_mainContract,7)) as %HauptvertraegeID,
      Id as %VertraegeID,
      Right(link_subVendors,7) as SubUnternehmenID,
      Right(link_vendor,7) as UnternehmenID
  FROM [$(vSourcePath)DS_api_Vertraege.qvd]
  (qvd);

  If not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Stakeholders.qvd')) Then
    LEFT JOIN (Vertraege_temp)
    LOAD Distinct
        StakeholderID as UnternehmenID,
        NameStakeholder as UnternehmenName,
        BasisURL as UnternehmenBasisURL,
        _KEY_root as Unternehmen_KEY_root,
    	ReferenzNrStakeholder as UnternehmenReferenzNrStakeholder,
    	ExterneID as UnternehmenExterneID,
    	Status as UnternehmenStatus,
    	Typ as UnternehmenTyp
    FROM [$(vSourcePath)DS_api_Stakeholders.qvd]
    (qvd)
    where Typ ='VENDOR'
      ;
      
	If not Isnull(QvdCreateTime('$(vSourcePath)DS_api_StakeholdersAdresse.qvd')) Then
      LEFT JOIN (Vertraege_temp)
      LOAD Distinct
          SubField(_KEY_root,'$(vKeySep)',1) as UnternehmenID,
          //_KEY_root,
          Adresse1 as UnternehmenAdresse1,
          Adresse2 as UnternehmenAdresse2,
          Land as UnternehmenLand,
          Ort as UnternehmenOrt,
          Kanton as UnternehmenKanton,
          PLZ as UnternehmenPLZ
      FROM [$(vSourcePath)DS_api_StakeholdersAdresse.qvd]
      (qvd);

	End if
  End if
 
 
 If not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Zahlungsplan.qvd')) Then
    Zahlungsplan_temp:
    LOAD Distinct
        _KEY_content,
        BauprojektID,
        Betrag,
        Kommentar,
        WeitererKommentar,
        Date([Datum],'MM.YYYY') as Datum,
        Aenderungsdatum,
        Status,
        WirtschaftseinheitsID
    FROM [$(vSourcePath)DS_api_Zahlungsplan.qvd]
    (qvd);

    LEFT JOIN (Zahlungsplan_temp)
    LOAD Distinct
        _KEY_content,
        %HauptvertraegeID
    Resident Vertraege_temp;
    

  If not Isnull(QvdCreateTime('$(vSourcePath)DS_api_SubUnternehmer.qvd')) Then
    NoConcatenate
    SubUnternehmen_temp:
    LOAD Distinct
        _KEY_content,
        Betrag,
        Right(link_stakeholder,7) as StakeholderID,
        Zahlungsdatum,
        BauprojektID,
        VertragsID as %VertraegeID,
        WirtschaftseinheitsID
    FROM [$(vSourcePath)DS_api_SubUnternehmer.qvd]
    (qvd);
  
    If not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Stakeholders.qvd')) Then
      LEFT JOIN (SubUnternehmen_temp)
      LOAD Distinct
          StakeholderID,
          NameStakeholder as Name,
          ApplyMap('MappingStakeholder',Status) as Status,
          ApplyMap('MappingStakeholder',Typ) as Typ
      FROM [$(vSourcePath)DS_api_Stakeholders.qvd]
      (qvd)
      where Typ ='VENDOR';
    End if
    
    If not Isnull(QvdCreateTime('$(vSourcePath)DS_api_StakeholdersAdresse.qvd')) Then
      LEFT JOIN (SubUnternehmen_temp)
      LOAD Distinct
          SubField(_KEY_root,'$(vKeySep)',1) as StakeholderID,
          //_KEY_root,
          Adresse1,
          Adresse2,
          Land,
          Ort,
          Kanton,
          PLZ
      FROM [$(vSourcePath)DS_api_StakeholdersAdresse.qvd]
      (qvd);
    End if
  
  // Store QVD
	Call QvdStore ('SubUnternehmen_temp', '$(vStorePath)', 'RF_TR', 'SubUnternehmen', '*', 1);
   
  End if;
  
  // Store QVD
	Call QvdStore ('Zahlungsplan_temp', '$(vStorePath)', 'RF_TR', 'Zahlungsplan', '*', 1);
  
 End if;

//lew
  
 If not Isnull(QvdCreateTime('$(vSourcePath)DS_api_ZahlungsplaeneBasis.qvd')) Then
  ZahlungsplaeneBasisFlach_temp:
    LOAD Distinct
      _KEY_content,
      _KEY_root,
      "Total",
      Erstellungsdatum,
      If(IsNull(Investitionsverzinsung),0,Investitionsverzinsung) as Investitionsverzinsung,
      Lebensdauer,
      Basismiete,
      MietzinserhöhungDurchsetzbar,
      ErfolgswirksamImJahr,
      Mietzinserhöhung,
      Status,
      BauprojektID as [%BauprojekteID],
      WirtschaftseinheitsID,
      If(IsNull(WVT),0,WVT) as WVA,
      Jahr as AuswahlJahr,
      Budgetrelevant,
      ExternerSchaetzungsexperte,
      BusinessPlan
  FROM [$(vSourcePath)DS_api_ZahlungsplaeneBasis.qvd]
  (qvd);
  
   If not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Zahlungsplaene.qvd')) Then
    LEFT JOIN (ZahlungsplaeneBasisFlach_temp)
    LOAD Distinct
      _KEY_content,
      BudgetBetrag as Wert,
      Jahr
    FROM [$(vSourcePath)DS_api_Zahlungsplaene.qvd]
   (qvd);
  
  End if;
   
   // Store QVD
	Call QvdStore ('ZahlungsplaeneBasisFlach_temp', '$(vStorePath)', 'RF_TR', 'ZahlungsplaeneBasisFlach', '*', 1);
   
 End if;

// Store QVD
 Call QvdStore ('Vertraege_temp', '$(vStorePath)', 'RF_TR', 'Vertraege', '*', 1);


End if

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_Vertraege = (now() - vStartTime_Vertraege)*86400;
Trace ---------------------------------- Vertraege geladen ----------------------------------;
Trace $(vElapsed_Vertraege);
//********************************************************************************************

///$tab 3.2.3 Zahlungen (neu)
//********************************* Start Zeitmessung *********************************
// SET vStartTime_Zahlungen = 0;
// Set vElapsed_Zahlungen = 0;
Let vStartTime_Zahlungen  = now();

//*************************************************************************************

  If not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Zahlungen.qvd')) Then
  
  Zahlungen_temp:  
  LOAD Distinct
      %ZahlungenID,
  //    _KEY_root,
      KontoReferenzNr,
      Kontonummer,
      Kontotyp,
  //    approvedBy_Link,
      Buchungskommentar,
      Buchungsdatum_temp as Buchungsdatum,
  //    contract_Link,
      Waehrung,
  //    dataBox_Link,
      Dokumentpfad,
      AbacusInbox,
      ReferenzNr,
      ReferenzNr2,
      DatumAbschluss_temp as DatumAbschluss,
      BetragBrutto,
//      Id,
      Rechnugsdatum_temp as Rechnugsdatum,
      Zahlungsstatus,
      Typ,
  //    secondApprovedBy_Link,
      VorgeschlagenesKontoExterneID,
      VorgeschlageneExterneAnbietererkennung,
      Rechnungstyp,
      ExternerLieferant,
      VertraegeID,
      BauprojekteID,
      WirtschaftseinheitsID,
      PortfolioID,
      approvedBy,
      approvedByName,
      secondApprovedBy,
      secondApprovedByName,
//      If(Len(Trim(PortfolioID))>0, PortfolioID, 'All') & '$(vKeySep)' & WirtschaftseinheitsID & '$(vKeySep)' & %ZahlungenID & '$(vKeySep)' & VertraegeID & '$(vKeySep)' & BauprojekteID & '$(vKeySep)' & Num(Buchungsdatum_temp) as %FaktenKey
  ;
  // Preceding load
  LOAD
      *,
      Date(Buchungsdatum) as Buchungsdatum_temp,
      Date(DatumAbschluss) as DatumAbschluss_temp,
      Date(Rechnugsdatum) as Rechnugsdatum_temp,
      ApplyMap('Map_WE_to_Portfolio', WirtschaftseinheitsID, Null()) as PortfolioID,
      ApplyMap('Map_Users', approvedBy, Null()) as approvedByName,
      ApplyMap('Map_Users', secondApprovedBy, Null()) as secondApprovedByName
  ;
  // Preceding load
  LOAD
      *,
        Id as %ZahlungenID,
        Right(contract_Link,7) as VertraegeID,
        SubField(contract_Link, '/', -3) as BauprojekteID,
        SubField(contract_Link, '/', -5) as WirtschaftseinheitsID,
        SubField(approvedBy_Link, '/', -1) as approvedBy,
        SubField(secondApprovedBy_Link, '/', -1) as secondApprovedBy

  FROM [$(vSourcePath)DS_api_Zahlungen.qvd]
  (qvd);
  
  If not Isnull(QvdCreateTime('$(vStorePath)RF_TR-Vertraege.qvd')) Then
  
    LEFT JOIN (Zahlungen_temp)
	LOAD Distinct
      %VertraegeID as VertraegeID,
      %HauptvertraegeID as HauptvertraegeID,
      UnternehmenID,
      BKP,
      SubUnternehmenID,
      UnternehmenName,
      UnternehmenBasisURL,
      Unternehmen_KEY_root,
      UnternehmenReferenzNrStakeholder,
      UnternehmenExterneID,
      UnternehmenStatus,
      UnternehmenTyp,
      UnternehmenAdresse1,
      UnternehmenAdresse2,
      UnternehmenLand,
      UnternehmenOrt,
      UnternehmenKanton,
      UnternehmenPLZ
//	Resident Vertraege_temp;
	FROM [$(vStorePath)RF_TR-Vertraege.QVD]
	(qvd);

//	END IF

  If not Isnull(QvdCreateTime('$(vSourcePath)DS_api_ZahlungenFreigabe.qvd')) Then
  
  LEFT JOIN (Zahlungen_temp)
  LOAD Distinct
      SubField(_KEY_root,'$(vKeySep)',1) as %ZahlungenID,
      Date(DatumGenehmigung) as DatumGenehmigung,
      BereitFuerGenehmigung,
      ZweitVisumGenehmigt,
      Date(ZweitVisumDatum) as ZweitVisumDatum
  FROM [$(vSourcePath)DS_api_ZahlungenFreigabe.qvd]
  (qvd);

  END IF

  If not Isnull(QvdCreateTime('$(vStorePath)RF_TR-Bauprojekte.qvd')) Then
  
  LEFT JOIN (Zahlungen_temp)
  LOAD Distinct
  	%BauprojekteID as BauprojekteID,
    StartDatum as CDPStartDate,
    EndDatum as CDPEndDate
  
  FROM [$(vStorePath)RF_TR-Bauprojekte.qvd]
  (qvd);	
  
  End if
  
  If not Isnull(QvdCreateTime('$(vSourcePath)DS_api_ZahlungenMWSt.qvd')) Then
  
  ZahlungenMWSt_temp:
  LOAD Distinct
      SubField(_KEY_root,'$(vKeySep)',1) as %ZahlungenID,
      BetragBrutto as RefBetragBrutto,
      "Rate",
      Steuerbetrag
  FROM [$(vSourcePath)DS_api_ZahlungenMWSt.qvd]
  (qvd);
  
 
  LEFT JOIN (Zahlungen_temp)
  LOAD Distinct
  	%ZahlungenID,
    "Rate",
    Steuerbetrag
    
  Resident ZahlungenMWSt_temp;
  DROP TABLE ZahlungenMWSt_temp;

  // Store QVD
 //  Call QvdStore ('ZahlungenMWSt_temp', '$(vStorePath)', 'temp', 'ZahlungenMWSt', '*', 1);

  End if
  
  Zahlungen_temp_neu:
  NoConcatenate
  LOAD Distinct
  	*,
    If(Len(Trim(PortfolioID))>0, PortfolioID, 'All') & '$(vKeySep)' & WirtschaftseinheitsID & '$(vKeySep)' & %ZahlungenID & '$(vKeySep)' & VertraegeID & '$(vKeySep)' & BauprojekteID & '$(vKeySep)' & 
     If(Len(Trim(Buchungsdatum))>0, Num(Buchungsdatum), Num(CDPStartDate)) as %FaktenKey
  Resident Zahlungen_temp;
  DROP TABLE Zahlungen_temp;
  RENAME TABLE Zahlungen_temp_neu TO Zahlungen_temp;
  
    // Store QVD
   Call QvdStore ('Zahlungen_temp', '$(vStorePath)', 'RF_TR', 'Zahlungen', '*', 1);
  
  END IF

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_Zahlungen = (now() - vStartTime_Zahlungen)*86400;
Trace ---------------------------------- Zahlungen geladen ----------------------------------;
Trace $(vElapsed_Zahlungen);
//********************************************************************************************
  
///$tab 3.2.4 InvestmentPlanning
//********************************* Start Zeitmessung *********************************
// SET vStartTime_InvPlan = 0;
// Set vElapsed_InvPlan = 0;
Let vStartTime_InvPlan  = now();

//*************************************************************************************

If not Isnull(QvdCreateTime('$(vSourcePath)DS_api_ZahlungsplaeneBasis.qvd')) Then

// Erweiterung ZhalungsplaeneBasis - Umstellung an CrossTab
ZahlungsplaeneBasis_temp5:
NoConcatenate
LOAD Distinct
  _KEY_content,
  _KEY_root,
  Projekttotal,
  Erstellungsdatum,
  Investitionsverzinsung_temp as Investitionsverzinsung,
  Lebensdauer,
  Basismiete,
  MietzinserhöhungDurchsetzbar,
  ErfolgswirksamImJahr,
  Mietzinserhöhung,
  Status,
  %BauprojekteID,
  %Key_Investitionsplanung,
  WVA,
  Planjahr,
  Budgetrelevant,
  ExternerSchaetzungsexperte,
  BusinessPlan
;
// Preceding load
LOAD
	*,
    if(isnull(WVT),0,WVT) as WVA,
    if(isnull(Investitionsverzinsung),0,Investitionsverzinsung) as Investitionsverzinsung_temp,
    BauprojektID as %BauprojekteID,
    "Total" as Projekttotal,
    Jahr as Planjahr,
    WirtschaftseinheitsID & '$(vKeySep)' & Jahr as %Key_Investitionsplanung
FROM [$(vSourcePath)DS_api_ZahlungsplaeneBasis.qvd]
(qvd);

LEFT JOIN (ZahlungsplaeneBasis_temp5)
LOAD Distinct
  _KEY_content,
  BudgetBetrag as Betrag,
  ActualBetrag as AbrechnungBetrag,
  Jahr
FROM [$(vSourcePath)DS_api_Zahlungsplaene.qvd]
(qvd);

 
ZahlungsplaeneBasis_temp4:
NoConcatenate
Load Distinct
  %BauprojekteID,
  %Key_Investitionsplanung,
  Planjahr,
  Jahr,
  ErfolgswirksamImJahr,
  %BauprojekteID & '$(vKeySep)' & Jahr & '$(vKeySep)' & Planjahr as %key_tmp,
  Sum(Betrag) as Cashout,
  Sum((1-WVA)*Betrag) as Erfolgswirksam,
  Sum(AbrechnungBetrag) as CashoutAbrechnung,
  Sum((1-WVA)*AbrechnungBetrag) as ErfolgswirksamAbrechnung,
  If(Jahr=ErfolgswirksamImJahr, Sum(Projekttotal*Investitionsverzinsung*WVA),0) as Mehrertrag
Resident ZahlungsplaeneBasis_temp5
GROUP BY [%BauprojekteID],%Key_Investitionsplanung,Planjahr,Jahr,ErfolgswirksamImJahr;

ZahlungsplaeneBasis_temp3:
NoConcatenate
LOAD  Distinct
	*,
    %BauprojekteID & '$(vKeySep)' & Jahr & '$(vKeySep)' & Planjahr as %key_tmp
Resident ZahlungsplaeneBasis_temp5;
DROP TABLE ZahlungsplaeneBasis_temp5;

LEFT JOIN (ZahlungsplaeneBasis_temp3)
LOAD Distinct
  %key_tmp,
  Erfolgswirksam,
  ErfolgswirksamAbrechnung,
  Mehrertrag,
  Cashout,
  CashoutAbrechnung,
  Erfolgswirksam-Mehrertrag as [Bereinigte Erfolgswirksam],
  ErfolgswirksamAbrechnung-Mehrertrag as [Bereinigte ErfolgswirksamAbrechnung]
Resident ZahlungsplaeneBasis_temp4;
DROP TABLE ZahlungsplaeneBasis_temp4;


ZahlungsplaeneBasis_temp2:
Crosstable(KPI,Wert,15)
LOAD Distinct
  %BauprojekteID,
  %Key_Investitionsplanung,
  WVA,
  Planjahr,
  Status,
  Mietzinserhöhung,
  ErfolgswirksamImJahr,
  Lebensdauer,
  Basismiete,
  MietzinserhöhungDurchsetzbar,
  Budgetrelevant,
  ExternerSchaetzungsexperte,
  BusinessPlan,
  Investitionsverzinsung,
  Jahr,
  Erfolgswirksam,
  ErfolgswirksamAbrechnung,
  Mehrertrag,
  Cashout,
  CashoutAbrechnung,
  [Bereinigte Erfolgswirksam],
  [Bereinigte ErfolgswirksamAbrechnung]
Resident ZahlungsplaeneBasis_temp3;
DROP TABLE ZahlungsplaeneBasis_temp3;

ZahlungsplaeneBasis_temp:
NoConcatenate
LOAD Distinct
  %BauprojekteID,
  %Key_Investitionsplanung,
  WVA,
  Planjahr,
  Status,
  Mietzinserhöhung,
  ErfolgswirksamImJahr,
  Lebensdauer,
  Basismiete,
  MietzinserhöhungDurchsetzbar,
  Budgetrelevant,
  ExternerSchaetzungsexperte,
  BusinessPlan,
  Investitionsverzinsung,
  Jahr,
  ApplyMap('MappingSortierungKPI',KPI) as SortierungKPI,
  KPI,
  Wert
Resident ZahlungsplaeneBasis_temp2;
DROP TABLE ZahlungsplaeneBasis_temp2;

// Store QVD
Call QvdStore ('ZahlungsplaeneBasis_temp', '$(vStorePath)', 'RF_TR', 'ZahlungsplaeneBasis', '*', 1);

END IF

If not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Investitionsplanung.qvd')) Then

//Instandsetzungen Nominalwerte filtern:
Temp:
NoConcatenate
LOAD Distinct
	_KEY_dcfAccount,
    _KEY_value,
    BewertungsID as %BewertungsID,
    year(Bewertungsstichtag) as Bewertungsstichjahr,
;
// Preceding load
LOAD
    *,
    ApplyMap('Map_BewStichtag_to_BewID', BewertungsID, null()) as Bewertungsstichtag
;
// Preceding load
LOAD
	*,
    left(_KEY_value, 11) as BewertungsID
FROM [$(vSourcePath)DS_api_KontoDCF.qvd]
(qvd);


FOR i=1 TO $(nPeriods)
LET j = $(i); 

left join(Temp)
LOAD Distinct
	[_KEY_dcfAccount],
	[Periode$(i)Nominal] as Periode$(j)
FROM [$(vSourcePath)DS_api_Periode$(j).qvd]
(qvd);

NEXT;

left join(Temp)
LOAD Distinct
    _KEY_value,
    KontoNameKonto
FROM [$(vSourcePath)DS_api_StandardKonti.qvd]
(qvd);


left join(Temp)
LOAD Distinct
    BewertungsID as %BewertungsID,
    BewFinal
//RESIDENT Bewertung_Dimension;
FROM [$(vStorePath)RF_MD-Bewertung.qvd] (qvd);



For vJahr=2019 to 2023;

let vJahr1=$(vJahr)+1;
let vJahr2=$(vJahr)+2;
let vJahr3=$(vJahr)+3;
let vJahr4=$(vJahr)+4;
let vJahr5=$(vJahr)+5;
let vJahr6=$(vJahr)+6;
let vJahr7=$(vJahr)+7;
let vJahr8=$(vJahr)+8;
let vJahr9=$(vJahr)+9;

Instandsetzungen:
Crosstable(Jahr,Instandsetzung,2)
Load Distinct
	subfield([%BewertungsID],'-',1) &'-'& subfield([%BewertungsID],'-',2) & '$(vKeySep)' & $(vJahr) as %Key_Investitionsplanung,
    $(vJahr) as Planjahr,
    Periode1 as $(vJahr),
    Periode2 as $(vJahr1),
    Periode3 as $(vJahr2),
    Periode4 as $(vJahr3),
    Periode5 as $(vJahr4),
    Periode6 as $(vJahr5),
    Periode7 as $(vJahr6),
    Periode8 as $(vJahr7),
    Periode9 as $(vJahr8),
    Periode10 as $(vJahr9)
    
resident Temp
where BewFinal=1 and KontoNameKonto='COSTS_CAPITAL-EXPENDITURE' and Bewertungsstichjahr=$(vJahr); //aktive Instandsetzungen

Next


drop table Temp;


Investitionsplanung_temp:
Load Distinct
*
FROM [$(vSourcePath)DS_api_Investitionsplanung.qvd]
(qvd);


For vJahr=2020 to 2023;

let vJahr1=$(vJahr)+1;
let vJahr2=$(vJahr)+2;
let vJahr3=$(vJahr)+3;
let vJahr4=$(vJahr)+4;
let vJahr5=$(vJahr)+5;
let vJahr6=$(vJahr)+6;
let vJahr7=$(vJahr)+7;
let vJahr8=$(vJahr)+8;
let vJahr9=$(vJahr)+9;

Investitionsplanung_temp2:
CrossTable(Jahr, Wert, 7)
LOAD Distinct
    Kommentar,
    zuletztBearbeitet,
    zuletztBearbeitetVon,
    VersionID,
    Status,
    WirtschaftseinheitsID & '$(vKeySep)' & Jahr as %Key_Investitionsplanung,
    $(vJahr) as Planjahr,
    Periode1 as $(vJahr),
    Periode2 as $(vJahr1),
    Periode3 as $(vJahr2),
    Periode4 as $(vJahr3),
    Periode5 as $(vJahr4),
    Periode6 as $(vJahr5),
    Periode7 as $(vJahr6),
    Periode8 as $(vJahr7),
    Periode9 as $(vJahr8),
    Periode10 as $(vJahr9)
Resident Investitionsplanung_temp
where Jahr=$(vJahr);

Next
DROP TABLE Investitionsplanung_temp;



LEFT JOIN (Investitionsplanung_temp2)
LOAD Distinct
    "UserID" as zuletztBearbeitetVon,
    Vorname & ' ' & Nachname as AenderungDurch
FROM [$(vSourcePath)DS_api_User.qvd]
(qvd);

DROP FIELD zuletztBearbeitetVon FROM Investitionsplanung_temp2;

left join(Investitionsplanung_temp2)
Load Distinct
    *
resident Instandsetzungen;
drop Table Instandsetzungen;

Investitionsplanung_temp3:
NoConcatenate
LOAD Distinct
	WirtschaftseinheitsID,
    RefPFID,
    BewertungsID as %BewertungsID  // BewId mitgeben
    
//    AsOfDate
//    WirtschaftseinheitsID & '$(vKeySep)' & Num(AsOfDate) as %WEDateKey
;
// Preceding load
LOAD
	*,
	ApplyMap('Map_WE_to_Portfolio', WirtschaftseinheitsID, null()) as RefPFID
;
// Preceding load
LOAD
    *,
    Left(BewertungsID, 7) as WirtschaftseinheitsID
     //   Bewertungsstichtag as AsOfDate,
//    Left(%BewertungsID, 7) as WirtschaftseinheitsID
//Resident Bewertungen_Fakten;
FROM [$(vStorePath)RF_MD-Bewertung.qvd] (qvd);

INNER JOIN (Investitionsplanung_temp3)
LOAD Distinct
	BewertungsID as %BewertungsID
//Resident Bewertung_Dimension
FROM [$(vStorePath)RF_MD-Bewertung.qvd] (qvd)
WHERE Match(BewFinal, '1')>0;


LEFT JOIN (Investitionsplanung_temp3)
LOAD Distinct
    *,
    SubField(%Key_Investitionsplanung,'$(vKeySep)',1) as WirtschaftseinheitsID
Resident Investitionsplanung_temp2;
DROP TABLE Investitionsplanung_temp2;
DROP FIELD %Key_Investitionsplanung;

Investitionsplanung_temp4:
NoConcatenate
LOAD Distinct
    *,
	If(Len(Trim(RefPFID))>0, RefPFID, 'All') & '$(vKeySep)' & WirtschaftseinheitsID & '$(vKeySep)' & VersionID & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & Num(Date(Makedate(Planjahr, 1))) as FaktenKey_temp,
//   Hash128(If(Len(Trim(RefPFID))>0, RefPFID, 'All') & '$(vKeySep)' & WirtschaftseinheitsID & '$(vKeySep)' & VersionID & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & Num(Date(Makedate(Planjahr, 1)))) as %FaktenKey,  //PF+WE+FactId+Sthold+MthYr+AsOfDate
//	If(Len(Trim(RefPFID))>0, RefPFID, 'All') & '$(vKeySep)' & WirtschaftseinheitsID & '$(vKeySep)' & VersionID & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & Num(Date(Makedate(Planjahr, 1))) as RefFaktenKey,
//    If(Len(Trim(RefPFID))>0, RefPFID, 'All') & '$(vKeySep)' & WirtschaftseinheitsID & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & VersionID & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & Num(Date(Makedate(Planjahr, 1))) as %FaktenKey,
//     If(IsNull(Planjahr_tmp),'2022',Planjahr_tmp) as Planjahr,
    Date(Makedate(Planjahr, 1)) as PlanStartDate,
    YearEnd(Date(Makedate(Planjahr, 12))) as PlanEndDate

Resident Investitionsplanung_temp3
WHERE Len(Trim(VersionID))>0;

// DROP FIELD Planjahr_tmp;
DROP TABLE Investitionsplanung_temp3;

Investitionsplanung_temp:
NoConcatenate
LOAD Distinct
	WirtschaftseinheitsID,
    RefPFID,
    %BewertungsID as BewertungsID,
    Kommentar,
    zuletztBearbeitet,
    Instandsetzung,
    VersionID,
    Status,
    Jahr,
    Wert,
    AenderungDurch,
    FaktenKey_temp as %FaktenKey,
//    Hash128(FaktenKey_temp) as %FaktenKey,
//    FaktenKey_temp as RefFaktenKey,
    Planjahr,
    Date(Floor(MonthStart(PlanStartDate))) as InvPlanValidFrom,
    Date(Floor(MonthEnd(NewDate))) as InvPlanValidTo
;
// Preceding load
LOAD
	*,
    Date(If(WirtschaftseinheitsID = Previous(WirtschaftseinheitsID), If(PlanStartDate < Previous(PlanStartDate), Previous(PlanEndDate)-1), PlanEndDate)) as NewDate
Resident Investitionsplanung_temp4
ORDER BY WirtschaftseinheitsID, PlanStartDate DESC;
DROP TABLE Investitionsplanung_temp4;

// Store QVD
Call QvdStore ('Investitionsplanung_temp', '$(vStorePath)', 'RF_TR', 'Investitionsplanung', '*', 1);

END IF

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_InvPlan = (now() - vStartTime_InvPlan)*86400;
Trace ---------------------------------- Investitionsplanungen geladen ----------------------------------;
Trace $(vElapsed_InvPlan);
//********************************************************************************************

///$tab 3.2.5 (temp) InvestmentPlanningWE
//********************************* Start Zeitmessung *********************************
// SET vStartTime_InvPlanWE = 0;
// Set vElapsed_InvPlanWE = 0;
Let vStartTime_InvPlanWE  = now();

//*************************************************************************************

If not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Investitionsplanung.qvd')) Then

Investitionsplanung_temp1:
Load Distinct
    Jahr as Planjahr,
    Kommentar,
    Periode10,
    Periode1,
    Periode2,
    Periode3,
    Periode4,
    Periode5,
    Periode6,
    Periode7,
    Periode8,
    Periode9,
    Status,
    TotalProJahr,
    VersionID,
    WirtschaftseinheitsID as %WirtschaftseinheitNr,
    zuletztBearbeitetVon,
    zuletztBearbeitet
FROM [$(vSourcePath)DS_api_Investitionsplanung.qvd]
(qvd);

Investitionsplanung_latest:
Mapping LOAD
	%WirtschaftseinheitNr,
    Max(Planjahr) as MaxPlanjahr

Resident Investitionsplanung_temp1
GROUP BY %WirtschaftseinheitNr;

Investitionsplanung_temp2:
NoConcatenate
Load *,
    If(Num(Planjahr) = ApplyMap('Investitionsplanung_latest', %WirtschaftseinheitNr), '1', '0') as Investitionsplanung_LatestFlag
Resident Investitionsplanung_temp1;
DROP TABLE Investitionsplanung_temp1;

// Store QVD
Call QvdStore ('Investitionsplanung_temp2', '$(vStorePath)', 'RF_TR', 'Investitionsplanung_orig', '*', 1);

END IF

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_InvPlanWE = (now() - vStartTime_InvPlanWE)*86400;
Trace ---------------------------------- Investitionsplanungen orig geladen ----------------------------------;
Trace $(vElapsed_InvPlanWE);
//********************************************************************************************

///$tab Ende Bauprojekte 3.2 <
//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_Bauprojekte = (now() - vStartTime_Bauprojekte)*86400;
Trace ---------------------------------- Bauprojekte geladen ----------------------------------;
Trace $(vElapsed_Bauprojekte);
//********************************************************************************************

///$tab > 3.3 Darlehen
//********************************* Start Zeitmessung *********************************
// SET vStartTime_Darlehen = 0;
// Set vElapsed_Darlehen = 0;
Let vStartTime_Darlehen  = now();

//*************************************************************************************
///$tab 3.3.1 Hypotheken
//********************************* Start Zeitmessung *********************************
// SET vStartTime_Hypo = 0;
// Set vElapsed_Hypo = 0;
Let vStartTime_Hypo  = now();

//*************************************************************************************

// Hypotheken und Rahmenkredite

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Hypotheken.qvd')) Then

Hypotheken_temp3:
NoConcatenate
LOAD Distinct
 	PFID_temp & '$(vKeySep)' & Num(Vertragsdatum_temp) as %PFDateKey,
    BasisURL,
//    NamePortfolio,
    IDKreditorFonds,
    RahmenkreditID,
    Liegenschafts_ID_WP,
    StakeholderID,
    HypothekID,
//    Eigentümer as Eigentuemer,
    Vertragsdatum_temp as Vertragsdatum,
    StartDatum_temp as StartDatum,
    Fälligkeit_temp as Faelligkeit,
    Vertragsdatum_temp as AsOfDate,
    PFID_temp as PFID,
//    _KEY_root,
    Betrag as origBetrag,
    Betrag_temp as Betrag,
    Waehrung,
    CHF_Currency,
    Zinsberechnungsmethode_temp as Zinsberechnungsmethode,
    ReferenzNrHypothek,
    Zinsfälligkeit_temp as Zinsfaelligkeit,
    Zins,
    Zinsmodell_temp as Zinsmodell,
    Hypothekenstatus_temp as Hypothekenstatus,
    Kündigungstermin_temp as Kuendigungstermin,
    KündigungsfristTage as KuendigungsfristTage,
    Objektstatus_temp as Objektstatus,
    HypothekTyp,
    RefRKLimit
;
// Preceding load
LOAD Distinct
	*,
    Typ_temp as HypothekTyp,
    if (len(trim(CHF_Currency_tmp)) = 0,1, CHF_Currency_tmp) as CHF_Currency,
	if (len(trim(Waehrung_tmp)) = 0,'CHF', Waehrung_tmp) as Waehrung,
    If(Not IsNull(Vertragsdatum_temp2),Vertragsdatum_temp2, StartDatum_temp) as Vertragsdatum_temp,
    Evaluate(Betrag) as Betrag_temp,
    RahmenkreditID & '$(vKeySep)' & PFID_temp as RefRKLimit,
;
// Preceding load
LOAD Distinct
	*,
    Währung as Waehrung_tmp,
    Date($(vFormatDate(Vertragsdatum))) as Vertragsdatum_temp2,
    Date($(vFormatDate(StartDatum))) as StartDatum_temp,
    Date($(vFormatDate(Fälligkeit))) as Fälligkeit_temp,
    Date($(vFormatDate(Kündigungstermin))) as Kündigungstermin_temp,
	ApplyMap('MappingHypothek',Zinsberechnungsmethode, null()) as Zinsberechnungsmethode_temp,
    ApplyMap('MappingHypothek',Zinsfälligkeit, null()) as Zinsfälligkeit_temp,
    ApplyMap('MappingHypothek',Zinsmodell, null()) as Zinsmodell_temp,
    ApplyMap('MappingHypothek',Objektstatus, null()) as Objektstatus_temp,
    ApplyMap('MappingHypothek',Hypothekenstatus, null()) as Hypothekenstatus_temp,
    ApplyMap('MappingHypothek',Typ, null()) as Typ_temp,
    ApplyMap('Map_Currency', Währung, null()) as CHF_Currency_tmp,
    If(Len(PFID)=0, ApplyMap('Map_WE_to_Portfolio', Liegenschafts_ID_WP, null()), PFID) as PFID_temp  
    
FROM [$(vSourcePath)DS_api_Hypotheken.qvd]
(qvd);

LEFT JOIN(Hypotheken_temp3)
LOAD Distinct
    PFID,
    sum(Betrag) as FundTotal
FROM [$(vSourcePath)DS_api_Hypotheken.qvd]
(qvd)
GROUP BY PFID;

// Füge PFName & Eigentuemer hinzu
IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Portfolios.qvd')) Then

LEFT JOIN (Hypotheken_temp3)
LOAD Distinct
	PortfolioId as PFID,
    Name as NamePortfolio,
    Eigentuemer as Eigentuemer
FROM [$(vSourcePath)DS_api_Portfolios.qvd] 
(qvd);

LEFT JOIN (Hypotheken_temp3)
LOAD Distinct
	PortfolioId as IDKreditorFonds,
    Name as KreditorFonds
FROM [$(vSourcePath)DS_api_Portfolios.qvd]
(qvd);

ELSE

LEFT JOIN(Hypotheken_temp3)
LOAD * Inline [
PFID, NamePortfolio, Eigentuemer
];

LEFT JOIN(Hypotheken_temp3)
LOAD * Inline [
IDKreditorFonds, KreditorFonds
];

END If

// Füge Kreditgeber hinzu
IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Stakeholders.qvd')) Then

LEFT JOIN(Hypotheken_temp3)
LOAD Distinct
	StakeholderID,
    NameStakeholder as Kreditgeber_tmp
FROM [$(vSourcePath)DS_api_Stakeholders.qvd]
(qvd);

ELSE

LEFT JOIN(Hypotheken_temp3)
LOAD * Inline [
StakeholderID, Kreditgeber_tmp
];

End If

// Füge Rahmenkredite hinzu
IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_RahmenkreditLimiten.qvd')) Then

LEFT JOIN (Hypotheken_temp3)
LOAD Distinct
    RahmenkreditID & '$(vKeySep)' & RahmenkreditPFID as RefRKLimit,
    RahmenkreditLimite
FROM [$(vSourcePath)DS_api_RahmenkreditLimiten.qvd]
(qvd);


Hypotheken_temp2:
NoConcatenate
LOAD Distinct
	*,
	Num(Betrag * CHF_Currency) as Betrag_CHF,
    RahmenkreditLimite * CHF_Currency as RahmenkreditLimite_CHF,
	Round(Restlaufzeit * Betrag / FundTotal) as RestlaufzeitKapitalgewichtet,
    Year([Faelligkeit]) as FaelligkeitsJahr,
    If(Not IsNull(Kreditgeber_tmp),Kreditgeber_tmp, If(Not IsNull(KreditorFonds),KreditorFonds)) as Kreditgeber
;
// Preceding load
LOAD
	*,
    If(Faelligkeit>date(today(),'YYYY-MM-DD'), Num(Interval(Faelligkeit-date(today(),'YYYY-MM-DD'), 'DD')), 0) as Restlaufzeit
Resident Hypotheken_temp3;
DROP TABLE Hypotheken_temp3;

ELSE

Hypotheken_temp2:
NoConcatenate
LOAD Distinct
	*,
	Num(Betrag * CHF_Currency) as Betrag_CHF,
    '' as RahmenkreditLimite_CHF,
	Round(Restlaufzeit * Betrag / FundTotal) as RestlaufzeitKapitalgewichtet,
    Year([Faelligkeit]) as FaelligkeitsJahr,
    If(Not IsNull(Kreditgeber_tmp),Kreditgeber_tmp, If(Not IsNull(KreditorFonds),KreditorFonds)) as Kreditgeber
;
// Preceding load
LOAD
	*,
    If(Faelligkeit>date(today(),'YYYY-MM-DD'), Num(Interval(Faelligkeit-date(today(),'YYYY-MM-DD'), 'DD')), 0) as Restlaufzeit
Resident Hypotheken_temp3;
DROP TABLE Hypotheken_temp3;

END IF

Hypotheken_temp:
NoConcatenate
LOAD Distinct
//	%PFDateKey,			// no PF+Date Link, instead FactKey
	FaktenKey_temp as %FaktenKey,
//   Hash128(FaktenKey_temp) as %FaktenKey,
//    FaktenKey_temp as RefFaktenKey,
    HypothekID as %HypothekID,
    Eigentuemer,
    ReferenzNrHypothek,
    PFID,
    NamePortfolio,
    Liegenschafts_ID_WP,
    Vertragsdatum,
    StartDatum,
    Faelligkeit,
    AsOfDate,
    Hypothekenstatus,
    Kuendigungstermin,
    KuendigungsfristTage,
    Objektstatus,
    HypothekTyp,
    BasisURL,
    StakeholderID,
    IDKreditorFonds,
    Kreditgeber,
	FaelligkeitsJahr,
    Restlaufzeit,
    origBetrag,
    Betrag,
    Waehrung,
    CHF_Currency,
    Betrag_CHF,
    Zinsberechnungsmethode,  
    Zinsfaelligkeit,
    Zins,
    Zinsmodell,
	FundTotal,	
    RestlaufzeitKapitalgewichtet,
    RahmenkreditID,
    RIGHT([HypothekID],3) &' $(vKeySep) '& ReferenzNrHypothek as ReferenzNrHypo,
    RIGHT([HypothekID],3) &' $(vKeySep) '& Kreditgeber as HypoNrKreditgeber,
//    RIGHT([RahmenkreditID],3) &' $(vKeySep) '& ReferenzNrHypothek as ReferenzNrRahmenkredit,
//	RahmenkreditLimite,
    RahmenkreditLimite_CHF,
    BetragohneRK_CHF,
    If(Betrag_CHF > RahmenkreditLimite_CHF, 0, RahmenkreditLimite_CHF - If(IsNull(Betrag_CHF), 0 , Betrag_CHF)) as BetragLimite_Offen_CHF
;
// Preceding load
LOAD Distinct
	*,
    If(Len(Trim(PFID))>0, PFID, 'All') & '$(vKeySep)' & If(Len(Trim(Liegenschafts_ID_WP))>0, Liegenschafts_ID_WP, 'All') & '$(vKeySep)' & HypothekID & '$(vKeySep)' & StakeholderID & '$(vKeySep)' & 'All' & '$(vKeySep)' & Num(AsOfDate) as FaktenKey_temp, //PF+WE+FactId+Sthold+MthYr+AsOfDate
//    If(Len(Trim(PFID))>0, PFID, 'All') & '$(vKeySep)' & If(Len(Trim(Liegenschafts_ID_WP))>0, Liegenschafts_ID_WP, 'All') & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & HypothekID & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & Num(AsOfDate) as %FaktenKey,
    If(RahmenkreditLimite_CHF > Betrag_CHF, 0, Betrag_CHF-If(IsNull(RahmenkreditLimite_CHF), 0, RahmenkreditLimite_CHF)) as BetragohneRK_CHF
Resident Hypotheken_temp2
WHERE Not(Match(HypothekTyp, 'Rahmenkredit')>0);

LEFT JOIN (Hypotheken_temp)
LOAD Distinct
    HypothekID as RahmenkreditID,
    Betrag_CHF as RahmenkreditBetrag_CHF,
    Hypothekenstatus as RKStatus,
    StartDatum as RKStartDatum,
    Faelligkeit as RKFaelligkeit,
    RIGHT([HypothekID],3) &' $(vKeySep) '& ReferenzNrHypothek as ReferenzNrRK
    
Resident Hypotheken_temp2
WHERE Match(HypothekTyp, 'Rahmenkredit')>0;

INNER JOIN(Hypotheken_temp)
LOAD Distinct
	RahmenkreditID,
    If(Betrag_CHF_sum > RahmenkreditBetrag_CHF_sum, 0, RahmenkreditBetrag_CHF_sum - If(IsNull(Betrag_CHF_sum), 0 , Betrag_CHF_sum)) as RKBetrag_Offen_CHF
;
// Preceding load
LOAD Distinct
	RahmenkreditID,
    Sum(Betrag_CHF) as Betrag_CHF_sum,
    Sum(DISTINCT RahmenkreditBetrag_CHF) as RahmenkreditBetrag_CHF_sum
Resident Hypotheken_temp
GROUP BY RahmenkreditID;


// Store QVD
Call QvdStore ('Hypotheken_temp', '$(vStorePath)', 'RF_TR', 'Hypotheken', '*', 1);

// Store QVD
Call QvdStore ('Hypotheken_temp2', '$(vStorePath)', 'temp', 'Hypotheken_temp', '*', 1);

End If

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_Hypo = (now() - vStartTime_Hypo)*86400;
Trace ---------------------------------- Hypotheken geladen ----------------------------------;
Trace $(vElapsed_Hypo);
//********************************************************************************************
///$tab 3.3.2 Schuldbriefe
//********************************* Start Zeitmessung *********************************
// SET vStartTime_Schuldbrief = 0;
// Set vElapsed_Schuldbrief = 0;
Let vStartTime_Schuldbrief  = now();

//*************************************************************************************

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Schuldbriefe.qvd')) Then

Schuldbriefe_temp2:
NoConcatenate
LOAD Distinct

    BasisURL,
    HypothekID,
    SchuldbriefID,
    Liegenschafts_ID_WP as WEId,
    PFID_temp as PFID,
  //  _KEY_content,
   // _KEY_root,
    Kommentar,
    Waehrung,
    CHF_Currency,
    ReferenzNrSchuldbrief,
    Status_temp as Status,
    Nennwert,
    NrDepotbank,
    Objektstatus_temp as Objektstatus,
    Rang,
    StartDatum_temp as StartDatum,
    StartDatum_temp as AsOfDate,
    Typ_temp as Typ
;
// Preceding load
LOAD Distinct
	*,
    if (len(trim(CHF_Currency_tmp)) = 0,1, CHF_Currency_tmp) as CHF_Currency,
	if (len(trim(Waehrung_tmp)) = 0,'CHF', Waehrung_tmp) as Waehrung
;
// Preceding load
LOAD Distinct
	*,
    Währung as Waehrung_tmp,
    Date(StartDatum) as StartDatum_temp,
    ApplyMap('Map_WE_to_Portfolio', Liegenschafts_ID_WP, null()) as PFID_temp,
    ApplyMap('MappingMortgageCertificate', Objektstatus, null()) as Objektstatus_temp,
    ApplyMap('MappingMortgageCertificate', Zertifikatstatus, null()) as Status_temp,
    ApplyMap('MappingMortgageCertificate', Typ, null()) as Typ_temp,
    ApplyMap('Map_Currency', Währung, null()) as CHF_Currency_tmp
 
FROM [$(vSourcePath)DS_api_Schuldbriefe.qvd]
(qvd);

IF Not Isnull(QvdCreateTime('$(vStorePath)temp-Hypotheken_temp.qvd')) Then

Left Join (Schuldbriefe_temp2)
LOAD Distinct
    HypothekID,
   // PFID,
    Kreditgeber,
    Faelligkeit,
   // Betrag_CHF,
    ReferenzNrHypothek
  //  NamePortfolio,
  //  AsOfDate   
//Resident Hypotheken_temp2;
FROM [$(vStorePath)temp-Hypotheken_temp.qvd] (qvd);

LEFT JOIN (Schuldbriefe_temp2)
LOAD Distinct
	HypothekID,
    Sum(Betrag_CHF) as HypoBetrag_CHF
FROM [$(vStorePath)temp-Hypotheken_temp.qvd] (qvd)
GROUP BY HypothekID;


End If

Schuldbriefe_temp:
NoConcatenate
Load Distinct
	FaktenKey_temp as %FaktenKey,
//    Hash128(FaktenKey_temp) as %FaktenKey,
//    FaktenKey_temp as RefFaktenKey,
    BasisURL,
    HypothekID,
    SchuldbriefID as %SchuldbriefID,
    PFID,
    WEId,
    Kommentar,
    Waehrung,
    CHF_Currency,
    ReferenzNrSchuldbrief,
    Status,
    Nennwert,
    NrDepotbank,
    Objektstatus,
    Rang,
    StartDatum,
    Typ,
    Kreditgeber,
    Faelligkeit,
    HypoBetrag_CHF,
    ReferenzNrHypothek,
    NamePortfolio
 WHERE Match(Validcheck, '1')>0
;
// Preceding load
LOAD Distinct
	*,
    ApplyMap('Map_Name_Portfolio', PFID, Null()) as NamePortfolio,
    If(Num(Faelligkeit)<Num(StartDatum), '0', '1') as Validcheck,
    If(Len(Trim(PFID))>0, PFID, 'All') & '$(vKeySep)' & If(Len(Trim(WEId))>0, WEId, 'All') & '$(vKeySep)' & SchuldbriefID & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & Num(AsOfDate) as FaktenKey_temp //PF+WE+FactId+Sthold+MthYr+AsOfDate

Resident Schuldbriefe_temp2;
Drop Table Schuldbriefe_temp2;

// Store QVD
Call QvdStore ('Schuldbriefe_temp', '$(vStorePath)', 'RF_TR', 'Schuldbriefe', '*', 1);

End If

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_Schuldbrief = (now() - vStartTime_Schuldbrief)*86400;
Trace ---------------------------------- Schuldbriefe geladen ----------------------------------;
Trace $(vElapsed_Schuldbrief);
//********************************************************************************************


///$tab 3.3.3 Rahmenkredite
//********************************* Start Zeitmessung *********************************
// SET vStartTime_RK = 0;
// Set vElapsed_RK = 0;
Let vStartTime_RK  = now();

//*************************************************************************************

IF Not Isnull(QvdCreateTime('$(vStorePath)temp-Hypotheken_temp.qvd')) Then

Rahmenkredite_temp2:
NoConcatenate
LOAD Distinct
    HypothekID as %RahmenkreditID,
    ReferenzNrHypothek,
    Vertragsdatum,
    StartDatum,
    Faelligkeit,
    AsOfDate,
    Hypothekenstatus,
    Kuendigungstermin,
    KuendigungsfristTage,
    Objektstatus,
    HypothekTyp,
    BasisURL,
    StakeholderID,
    Kreditgeber,
	FaelligkeitsJahr,
    Restlaufzeit,
    origBetrag,
    Betrag,
    Waehrung,
    CHF_Currency,
    Betrag_CHF
//Resident Hypotheken_temp2
FROM [$(vStorePath)temp-Hypotheken_temp.qvd] (qvd)
WHERE Match(HypothekTyp, 'Rahmenkredit')>0;

// Füge PFID und RK-Limite hinzu
IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_RahmenkreditLimiten.qvd')) Then

LEFT JOIN (Rahmenkredite_temp2)
LOAD Distinct
	RahmenkreditID as %RahmenkreditID,
    RahmenkreditPFID as RefPFID,
    RahmenkreditID & '$(vKeySep)' & RahmenkreditPFID as RefRKLimit
FROM [$(vSourcePath)DS_api_RahmenkreditLimiten.qvd]
(qvd);

LEFT JOIN (Rahmenkredite_temp2)
LOAD Distinct
    RahmenkreditID & '$(vKeySep)' & RahmenkreditPFID as RefRKLimit,
    RahmenkreditLimite
FROM [$(vSourcePath)DS_api_RahmenkreditLimiten.qvd]
(qvd);

ELSE


tempRK:
LOAD * INLINE [
RefPFID, RahmenkreditLimite
];

LEFT JOIN (Rahmenkredite_temp2)
LOAD 
  RefPFID,
  RahmenkreditLimite
Resident tempRK;

DROP TABLE tempRK;


End If

// Füge PFName hinzu
IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Portfolios.qvd')) Then

LEFT JOIN (Rahmenkredite_temp2)
LOAD Distinct
	If(Len(Trim(PortfolioId))>0, PortfolioId, null()) as RefPFID,
    Name as RefFondsName
FROM [$(vSourcePath)DS_api_Portfolios.qvd]
(qvd);

End If

// Füge Hypobeträge und benutzte Limite hinzu

IF Not Isnull(QvdCreateTime('$(vStorePath)RF_TR-Hypotheken.qvd')) Then

LEFT JOIN (Rahmenkredite_temp2)
LOAD Distinct
	RefRKLimit,
    Sum(RKLimit_Benutzt_temp) as RKLimit_Benutzt
GROUP BY RefRKLimit
;
// Preceding load
LOAD Distinct
	RahmenkreditID & '$(vKeySep)' & PFID as RefRKLimit,
    Betrag as RKLimit_Benutzt_temp
//Resident Hypotheken_temp;
FROM [$(vStorePath)RF_TR-Hypotheken.qvd] (qvd);


LEFT JOIN (Rahmenkredite_temp2)
LOAD Distinct
	RefRKLimit,
    Sum(RKLimit_Benutzt_CHF_temp) as RKLimit_Benutzt_CHF
GROUP BY RefRKLimit
;
// Preceding load
LOAD Distinct
	RahmenkreditID & '$(vKeySep)' & PFID as RefRKLimit,
    Betrag_CHF as RKLimit_Benutzt_CHF_temp
//Resident Hypotheken_temp;
FROM [$(vStorePath)RF_TR-Hypotheken.qvd] (qvd);

LEFT JOIN (Rahmenkredite_temp2)
LOAD Distinct
	RefRKLimit,
    Sum(HypoBetrag_Benutzt_CHF_temp) as HypoBetrag_Benutzt_CHF
GROUP BY RefRKLimit
;
// Preceding load
LOAD Distinct
	RahmenkreditID & '$(vKeySep)' & PFID as RefRKLimit,
    Betrag_CHF as HypoBetrag_Benutzt_CHF_temp
//Resident Hypotheken_temp
FROM [$(vStorePath)RF_TR-Hypotheken.qvd] (qvd)
WHERE Not(Match(Hypothekenstatus, 'Abgelaufen')>0);

End If

Rahmenkredite_temp:
NoConcatenate
LOAD Distinct
	FaktenKey_temp as %FaktenKey,
//    Hash128(FaktenKey_temp) as %FaktenKey,
//    FaktenKey_temp as RefFaktenKey,
	%RahmenkreditID,
    RIGHT([%RahmenkreditID],3) &' $(vKeySep) '& ReferenzNrHypothek as ReferenzNrRahmenkredit,
    RIGHT([%RahmenkreditID],3) &' $(vKeySep) '& Kreditgeber as RKNrKreditgeber,
//    %PFDateKey,		// no PF+Date Link, instead FactKey
    ReferenzNrHypothek,
    Vertragsdatum,
    StartDatum,
    Faelligkeit,
    AsOfDate,
    Hypothekenstatus,
    Kuendigungstermin,
    KuendigungsfristTage,
    Objektstatus,
    HypothekTyp,
    BasisURL,
    StakeholderID,
    Kreditgeber,
	FaelligkeitsJahr,
    Restlaufzeit,
    origBetrag,
    Betrag,
    Waehrung,
    CHF_Currency,
    Betrag_CHF,
    RefPFID,
    RefFondsName,
    RahmenkreditLimite,
    RahmenkreditLimite_CHF,
    OffenerRKBetrag_CHF,
    RKLimit_Benutzt,
    RKLimit_Benutzt_CHF,
    OffeneRKLimite_CHF,
    HypoBetrag_Benutzt_CHF,
    Offen_CHF
;
// Preceding load
LOAD Distinct
	*,
    If(Len(Trim(RefPFID)), RefPFID, 'All') & '$(vKeySep)' & 'All' & '$(vKeySep)' & %RahmenkreditID & '$(vKeySep)' & StakeholderID & '$(vKeySep)' & 'All' & '$(vKeySep)' & Num(AsOfDate) as FaktenKey_temp,  //PF+WE+FactId+Sthold+MthYr+AsOfDate
//    If(Len(Trim(RefPFID)), RefPFID, 'All') & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & 'All' & '$(vKeySep)' & %RahmenkreditID & '$(vKeySep)' & 'All' & '$(vKeySep)' & Num(AsOfDate) as %FaktenKey,
//    RefPFID & '$(vKeySep)' & Num(AsOfDate) as %PFDateKey,
    If(RahmenkreditLimite_CHF > Betrag_CHF, 0, Betrag_CHF - If(IsNull(RahmenkreditLimite_CHF), 0,  RahmenkreditLimite_CHF)) as OffenerRKBetrag_CHF,
    If(RKLimit_Benutzt_CHF > RahmenkreditLimite_CHF, 0, RahmenkreditLimite_CHF - If(IsNull(RKLimit_Benutzt_CHF), 0, RKLimit_Benutzt_CHF)) as OffeneRKLimite_CHF,
    If(HypoBetrag_Benutzt_CHF > Betrag_CHF, 0, Betrag_CHF - If(IsNull(HypoBetrag_Benutzt_CHF), 0, HypoBetrag_Benutzt_CHF)) as Offen_CHF
;
// Preceding load
LOAD Distinct
	*,
    Num(RahmenkreditLimite * CHF_Currency) as RahmenkreditLimite_CHF
Resident Rahmenkredite_temp2;
DROP TABLE Rahmenkredite_temp2;

// Store QVD
Call QvdStore ('Rahmenkredite_temp', '$(vStorePath)', 'RF_TR', 'Rahmenkredite', '*', 1);

End If

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_RK = (now() - vStartTime_RK)*86400;
Trace ---------------------------------- Rahmenkredite geladen ----------------------------------;
Trace $(vElapsed_RK);
//********************************************************************************************

///$tab Ende Darlehen 3.3 <
//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_Darlehen = (now() - vStartTime_Darlehen)*86400;
Trace ---------------------------------- Darlehen geladen ----------------------------------;
Trace $(vElapsed_Darlehen);
//********************************************************************************************

///$tab > 3.4 IVM Area Model
//********************************* Start Zeitmessung *********************************
// SET vStartTime_IVMAreaModel = 0;
// Set vElapsed_IVMAreaModel = 0;
Let vStartTime_IVMAreaModel  = now();

//*************************************************************************************
///$tab 3.4.1 IVM - Mietverhaeltnisse
//********************************* Start Zeitmessung *********************************
// SET vStartTime_IVM_Mietverhaeltnisse = 0;
// Set vElapsed_IVM_Mietverhaeltnisse = 0;
Let vStartTime_IVM_Mietverhaeltnisse  = now();

//*************************************************************************************

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_IVM_Mietverhaeltnisse.qvd')) Then


// Placeholder for Max Date
// Max_Lease_Date:
// NoConcatenate
// LOAD
//     Date(Max(Date(Floor(MonthEnd(AddYears(Date(StartDatum), 5)))))) as MaxLeaseDate
// FROM [$(vSourcePath)DS_api_IVM_Mietverhaeltnisse.qvd]
// (qvd);


// LET vMaxLeaseDate = Peek('MaxLeaseDate', 0, 'Max_Lease_Date');
// DROP TABLE Max_Lease_Date;


// Generate Leases Table
Mietverhaeltnisse_temp2:
NoConcatenate
LOAD Distinct
//    _KEY_content,
//    _KEY_root,
    MietverhaeltnisID as %MietverhaeltnisID,
    MietverhaeltnisID as RefMietverhaeltnisID,
    MietobjektID as RefMietobjektID,
    MietvertragID as RefMietvertragID,
    MietobjektID&'-'&MietvertragID as RefMOMVR,
//     MietobjektID as %MietobjektID,
//     MietvertragID as %MietvertragID,
    If(Date(StartDatum) < '$(vIVM_MinStartDate)', '$(vIVM_MinStartDate)', Date(StartDatum)) as mod_MVStartDatum,
//	Date(StartDatum) as MVStartDatum,
	Date(StartDatum) as StartDatum_temp,
    Date(StartDatum) as StartDatumMV_orig,
//    If(Num(StartDatum)=ApplyMap('Max_MV_Date', MietverhaeltnisID), '1', '0') as MostRecentMVRFlag,
//     If(Len(Trim(EndDatum))>0 AND Date(EndDatum) < YearEnd(AddYears($(vCurrentDate),5)), If(Date(EndDatum) < Date(StartDatum), Date(StartDatum), Date(EndDatum)), 
//       If(YearEnd($(vCurrentDate))<Date(StartDatum), YearEnd(AddYears(Date(StartDatum), 5)), YearEnd(AddYears($(vCurrentDate),5)))) as MVEndDatum,
	Date(EndDatum) as EndDatum_temp,
    Date(EndDatum) as EndDatumMV_orig,
    TimeStamp(Bearbeitungsdatum) as MVBearbeitungsdatum,
    WirtschaftseinheitsID,
//    WirtschaftseinheitsID as %WERefKeyMSP,
    ApplyMap('Map_WE_to_Portfolio', WirtschaftseinheitsID, null()) as PortfolioID
//    Date(AddMonths(Date(Floor(MonthStart(Date(StartDatum)))), IterNo()-1), 'MMM-YY') as MonthYear

FROM [$(vSourcePath)DS_api_IVM_Mietverhaeltnisse.qvd]
(qvd);
//WHILE AddMonths(Date(Floor(MonthStart(Date(StartDatum)))), IterNo()-1) <= Date(Floor(MonthEnd(If(Len(Trim(EndDatum))>0, Date(EndDatum), '$(vMaxLeaseDate)'))));


Mietverhaeltnisse_temp:
NoConcatenate
LOAD Distinct
	%MietverhaeltnisID,
    RefMietverhaeltnisID,
    RefMietobjektID,
    RefMietvertragID,
    mod_MVStartDatum,
	StartDatum_temp as MVStartDatum,
    StartDatumMV_orig,
    If(Len(Trim(EndDatum_temp))>0 AND EndDatum_temp < YearEnd(AddYears($(vCurrentDate),5)), If(EndDatum_temp < StartDatum_temp, StartDatum_temp, EndDatum_temp),
     Date(If(RefMOMVR = Previous(RefMOMVR), If(StartDatum_temp = Previous(StartDatum_temp), StartDatum_temp, Previous(StartDatum_temp)-1), 
      If(YearEnd($(vCurrentDate))<StartDatum_temp, YearEnd(AddYears(StartDatum_temp, 5)), YearEnd(AddYears($(vCurrentDate),5)))))) as MVEndDatum,
    EndDatumMV_orig,
    MVBearbeitungsdatum,
    WirtschaftseinheitsID,
    PortfolioID
    
Resident Mietverhaeltnisse_temp2
ORDER BY RefMOMVR, StartDatum_temp DESC;
DROP TABLE Mietverhaeltnisse_temp2;


// Store QVD
Call QvdStore ('Mietverhaeltnisse_temp', '$(vStorePath)', 'RF_TR', 'Mietverhaeltnisse', '*', 1);

End If


//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_IVM_Mietverhaeltnisse = (now() - vStartTime_IVM_Mietverhaeltnisse)*86400;
Trace ---------------------------------- IVM_Mietverhaeltnisse geladen ----------------------------------;
Trace $(vElapsed_IVM_Mietverhaeltnisse);
//********************************************************************************************

///$tab 3.4.2 IVM - Mietobjekte
//********************************* Start Zeitmessung *********************************
// SET vStartTime_IVM_Mietobjekte = 0;
// Set vElapsed_IVM_Mietobjekte = 0;
Let vStartTime_IVM_Mietobjekte  = now();

//*************************************************************************************

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_IVM_Mietobjekte_Versionen.qvd')) Then

Mietobjekte_Versionen_temp2:
NoConcatenate
LOAD Distinct
    WirtschaftseinheitsID,
//    _KEY_root,
    Kommentar,
    Date(EndDatum) as EndDatum_temp,
    Stockwerk,
    TimeStamp(Bearbeitungsdatum) as Bearbeitungsdatum_temp,
    Hauptnutzung_temp as Hauptnutzung,
    HauptnutzungRGB,
    HauptnutzungSortierung,
    Zimmerzahl,
    If(Zimmerzahl>10, Zimmerzahl/10, Zimmerzahl) as Zimmerzahl_mod,   //Exception handling for Typos
    Nutzung_temp as Nutzung,
    Nutzung_vereinfacht,
    Nutzung_vereinfachtRGB,
    NutzungKommerziell,
    NutzungMarkt,
    Date(Floor(Date(StartDatum))) as StartDatum_temp,
    Anzahl,
    MietobjektID,
    MietobjektID & '$(vKeySep)' & Num(Date(StartDatum)) as %MietobjektVersionKey,
    MietobjektID & '$(vKeySep)' & Date(Date(Floor(MonthStart(Date(StartDatum)))), 'MMM-YY') as %KeyMOMonthYear   
//    AutoNumberHash256(MietobjektID & '$(vKeySep)' & Num(Date(StartDatum))) as %MietobjektVersionKey
;
// Preceding load
LOAD
	*,
    ApplyMap('MappingRU', Hauptnutzung, Null()) as Hauptnutzung_temp,
    ApplyMap('MappingRUType2', Nutzung, Null()) as Nutzung_temp,
    ApplyMap('MappingPM',Hauptnutzung) as Nutzung_vereinfacht,		
   // ApplyMap('MappingNutzungPM',Hauptnutzung) as Nutzung_vereinfacht,
    ApplyMap('MappingPMRGB',Hauptnutzung) as Nutzung_vereinfachtRGB,
    ApplyMap('MappingNutzungMarkt', ApplyMap('MappingRU', Hauptnutzung), Null()) as NutzungMarkt,
    ApplyMap('MappingRURGB',Hauptnutzung) as HauptnutzungRGB,
    Applymap('MappingRUOrder',Hauptnutzung) as HauptnutzungSortierung,
    ApplyMap('MappingNutzungKommerziell',Hauptnutzung) as NutzungKommerziell
FROM [$(vSourcePath)DS_api_IVM_Mietobjekte_Versionen.qvd]
(qvd);

// LEFT JOIN (Mietobjekte_Versionen_temp2)
// LOAD Distinct
// 	%WirtschaftseinheitNr as WirtschaftseinheitsID,
//     Gemeindecode
    
// FROM [$(vStorePath)temp-WE_temp.qvd] (qvd);


Mietobjekte_Versionen_temp:
NoConcatenate
LOAD Distinct
    MietobjektID,
    %MietobjektVersionKey,
//    %KeyMOMonthYear,
    Hauptnutzung,
    if (Hauptnutzung='Wohnen', Zimmerzahl, 
	 if (Hauptnutzung='Einstellplätze', 'Parking', 
	  if (Hauptnutzung='Aussenparkplätze', 'Parking',
		   Hauptnutzung))) as Hauptnutzung2,
    HauptnutzungRGB,
    HauptnutzungSortierung,
    Nutzung,
    Nutzung_vereinfacht,
    Nutzung_vereinfachtRGB,
    NutzungKommerziell,
    NutzungMarkt,
    Stockwerk,
    Zimmerzahl_mod as Zimmerzahl,
    If(StartDatum_temp < '$(vIVM_MinStartDate)', '$(vIVM_MinStartDate)', StartDatum_temp) as mod_MO_Ver_StartDatum,
	StartDatum_temp as MO_Ver_StartDatum,
    StartDatum_temp as StartDatumMOVer_orig,
    EndDatum_temp as EndDatumMO_Ver_orig,
    If(Len(Trim(EndDatum_temp))>0 AND EndDatum_temp < YearEnd(AddYears($(vCurrentDate),5)), If(EndDatum_temp < StartDatum_temp, StartDatum_temp, EndDatum_temp),
     Date(If(MietobjektID = Previous(MietobjektID), If(StartDatum_temp = Previous(StartDatum_temp), StartDatum_temp, Previous(StartDatum_temp)-1), 
      If(YearEnd($(vCurrentDate))<StartDatum_temp, YearEnd(AddYears(StartDatum_temp, 5)), YearEnd(AddYears($(vCurrentDate),5)))))) as MO_Ver_EndDatum,
    Kommentar as MO_Ver_Kommentar,
    Bearbeitungsdatum_temp as MO_Ver_Bearbeitungsdatum,
    Anzahl,
//     Gemeindecode,
//     Gemeindecode & '$(vKeySep)'& Hauptnutzung as %Marktdaten_GN,
    if(isnum(applymap('$(vBerechnungWAULT)_WAULTFaktoren',Applymap('MappingRU',Hauptnutzung))),applymap('$(vBerechnungWAULT)_WAULTFaktoren',Applymap('MappingRU',Hauptnutzung)),1) as FaktorWAULT

Resident Mietobjekte_Versionen_temp2
ORDER BY MietobjektID, StartDatum_temp DESC;

DROP TABLE Mietobjekte_Versionen_temp2;


// *** Mapping
Min_MOVer_StartDate:
Mapping LOAD
	MietobjektID,
    Date(Floor(Min(MO_Ver_StartDatum))) as MinMOVerStartbyMODate

Resident Mietobjekte_Versionen_temp
GROUP BY MietobjektID;


// *** Mapping
Max_MOVer_EndDate:
Mapping LOAD
	MietobjektID,
    Date(Floor(Max(MO_Ver_EndDatum))) as MaxMOVerEndbyMODate

Resident Mietobjekte_Versionen_temp
GROUP BY MietobjektID;


// Add Area Unit Data
MO_temp:
NoConcatenate
LOAD Distinct
//     WirtschaftseinheitsID,
//     _KEY_root, 
    MietobjektID,  // join on this
    MietobjektID as %MietobjektID,
    externeIdMietobjekt,
    Gebaeude,
    Hauseingang,
    ApplyMap('Min_MOVer_StartDate', MietobjektID) as MinMOVerStartbyMODate,
    ApplyMap('Max_MOVer_EndDate', MietobjektID) as MaxMOVerEndbyMODate,
    If(Date(StartDatum) > ApplyMap('Min_MOVer_StartDate', MietobjektID), ApplyMap('Min_MOVer_StartDate', MietobjektID), 
     If(Date(StartDatum) < '$(vIVM_MinStartDate)', '$(vIVM_MinStartDate)', Date(StartDatum))) as mod_MOStartDatum,
	Date(Floor(Date(StartDatum))) as MOStartDatum,
    Date(Floor(Date(StartDatum))) as StartDatumMO_orig,
    If(Len(Trim(EndDatum))>0 AND Date(EndDatum)< ApplyMap('Max_MOVer_EndDate', MietobjektID), Date(EndDatum), ApplyMap('Max_MOVer_EndDate', MietobjektID)) as MOEndDatum,
    Date(EndDatum) as EndDatumMO_orig
    
FROM [$(vSourcePath)DS_api_IVM_Mietobjekte.qvd]
(qvd);

LEFT JOIN (Mietobjekte_Versionen_temp)
LOAD
	MietobjektID,  // join on this
    %MietobjektID,
    externeIdMietobjekt,
    SubField(externeIdMietobjekt, '-', -1) as MOexterneID,
    Gebaeude,
    Hauseingang,
    mod_MOStartDatum,
    MOStartDatum,
    StartDatumMO_orig,
    MOEndDatum,
    EndDatumMO_orig

Resident MO_temp;
DROP TABLE MO_temp;


// *** Mapping
Max_MOVer_StartDate:
Mapping LOAD
	MietobjektID,
    Max(MO_Ver_StartDatum) as MaxMOVerStartbyMODate

Resident Mietobjekte_Versionen_temp
GROUP BY MietobjektID;

Mietobjekte_Versionen_neu:
NoConcatenate
LOAD Distinct
	*,
    If(Num(MO_Ver_StartDatum) = ApplyMap('Max_MOVer_StartDate', MietobjektID), '1', '0') as MO_Ver_LatestFlag

Resident Mietobjekte_Versionen_temp;
DROP TABLE Mietobjekte_Versionen_temp;
RENAME TABLE Mietobjekte_Versionen_neu TO Mietobjekte_Versionen_temp;



// MaxMOVerDate_temp:
// NoConcatenate
// LOAD
// 	Date(Floor(MonthEnd(Floor(Max(MO_Ver_EndDatum))))) as MaxMOVerDate
// Resident Mietobjekte_Versionen_temp;

// LET vMaxMOVerDate = Peek('MaxMOVerDate', 0, 'MaxMOVerDate_temp');
// DROP TABLE MaxMOVerDate_temp;



// LEFT JOIN (Mietobjekte_Versionen_temp)
// LOAD Distinct
// //    WirtschaftseinheitsID as %WERefKeyMSP,
// //    _KEY_root,
//     Gebaeude,
// //    If(Len(Trim(EndDatum))>0 AND Date(EndDatum) < '$(vMaxMOVerDate)', Date(EndDatum), '$(vMaxMOVerDate)') as MOEndDatum,
//     Date(EndDatum) as EndDatumMO_orig,
//     Hauseingang,
//     externeIdMietobjekt,
//     Date(StartDatum) as MOStartDatum,
//     MietobjektID
// //    MietobjektID as %MietobjektID
    
// FROM [$(vSourcePath)DS_api_IVM_Mietobjekte.qvd]
// (qvd);



// Store QVD
Call QvdStore ('Mietobjekte_Versionen_temp', '$(vStorePath)', 'RF_TR', 'Mietobjekte', '*', 1);

End If


//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_IVM_Mietobjekte = (now() - vStartTime_IVM_Mietobjekte)*86400;
Trace ---------------------------------- IVM_Mietobjekte Versionen geladen ----------------------------------;
Trace $(vElapsed_IVM_Mietobjekte);
//********************************************************************************************

///$tab 3.4.3 IVM - Mietvertraege
//********************************* Start Zeitmessung *********************************
// SET vStartTime_IVM_Mietvertraege = 0;
// Set vElapsed_IVM_Mietvertraege = 0;
Let vStartTime_IVM_Mietvertraege  = now();

//*************************************************************************************

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_IVM_Mietvertrag_Versionen.qvd')) Then

Mietvertraege_Versionen_temp2:
NoConcatenate
LOAD Distinct
    Kommentar,
//    WirtschaftseinheitsID,
//    _KEY_root,
    _KEY_versions,
    Date(VisiertAm) as VisiertAm_temp,
    VisiertVon,
    Date(EndDatum) as EndDatum_temp,
    Date(StartDatum) as StartDatum_temp,
    Vertragstyp,
    Timestamp(ErstelltAm) as ErstelltAm_temp,
    Date(ErsteIndexanpassung) as ErsteIndexanpassung_temp,
    Ausbautyp,
    Indexbasis,
    Indexierung,
    If(Indexierung>1, Indexierung/10, Indexierung) as Indexierung_mod,
    Indexierungstyp,
    Timestamp(Bearbeitungsdatum) as Bearbeitungsdatum_temp,
    Date(HaftungsDatum) as HaftungsDatum_temp,
    KuendigungsdauerInMonate,
//    Kuendigungsmonat,
    BKUeberwaehlzungAnteil,
    Optiert,
    Staffelmiete,
    MieterName,
    Kuendigungsgrund,
    MietvertragID,
    Leerstandsgrund,
    Leerstand,
    If(Leerstand='True', '1', '0') as Leerstand_1_0,
    MietvertragID & '$(vKeySep)' & Num(Date(StartDatum)) as %MietvertragVersionKey,
    MietvertragID & '$(vKeySep)' & Date(Date(Floor(MonthStart(Date(StartDatum)))), 'MMM-YY') as %KeyMVRMonthYear
FROM [$(vSourcePath)DS_api_IVM_Mietvertrag_Versionen.qvd]
(qvd);

  // *** Mapping
  Map_MVRVerToKey:
  Mapping LOAD Distinct
        _KEY_versions,
        %MietvertragVersionKey

  Resident Mietvertraege_Versionen_temp2;



Mietvertraege_Versionen_temp:
NoConcatenate
LOAD Distinct
//	_KEY_versions,
    MietvertragID,
    %MietvertragVersionKey,
//    %KeyMVRMonthYear,
    Vertragstyp,
    Ausbautyp,
    Optiert,
    Staffelmiete,
    MieterName,
    Leerstand,
    Leerstand_1_0,
    Leerstandsgrund,
    Kuendigungsgrund,
    KuendigungsdauerInMonate,
    HaftungsDatum_temp as MVR_Haftungsdatum,
    BKUeberwaehlzungAnteil,
    Indexierung_mod as MVR_Indexierung,
    Indexbasis as MVR_Indexbasis,
    Indexierungstyp as MVR_indexierungstyp,
    ErsteIndexanpassung_temp as MVR_ErsteIndexanpassung,
    VisiertAm_temp as MVR_VisiertAm,
    VisiertVon as MVR_VisiertVon,
    ErstelltAm_temp as MVR_ErstelltAm,
    Kommentar as MVR_Kommentar,
    Bearbeitungsdatum_temp as MVR_Bearbeitungsdatum,
    If(StartDatum_temp < '$(vIVM_MinStartDate)', '$(vIVM_MinStartDate)', StartDatum_temp) as mod_MVR_StartDatum,
    StartDatum_temp as MVR_StartDatum,
    StartDatum_temp as StartDatumMVR_orig,
    EndDatum_temp as EndDatumMVR_orig,
    If(Len(Trim(EndDatum_temp))>0 AND EndDatum_temp < YearEnd(AddYears($(vCurrentDate),5)), If(EndDatum_temp < StartDatum_temp, StartDatum_temp, EndDatum_temp),
     Date(If(MietvertragID = Previous(MietvertragID), If(StartDatum_temp = Previous(StartDatum_temp), StartDatum_temp, Previous(StartDatum_temp)-1), 
      If(YearEnd($(vCurrentDate))<StartDatum_temp, YearEnd(AddYears(StartDatum_temp, 5)), YearEnd(AddYears($(vCurrentDate),5)))))) as MVR_EndDatum
 
Resident Mietvertraege_Versionen_temp2
ORDER BY MietvertragID, StartDatum_temp DESC;

DROP TABLE Mietvertraege_Versionen_temp2;


LEFT JOIN (Mietvertraege_Versionen_temp)
LOAD Distinct
//    WirtschaftseinheitsID as %WERefKeyMSP,
//    _KEY_root,
    ExterneVertragsnummer,
    Date(NaechsterKuendigungsterminVermieter) as NaechsterKuendigungsterminVermieter,
    Date(NaechsterKuendigungsterminMieter) as NaechsterKuendigungsterminMieter,
    MietvertragID,  //join on this
    MietvertragID as %MietvertragID
FROM [$(vSourcePath)DS_api_IVM_Mietvertraege.qvd]
(qvd);

// *** Mapping
Max_MVRVer_Date:
Mapping LOAD Distinct
	MietvertragID,
    Max(MVR_StartDatum) as MaxMVRVerbyMVBRDate

Resident Mietvertraege_Versionen_temp
GROUP BY MietvertragID;

Mietvertraege_Versionen_neu:
NoConcatenate
LOAD Distinct
	*,
    If(Num(MVR_StartDatum)=ApplyMap('Max_MVRVer_Date', MietvertragID), '1', '0') as MVR_Ver_LatestFlag

Resident Mietvertraege_Versionen_temp;
DROP TABLE Mietvertraege_Versionen_temp;
RENAME TABLE Mietvertraege_Versionen_neu TO Mietvertraege_Versionen_temp;

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_IVM_Mietvertrag_Optionen.qvd')) Then

  MietvertragsOptionen_temp:
  NoConcatenate
  LOAD Distinct
  //    WirtschaftseinheitsID,
  //    MietvertragID,
  //    _KEY_versions,
      ApplyMap('Map_MVRVerToKey', _KEY_versions, Null()) as %MietvertragVersionKey,
      AusuebungPeriodeInMonate,
      Date(EndDatum) as OptionEnde,
      Date(StartDatum) as OptionStart,
      Status as OptionStatus,
      Optionstyp
  FROM [$(vSourcePath)DS_api_IVM_Mietvertrag_Optionen.qvd]
  (qvd);

//   // Join the OptionEnddate to the MVR-Version Table
//   LEFT JOIN (Mietvertraege_Versionen_temp)
//   LOAD Distinct
//       %MietvertragVersionKey,
//       OptionEnde as EndDateOption

//   Resident MietvertragsOptionen_temp;

// Store QVD
Call QvdStore ('MietvertragsOptionen_temp', '$(vStorePath)', 'RF_TR', 'MietvertragsOptionen', '*', 1);

END IF

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_IVM_Kuendigungsmonate.qvd')) Then

  Kuendigungsmonate_temp:
  NoConcatenate
  LOAD Distinct
   //   _KEY_versions,
      ApplyMap('Map_MVRVerToKey', _KEY_versions, Null()) as %MietvertragVersionKey,
      Kuendigungsmonat

  FROM [$(vSourcePath)DS_api_IVM_Kuendigungsmonate.qvd]
  (qvd);
  
//   LEFT JOIN (MietvertragsOptionen_temp)
//   LOAD Distinct
//       _KEY_versions,
//       %MietvertragVersionKey

//   Resident Mietvertraege_Versionen_temp;
  
  
// Store QVD
Call QvdStore ('Kuendigungsmonate_temp', '$(vStorePath)', 'RF_TR', 'Kuendigungsmonate', '*', 1);

END IF


//DROP FIELD [_KEY_versions];

// Store QVD
Call QvdStore ('Mietvertraege_Versionen_temp', '$(vStorePath)', 'RF_TR', 'Mietvertraege', '*', 1);


End If


//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_IVM_Mietvertraege = (now() - vStartTime_IVM_Mietvertraege)*86400;
Trace ---------------------------------- IVM_Mietvertraege Versionen geladen ----------------------------------;
Trace $(vElapsed_IVM_Mietvertraege);
//********************************************************************************************



    
///$tab 3.4.4 IVM - Flaeche neu
//********************************* Start Zeitmessung *********************************
// SET vStartTime_IVM_FlaecheVersionen = 0;
// Set vElapsed_IVM_FlaecheVersionen = 0;
Let vStartTime_IVM_FlaecheVersionen  = now();

//*************************************************************************************

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_IVM_Mietobjekt_Flaeche_Versionen.qvd')) AND Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_IVM_Mietvertrag_Flaeche_Versionen.qvd')) Then

// *** Mapping
Map_MO_EndDate:
Mapping LOAD Distinct
	MietobjektID,
    MOEndDatum

//Resident Mietobjekte_Versionen_temp;
FROM [$(vStorePath)RF_TR-Mietobjekte.qvd] (qvd);

// *** Mapping
Map_MVToMO:
Mapping LOAD Distinct
	RefMietobjektID as RefMO,
    %MietverhaeltnisID

//Resident Mietverhaeltnisse_temp;
FROM [$(vStorePath)RF_TR-Mietverhaeltnisse.qvd] (qvd);


// *** Mapping
Map_MVR_EndDate:
Mapping LOAD Distinct
	MietvertragID,
    MVR_EndDatum

//Resident Mietvertraege_Versionen_temp;
FROM [$(vStorePath)RF_TR-Mietvertraege.qvd] (qvd);

// *** Mapping
Map_MVToMVR:
Mapping LOAD Distinct
	RefMietvertragID as RefMVR,
    %MietverhaeltnisID

//Resident Mietverhaeltnisse_temp;
FROM [$(vStorePath)RF_TR-Mietverhaeltnisse.qvd] (qvd);


// Get Area Versions from Area Units
Flaeche_Versionen_temp4:
NoConcatenate
LOAD Distinct
    WirtschaftseinheitsID,
//    _KEY_root,
    FlaecheProEinheit,
    Flaechentyp,
    Flaecheeinheit,
    Date(EndDatum) as EndDatum_temp,
    Timestamp(Bearbeitungsdatum) as Bearbeitungsdatum_temp,
    Date(StartDatum) as StartDatum_temp,
    '' as MietvertragID,
    MietobjektID,
    MietobjektID & '$(vKeySep)' & 'OF' & '$(vKeySep)' & Num(Date(StartDatum)) as %FlaecheVersionKey
//    AutoNumberHash256(Num(Date(StartDatum))) as %FlaecheVersionKey
FROM [$(vSourcePath)DS_api_IVM_Mietobjekt_Flaeche_Versionen.qvd]
(qvd);

LOAD Distinct
    WirtschaftseinheitsID,
//    _KEY_root,
    FlaecheProEinheit,
    Flaechentyp,
    Flaecheeinheit,
    Date(EndDatum) as EndDatum_temp,
    Timestamp(Bearbeitungsdatum) as Bearbeitungsdatum_temp,
    Date(StartDatum) as StartDatum_temp,
    MietvertragID,
    '' as MietobjektID,
    MietvertragID & '$(vKeySep)' & 'MF' & '$(vKeySep)' & Num(Date(StartDatum)) as %FlaecheVersionKey
//    AutoNumberHash256(Num(Date(StartDatum))) as %FlaecheVersionKey
FROM [$(vSourcePath)DS_api_IVM_Mietvertrag_Flaeche_Versionen.qvd]
(qvd);


Flaeche_MO_temp:
NoConcatenate
LOAD Distinct
	%FlaecheVersionKey as FlaecheVersionKey_temp,
    MietobjektID as RefMO,
    WirtschaftseinheitsID,
    ApplyMap('Map_MVToMO', MietobjektID, Null()) as MietverhaeltnisID,
    Flaechentyp,
    Flaecheeinheit,
    FlaecheProEinheit,
    If(StartDatum_temp < '$(vIVM_MinStartDate)', '$(vIVM_MinStartDate)', StartDatum_temp) as mod_FlaecheVer_StartDatum,
    StartDatum_temp as FlaecheVer_StartDatum,
    StartDatum_temp as StartDatumFlaeche_orig,
    EndDatum_temp as EndDatumFlaeche_orig,
    Bearbeitungsdatum_temp,
    If(Len(Trim(EndDatum_temp))>0 AND EndDatum_temp < ApplyMap('Map_MO_EndDate', MietobjektID), If(EndDatum_temp < StartDatum_temp, StartDatum_temp, EndDatum_temp),
     Date(If(MietobjektID = Previous(MietobjektID), If(StartDatum_temp = Previous(StartDatum_temp), StartDatum_temp, Previous(StartDatum_temp)-1), ApplyMap('Map_MO_EndDate', MietobjektID, Null())))) as FlaecheVer_EndDatum,
     
    If(Len(Trim(EndDatum_temp))>0 AND EndDatum_temp < ApplyMap('Map_MO_EndDate', MietobjektID), If(EndDatum_temp < StartDatum_temp, StartDatum_temp, EndDatum_temp),
     Date(If(MietobjektID = Previous(MietobjektID), If(StartDatum_temp = Previous(StartDatum_temp), StartDatum_temp, MonthEnd(AddMonths(Previous(StartDatum_temp), -1))), 
      ApplyMap('Map_MO_EndDate', MietobjektID, Null())))) as FlaecheFakten_Enddatum
      
Resident Flaeche_Versionen_temp4
WHERE LEN(Trim(MietobjektID))>0
ORDER BY MietobjektID, StartDatum_temp DESC;


Flaeche_MVR_temp:
NoConcatenate
LOAD Distinct
	%FlaecheVersionKey as FlaecheVersionKey_temp,
    MietvertragID as RefMVR,
    WirtschaftseinheitsID,
    ApplyMap('Map_MVToMVR', MietvertragID, Null()) as MietverhaeltnisID,
    Flaechentyp,
    Flaecheeinheit,
    FlaecheProEinheit,
    If(StartDatum_temp < '$(vIVM_MinStartDate)', '$(vIVM_MinStartDate)', StartDatum_temp) as FlaecheVer_StartDatum,
    StartDatum_temp as StartDatumFlaeche_orig,
    EndDatum_temp as EndDatumFlaeche_orig,
    Bearbeitungsdatum_temp,
    If(Len(Trim(EndDatum_temp))>0 AND EndDatum_temp < ApplyMap('Map_MVR_EndDate', MietvertragID), EndDatum_temp,
     Date(If(MietvertragID = Previous(MietvertragID), If(StartDatum_temp = Previous(StartDatum_temp), StartDatum_temp, Previous(StartDatum_temp)-1), ApplyMap('Map_MVR_EndDate', MietvertragID, Null())))) as FlaecheVer_EndDatum,
     
    If(Len(Trim(EndDatum_temp))>0 AND EndDatum_temp < ApplyMap('Map_MVR_EndDate', MietvertragID), EndDatum_temp,
     Date(If(MietvertragID = Previous(MietvertragID), If(StartDatum_temp = Previous(StartDatum_temp), StartDatum_temp, MonthEnd(AddMonths(Previous(StartDatum_temp), -1))), 
      ApplyMap('Map_MVR_EndDate', MietvertragID, Null())))) as FlaecheFakten_Enddatum
      
Resident Flaeche_Versionen_temp4
WHERE LEN(Trim(MietvertragID))>0
ORDER BY MietvertragID, StartDatum_temp DESC;

DROP TABLE Flaeche_Versionen_temp4;


Flaeche_Versionen_temp:
NoConcatenate
LOAD Distinct
//	SubField(FlaecheVersionKey_temp, '$(vKeySep)', 1) as %FlaecheVersionKey,
	FlaecheVersionKey_temp as %FlaecheVersionKey,
//    WirtschaftseinheitsID as %WERefKeyMSP,
    MietverhaeltnisID as RefFlaecheMietverhaeltnisID,
    Flaechentyp,
    Flaecheeinheit,
    FlaecheProEinheit,
    FlaecheVer_StartDatum,
    StartDatumFlaeche_orig,
    Bearbeitungsdatum_temp,
	FlaecheVer_EndDatum,
    EndDatumFlaeche_orig,
    'Mietflaeche' as FlaecheSource

Resident Flaeche_MVR_temp;

LOAD Distinct
//	SubField(FlaecheVersionKey_temp, '$(vKeySep)', 1) as %FlaecheVersionKey,
	FlaecheVersionKey_temp as %FlaecheVersionKey,
//    WirtschaftseinheitsID as %WERefKeyMSP,
    MietverhaeltnisID as RefFlaecheMietverhaeltnisID,
    Flaechentyp,
    Flaecheeinheit,
    FlaecheProEinheit,
    FlaecheVer_StartDatum,
    StartDatumFlaeche_orig,
    Bearbeitungsdatum_temp,
	FlaecheVer_EndDatum,
    EndDatumFlaeche_orig,
    'Objektflaeche' as FlaecheSource
    
Resident Flaeche_MO_temp;

// DROP TABLE Flaeche_MVR_temp;
// DROP TABLE Flaeche_MO_temp;


// *** Mapping
Max_FlaecheVer_Date:
Mapping LOAD
	RefFlaecheMietverhaeltnisID,
    Max(FlaecheVer_StartDatum) as MaxFlaechebyMVDate

Resident Flaeche_Versionen_temp
GROUP BY RefFlaecheMietverhaeltnisID;


Flaeche_Versionen_neu:
NoConcatenate
LOAD Distinct
	*,
    If(Num(FlaecheVer_StartDatum) = ApplyMap('Max_FlaecheVer_Date', RefFlaecheMietverhaeltnisID), '1', '0') as Flaeche_LatestFlag
    
Resident Flaeche_Versionen_temp;
DROP TABLE Flaeche_Versionen_temp;
RENAME TABLE Flaeche_Versionen_neu TO Flaeche_Versionen_temp;



// Store QVD
Call QvdStore ('Flaeche_Versionen_temp', '$(vStorePath)', 'RF_TR', 'FlaecheVer', '*', 1);

// Store QVD
Call QvdStore ('Flaeche_MO_temp', '$(vStorePath)', 'temp', 'FlaecheMO_temp', '*', 1);

// Store QVD
Call QvdStore ('Flaeche_MVR_temp', '$(vStorePath)', 'temp', 'FlaecheMVR_temp', '*', 1);


End If


//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_IVM_FlaecheVersionen = (now() - vStartTime_IVM_FlaecheVersionen)*86400;
Trace ---------------------------------- IVM_Flaeche Versionen geladen ----------------------------------;
Trace $(vElapsed_IVM_FlaecheVersionen);
//********************************************************************************************


///$tab 3.4.5 IVM - Konditionen neu
//********************************* Start Zeitmessung *********************************
// SET vStartTime_IVM_Konditionen = 0;
// Set vElapsed_IVM_Konditionen = 0;
Let vStartTime_IVM_Konditionen  = now();

//*************************************************************************************

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_IVM_Mietobjekt_Konditionen.qvd')) Then

// Get Conditions from Area Units

temp_Kond_MO:
NoConcatenate
LOAD *
FROM [$(vSourcePath)DS_api_IVM_Mietobjekt_Konditionen.qvd]
(qvd);

LEFT JOIN (temp_Kond_MO)
LOAD
	RefMietobjektID as MietobjektID,  //join on this
    %MietverhaeltnisID as MietverhaeltnisID_MO

//Resident Mietverhaeltnisse_temp;
FROM [$(vStorePath)RF_TR-Mietverhaeltnisse.qvd] (qvd);


Konditionen_temp4:
NoConcatenate
LOAD Distinct
    WirtschaftseinheitsID,
    MietverhaeltnisID_MO as MietverhaeltnisID,
//    _KEY_root,
    Date(VisiertAm) as VisiertAm_temp,
    VisiertVon,
    CashFlowRelevantVermietet,
    CashFlowRelevantLeerstehend,
    Kommentar,
    Date(Floor(ErstelltAm)) as ErstelltAm_temp,
    Date(EndDatum) as EndDatum_temp,
    Indexierung,
    BasisIndexwert,
    Date(IndexDatum) as IndexDatum_temp,
    Date(letzteAnpassungRefZinssatz) as letzteAnpassungRefZinssatz_temp,
    Timestamp(Bearbeitungsdatum) as Bearbeitungsdatum_temp,
    Date(DatumLetzteBKUeberwaehlzung) as DatumLetzteBKUeberwaehlzung_temp,
    Zahlungsmodalitaet,
    Referenzzinssatz,
    If(Referenzzinssatz>1, If(Referenzzinssatz>1000, Referenzzinssatz/100000, Referenzzinssatz/100), Referenzzinssatz) as Referenzzinssatz_mod,
//    Date(StartDatum) as StartDatum_temp,
	StartDatum_temp,
    CashFlowKonditionTyp,
    MietobjektID,
    '' as MietvertragID,
    Num(Date(StartDatum_temp))& '$(vKeySep)' & CashFlowKonditionTyp & '$(vKeySep)' & Num(BetragProjahr) as %KonditionKey,
//	Num(Date(StartDatum_temp))& '$(vKeySep)' & CashFlowKonditionTyp & '$(vKeySep)' & MietobjektID as %KonditionKey,
    Num(Date(StartDatum_temp))& '$(vKeySep)' & CashFlowKonditionTyp as KonditionBaseKey,
//	Num(Date(StartDatum_temp))& '$(vKeySep)' & CashFlowKonditionTyp as %KonditionKey,
//    Hash256(Num(Date(StartDatum))& '$(vKeySep)' & Hash256(CashFlowKonditionTyp)) as KonditionVersion,
    Coalesce(BetragProjahr, '0') as BetragProjahr
;
//Preceding load
LOAD
	*,
    If(Date(StartDatum)='01.01.2022' AND CashFlowKonditionTyp='NET_RENT' AND MietobjektID='106-264-100', MakeDate(2022,01,02), Date(StartDatum)) as StartDatum_temp  // have to correct 106-264-100 as the raw data is wrong

// FROM [$(vSourcePath)DS_api_IVM_Mietobjekt_Konditionen.qvd]
// (qvd);
Resident temp_Kond_MO;
DROP TABLE temp_Kond_MO;



If Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_IVM_Mietvertrag_Konditionen.qvd')) Then

// Get Conditions from Rental Contracts if they are included there

temp_Kond_MVR:
NoConcatenate
LOAD *
FROM [$(vSourcePath)DS_api_IVM_Mietvertrag_Konditionen.qvd]
(qvd);

LEFT JOIN (temp_Kond_MVR)
LOAD
	RefMietvertragID as MietvertragID,
    %MietverhaeltnisID as MietverhaeltnisID_MVR

//Resident Mietverhaeltnisse_temp;
FROM [$(vStorePath)RF_TR-Mietverhaeltnisse.qvd] (qvd);


Concatenate (Konditionen_temp4)
LOAD Distinct
    WirtschaftseinheitsID,
    MietverhaeltnisID_MVR as MietverhaeltnisID,
//    _KEY_root,
    Date(VisiertAm) as VisiertAm_temp,
    VisiertVon,
    CashFlowRelevantVermietet,
    CashFlowRelevantLeerstehend,
    Kommentar,
    Date(Floor(ErstelltAm)) as ErstelltAm_temp,
    Date(EndDatum) as EndDatum_temp,
    Indexierung,
    BasisIndexwert,
    Date(IndexDatum) as IndexDatum_temp,
    Date(letzteAnpassungRefZinssatz) as letzteAnpassungRefZinssatz_temp,
    Timestamp(Bearbeitungsdatum) as Bearbeitungsdatum_temp,
    Date(DatumLetzteBKUeberwaehlzung) as DatumLetzteBKUeberwaehlzung_temp,
    Zahlungsmodalitaet,
    Referenzzinssatz,
    If(Referenzzinssatz>1, If(Referenzzinssatz>1000, Referenzzinssatz/100000, Referenzzinssatz/100), Referenzzinssatz) as Referenzzinssatz_mod,
//    Date(StartDatum) as StartDatum_temp,
	StartDatum_temp,
    CashFlowKonditionTyp,
    '' as MietobjektID,
    MietvertragID,
    Num(Date(StartDatum_temp))& '$(vKeySep)' & CashFlowKonditionTyp & '$(vKeySep)' & Num(BetragProjahr) as %KonditionKey,
//    Num(Date(StartDatum_temp))& '$(vKeySep)' & CashFlowKonditionTyp & '$(vKeySep)' & MietvertragID as %KonditionKey,
    Num(Date(StartDatum_temp))& '$(vKeySep)' & CashFlowKonditionTyp as KonditionBaseKey,
//	Num(Date(StartDatum_temp))& '$(vKeySep)' & CashFlowKonditionTyp as %KonditionKey,
//    Hash256(Num(Date(StartDatum))& '$(vKeySep)' & Hash256(CashFlowKonditionTyp)) as KonditionVersion,
    Coalesce(BetragProjahr, '0') as BetragProjahr
;
// Preceding load
LOAD
	*,
    If(Date(StartDatum)='01.01.2022' AND CashFlowKonditionTyp='NET_RENT' AND MietvertragID='106-264-100', MakeDate(2022,01,02), Date(StartDatum)) as StartDatum_temp  // have to correct 106-264-100 as the raw data is wrong
// FROM [$(vSourcePath)DS_api_IVM_Mietvertrag_Konditionen.qvd]
// (qvd);
Resident temp_Kond_MVR;
DROP TABLE temp_Kond_MVR;

ELSE

Concatenate (Konditionen_temp4)
LOAD * Inline [
MietvertragID
];


END IF


// *** Mapping
Map_MO_Date:
Mapping LOAD Distinct
	MietobjektID,
    MOEndDatum

//Resident Mietobjekte_Versionen_temp;
FROM [$(vStorePath)RF_TR-Mietobjekte.qvd] (qvd);

// *** Mapping
Map_MVR_Date:
Mapping LOAD Distinct
	MietvertragID,
    MVR_EndDatum

//Resident Mietvertraege_Versionen_temp;
FROM [$(vStorePath)RF_TR-Mietvertraege.qvd] (qvd);


Konditionen_temp3:
NoConcatenate
LOAD Distinct
	%KonditionKey,
//     MietobjektID,
//     MietvertragID,
    MietverhaeltnisID,
    MietverhaeltnisID & '$(vKeySep)' & CashFlowKonditionTyp as MVKondKey,
    KonditionBaseKey,
    WirtschaftseinheitsID,
    ErstelltAm_temp,
//    VisiertAm_temp,
//    VisiertVon,
    StartDatum_temp,
    EndDatum_temp,
//    Num(StartDatum_temp) as NumStartDatum,
//    EndDatum_temp as EndDatumKond_orig,
//	Coalesce(EndDatum_temp, ApplyMap('Map_Konditionen_Date_temp', KonditionBaseKey, Null())) as EndDatum_temp,
    CashFlowKonditionTyp,
    BetragProjahr,
    CashFlowRelevantVermietet,
    CashFlowRelevantLeerstehend,
//    Kommentar,
    Indexierung,
    BasisIndexwert,
    IndexDatum_temp,
    DatumLetzteBKUeberwaehlzung_temp,
    Zahlungsmodalitaet,
    Referenzzinssatz_mod as Referenzzinssatz,
    letzteAnpassungRefZinssatz_temp
//   Bearbeitungsdatum_temp

Resident Konditionen_temp4;


// Need to do this cleanup, as there are errors in the data (validation check did not work in WS)
LEFT JOIN (Konditionen_temp3)
LOAD Distinct
	%KonditionKey,
    FirstValue(Date(Floor(ErstelltAm_temp))) as ErstelltAm_temp,
    FirstValue(Date(VisiertAm_temp)) as VisiertAm_temp,
    FirstValue(VisiertVon) as VisiertVon_temp,
    FirstValue(Kommentar) as Kommentar_temp,
//    FirstValue(BetragProjahr) as BetragProjahr_temp,
    FirstValue(Timestamp(Bearbeitungsdatum_temp)) as Bearbeitungsdatum_temp

Resident Konditionen_temp4
GROUP BY %KonditionKey;
DROP TABLE Konditionen_temp4;

// Get the MO % MVR Ids from Lease Id
LEFT JOIN (Konditionen_temp3)
LOAD
	%MietverhaeltnisID as MietverhaeltnisID, //join on this
    RefMietobjektID as MietobjektID,
    RefMietvertragID as MietvertragID

//Resident Mietverhaeltnisse_temp;
FROM [$(vStorePath)RF_TR-Mietverhaeltnisse.qvd] (qvd);


Konditionen_temp2:
NoConcatenate
LOAD Distinct
    %KonditionKey,
    KonditionBaseKey,
    WirtschaftseinheitsID,
    MietverhaeltnisID,
    MietobjektID,
    MietvertragID,
    ErstelltAm_temp as Kondition_ErstelltAm,
    VisiertAm_temp as Kondition_VisiertAm,
    VisiertVon_temp as Kondition_VisiertVon,
    CashFlowKonditionTyp,
  //  BetragProjahr_temp as BetragProjahr,
    If(Len(Trim(BetragProjahr))>0, BetragProjahr, '0') as BetragProjahr_temp,
    CashFlowRelevantVermietet,
    CashFlowRelevantLeerstehend,
    Indexierung as Kondition_Indexierung,
    BasisIndexwert as Kondition_BasisIndexwert,
    IndexDatum_temp as Kondition_IndexDatum,
    DatumLetzteBKUeberwaehlzung_temp as DatumLetzteBKUeberwaehlzung,
    Zahlungsmodalitaet,
    Referenzzinssatz,
    Kommentar_temp as Kondition_Kommentar,
    letzteAnpassungRefZinssatz_temp as letzteAnpassungRefZinssatz,
    //If(StartDatum_temp < '$(vIVM_MinStartDate)', '$(vIVM_MinStartDate)', StartDatum_temp) as Kondition_StartDatum,
    StartDatum_temp as Kondition_StartDatum,
    StartDatum_temp as StartDatumKond_orig,
    EndDatum_temp as EndDatumKond_orig,
    Coalesce(If(Len(Trim(EndDatum_temp))>0 AND EndDatum_temp < ApplyMap('Map_MO_Date', MietobjektID) , If(EndDatum_temp < StartDatum_temp, StartDatum_temp, EndDatum_temp),
     Date(If(MVKondKey = Previous(MVKondKey), If(StartDatum_temp = Previous(StartDatum_temp), StartDatum_temp, Previous(StartDatum_temp)-1)))), ApplyMap('Map_MO_Date', MietobjektID, Null())) as Kondition_EndDatum,
	
    Coalesce(If(Len(Trim(EndDatum_temp))>0 AND EndDatum_temp < ApplyMap('Map_MVR_Date', MietvertragID) , If(EndDatum_temp < StartDatum_temp, StartDatum_temp, EndDatum_temp),
     Date(If(MVKondKey = Previous(MVKondKey), If(StartDatum_temp = Previous(StartDatum_temp), StartDatum_temp, MonthEnd(AddMonths(Previous(StartDatum_temp), -1)))))), 
      If(Len(Trim(ApplyMap('Map_MVR_Date', MietvertragID, Null())))>0, ApplyMap('Map_MVR_Date', MietvertragID, Null()), ApplyMap('Map_MO_Date', MietobjektID, Null())))  as KondFakten_EndDatum
//     If(Len(Trim(EndDatum_temp_new))>0, EndDatum_temp_new,
//      Date(If(CashFlowKonditionTyp = Previous(CashFlowKonditionTyp), If(StartDatum_temp = Previous(StartDatum_temp), StartDatum_temp, Previous(StartDatum_temp)-1)))) as Kondition_EndDatum

Resident Konditionen_temp3
ORDER BY MVKondKey, StartDatum_temp DESC;
DROP TABLE Konditionen_temp3;

// *** Mapping
Max_KonditionVer_Date:
Mapping LOAD
	MietverhaeltnisID & '$(vKeySep)' & CashFlowKonditionTyp as MVCCTypeKey,
    Max(Kondition_StartDatum) as MaxKonditionbyMVDate

Resident Konditionen_temp2
GROUP BY MietverhaeltnisID, CashFlowKonditionTyp;

Konditionen_neu:
NoConcatenate
LOAD Distinct
	*,
    If(Num(Kondition_StartDatum) = ApplyMap('Max_KonditionVer_Date', MietverhaeltnisID & '$(vKeySep)' & CashFlowKonditionTyp), '1', '0') as Kondition_LatestFlag

Resident Konditionen_temp2;
DROP TABLE Konditionen_temp2;
RENAME TABLE Konditionen_neu TO Konditionen_temp2;

Konditionen_temp:
NoConcatenate
LOAD Distinct
	%KonditionKey,
    KonditionBaseKey,
    WirtschaftseinheitsID,
	num(letzteAnpassungRefZinssatz) as %LIK_Indexstand, //Key für KPI Indexstand
//	MietverhaeltnisID as RefKondMietverhaeltnisID,
    Kondition_ErstelltAm,
    Kondition_VisiertAm,
    Kondition_VisiertVon,
    CashFlowKonditionTyp,
    BetragProjahr_temp as BetragProjahr,
    CashFlowRelevantVermietet,
    CashFlowRelevantLeerstehend,
    Kondition_Indexierung,
    Kondition_BasisIndexwert,
    Kondition_IndexDatum,
    DatumLetzteBKUeberwaehlzung,
    Zahlungsmodalitaet,
    Referenzzinssatz,
    Kondition_Kommentar,
    letzteAnpassungRefZinssatz,
    Kondition_StartDatum,
    StartDatumKond_orig,
    Kondition_EndDatum,
    EndDatumKond_orig,
    Kondition_LatestFlag,
    MietobjektID as RefKondMO,
    MietvertragID as RefKondMVR,
    MietobjektID & '$(vKeySep)' & %KonditionKey as %KeyToKondition
    
Resident Konditionen_temp2;

//DROP TABLE Konditionen_temp2;


// Store QVD
Call QvdStore ('Konditionen_temp2', '$(vStorePath)', 'temp', 'Konditionen_temp', '*', 1);

//hsc, 07.09.2022
//******************************************** Start Berechnug KPI Indesstände ********************************************************
//Ergänzung vom passenden KPI-Indexstand (derjenige, welcher zum Zeitpunkt der letzten Anpassung an den Referenzzinssatz gültig war)
//*************************************************************************************************************************************
 
//temporäre Tabelle mit allen eindeutigen Zeitpunkten der letzten Anpassung an den RefZinssatz (nur nicht leere Records)
tmp:
NoConcatenate LOAD
    Distinct num(letzteAnpassungRefZinssatz) as %LIK_Indexstand
Resident Konditionen_temp
where not IsNull(letzteAnpassungRefZinssatz);
 
//Bilde für jedes letztes Anpassungsdatum alle Kombinationen mit allen Indexständen der Zeitreihe (enthält pro Monat einen Indexstand)
tmp:
Join(tmp)
Load
    num(date(date#(text(periodCode)&'01','YYYYMMDD'))) as [LIK_Indexstand],
    indexValue
FROM [lib://0100_Global/02_Datamodel/01_qvd/consumerPriceIndex.qvd]
(qvd);
 
//Differenzen zu allen Indexständen
diffs_all:
load
[%LIK_Indexstand],
indexValue,
[LIK_Indexstand],
%LIK_Indexstand - [LIK_Indexstand] as diff
Resident tmp;
Drop Table tmp;
 
//Relevant sind nur die positiven Differenzen (entspricht den Indexständen, welche sich zeitlich vor der letzten Anpassung befinden)
diffs_positive:
NoConcatenate load
*
Resident diffs_all
where diff >= 0;
Drop Table diffs_all;
 
//Für jedes Anpassungsdatum wird die tiefste Abweichung berechnet (entspricht dem nächsttiefen Indexdatum, resp. dasjenige, welchee zum Zeitpunkt der letzten Anpassung gültig war)
//Danach den passenden Indexstand dazujoinen
right join(diffs_positive)
Load
    %LIK_Indexstand,
    min(diff) as diff
Resident diffs_positive
group by %LIK_Indexstand;
 
//Aktuellen Indexstand auslesen (zuerst alle laden, dann absteigend sortiert und den 1. nehmen)
IndexCurrent_tmp:
NoConcatenate Load
    date(date#(text(periodCode)&'01','YYYYMMDD')) as [DateIndexCurrent],
    indexValue as IndexCurrent
FROM [lib://0100_Global/02_Datamodel/01_qvd/consumerPriceIndex.qvd]
(qvd);
 
//Aktuellen Indexstand auslesen
IndexCurrent:
NoConcatenate First 1 Load
            [DateIndexCurrent],
    IndexCurrent
Resident IndexCurrent_tmp
order by [DateIndexCurrent] desc;
Drop Table IndexCurrent_tmp;
 
//Aktuelle Indexstände in Variablen hinterlegen
Let vIndexCurrent = peek('IndexCurrent',0,'IndexCurrent');
Let vDateIndexCurrent = peek('DateIndexCurrent',0,'IndexCurrent');
 
Drop Table IndexCurrent;
 
RezinsAktuell_tmp:
NoConcatenate LOAD
    referenceRate,
    validFrom
FROM [lib://0100_Global/02_Datamodel/01_qvd/mortgageReferenceRates.qvd]
(qvd);
 
RefzinsAktuell:
NoConcatenate First 1 Load
*
Resident RezinsAktuell_tmp
order by validFrom desc;
Drop Table RezinsAktuell_tmp;
 
//Aktueller Referenzzinssatz in Variablen hinterlegen
Let vReferenceRate = peek('referenceRate',0,'RefzinsAktuell');
Let vValidFrom= peek('validFrom',0,'RefzinsAktuell');
 
Drop Table RefzinsAktuell;
 
 
//finaler Datensatz inkl. Berechnung der aufgelaufenen Teuerung (seit der letzten RefzinsAnpassung)
Left join(Konditionen_temp)
Load
    *,
    IndexKPI_aktuell/IndexKPI-1 as AufgelaufeneTeuerung
;
Load
    %LIK_Indexstand,
    indexValue as IndexKPI,
    date([LIK_Indexstand]) as DatumKPI,
    $(vIndexCurrent) as IndexKPI_aktuell,
    date('$(vDateIndexCurrent)') as DatumKPI_aktuell,
    $(vReferenceRate) as RefZinsAktuell,
    date('$(vValidFrom)') as RefZinsGueltigSeit
   
Resident diffs_positive;
Drop table diffs_positive;
 
//******************************************** Ende Berechnug KPI Indesstände ********************************************************


// Store QVD
Call QvdStore ('Konditionen_temp', '$(vStorePath)', 'RF_TR', 'Konditionen', '*', 1);


End If


//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_IVM_Konditionen = (now() - vStartTime_IVM_Konditionen)*86400;
Trace ---------------------------------- IVM_Konditionen geladen ----------------------------------;
Trace $(vElapsed_IVM_Konditionen);
//********************************************************************************************

///$tab 3.4.6 IVM - Fakten neu
//********************************* Start Zeitmessung *********************************
// SET vStartTime_IVM_Fakten = 0;
// Set vElapsed_IVM_Fakten = 0;
Let vStartTime_IVM_Fakten  = now();

//*************************************************************************************

IF Not Isnull(QvdCreateTime('$(vStorePath)temp-Konditionen_temp.qvd')) OR Not Isnull(QvdCreateTime('$(vStorePath)temp-FlaecheMVR_temp.qvd')) OR Not Isnull(QvdCreateTime('$(vStorePath)temp-FlaecheMO_temp.qvd')) Then

LET vCCTyp = 'NET_RENT';

// *** Mapping
Max_KonditionVer_Date:
Mapping LOAD
	MietverhaeltnisID & '$(vKeySep)' & CashFlowKonditionTyp as MVCCTypeKey,
    Max(Kondition_StartDatum) as MaxKonditionbyMVDate

FROM [$(vStorePath)temp-Konditionen_temp.qvd] (qvd)
GROUP BY MietverhaeltnisID, CashFlowKonditionTyp;

// *** Mapping
Max_FlaecheVer_Date:
Mapping LOAD
	RefFlaecheMietverhaeltnisID,
    Max(FlaecheVer_StartDatum) as MaxFlaechebyMVDate

FROM [$(vStorePath)RF_TR-FlaecheVer.qvd] (qvd)
GROUP BY RefFlaecheMietverhaeltnisID;

// *** Mapping
Map_MVR_EndDate:
Mapping LOAD Distinct
	MietvertragID,
    MVR_EndDatum

FROM [$(vStorePath)RF_TR-Mietvertraege.qvd] (qvd);

// *** Mapping
Map_MVR_EndDate_orig:
Mapping LOAD Distinct
	MietvertragID,
    EndDatumMVR_orig

FROM [$(vStorePath)RF_TR-Mietvertraege.qvd] (qvd);

// *** Mapping
Map_MO_EndDate:
Mapping LOAD Distinct
	MietobjektID,
    MOEndDatum

FROM [$(vStorePath)RF_TR-Mietobjekte.qvd] (qvd);

// *** Mapping
Map_MV_EndDate:
Mapping LOAD Distinct
	%MietverhaeltnisID,
    MVEndDatum
    
//Resident Mietverhaeltnisse_temp;
FROM [$(vStorePath)RF_TR-Mietverhaeltnisse.qvd] (qvd);

// *** Mapping
Map_MO_to_MV:
Mapping LOAD Distinct
	%MietverhaeltnisID,
    RefMietobjektID
    
//Resident Mietverhaeltnisse_temp;
FROM [$(vStorePath)RF_TR-Mietverhaeltnisse.qvd] (qvd);

// *** Mapping
Map_MVR_to_MV:
Mapping LOAD Distinct
	%MietverhaeltnisID,
    RefMietvertragID
    
//Resident Mietverhaeltnisse_temp;
FROM [$(vStorePath)RF_TR-Mietverhaeltnisse.qvd] (qvd);

// *** Mapping
Rev_Map_MV_to_MO:
Mapping LOAD Distinct
	RefMietobjektID,
    %MietverhaeltnisID
    
//Resident Mietverhaeltnisse_temp;
FROM [$(vStorePath)RF_TR-Mietverhaeltnisse.qvd] (qvd);

// *** Mapping
Rev_Map_MV_to_MVR:
Mapping LOAD Distinct
	RefMietvertragID,
    %MietverhaeltnisID
    
//Resident Mietverhaeltnisse_temp;
FROM [$(vStorePath)RF_TR-Mietverhaeltnisse.qvd] (qvd);

// *** Mapping 
Map_MVRToMVRVer:
Mapping LOAD Distinct
	MietvertragID,
    %MietvertragVersionKey

FROM [$(vStorePath)RF_TR-Mietvertraege.qvd] (qvd);

// *** Mapping
Map_LeerToMVRVer:
Mapping LOAD Distinct
	%MietvertragVersionKey,
    If(Match(Leerstand, 'True')>0, '1', '0') as Leerstand_new

FROM [$(vStorePath)RF_TR-Mietvertraege.qvd] (qvd);


// Start with Conditions
IVM_Facts_temp3:
NoConcatenate
LOAD
//	'ALL' as %MietobjektVersionKey,
    %KonditionKey,
 //   KonditionBaseKey as RefKonditionBaseKey,
 //   'ALL' as %FlaecheVersionKey,
    MietverhaeltnisID as FactRefMVID,
    MietobjektID as FactRefMO,
    MietvertragID as FactRefMVR,
    'LeaseCashFlowFakten' as FactType,
    CashFlowKonditionTyp as FactSubType,
    BetragProjahr_temp as FactValue,
    Kondition_StartDatum as FactStart,
    If(Num(Kondition_StartDatum) = ApplyMap('Max_KonditionVer_Date', MietverhaeltnisID & '$(vKeySep)' & CashFlowKonditionTyp), '1', '0') as FactLatestFlag,
    WirtschaftseinheitsID as FactRefWE,
    ApplyMap('Map_WE_to_Portfolio', WirtschaftseinheitsID, null()) as FactRefPF,
    Date(Floor(Kondition_EndDatum)) as RefEndDatum,
    Date(Floor(KondFakten_EndDatum)) as RefFaktenEndDatum,
    Date(Floor(ApplyMap('Map_MVR_EndDate', MietvertragID, Null()))) as RefMVREndDatum,
    Date(Floor(ApplyMap('Map_MVR_EndDate_orig', MietvertragID, Null()))) as RefMVREndDatum_orig,
    Date(Floor(ApplyMap('Map_MO_EndDate', MietobjektID, Null()))) as RefMOEndDatum
       
//Resident Konditionen_temp2;
FROM [$(vStorePath)temp-Konditionen_temp.qvd] (qvd);

// Add Rental Contract Areas
Concatenate (IVM_Facts_temp3)
LOAD
//	'ALL' as %MietobjektVersionKey,
 //   'ALL' as %KonditionKey,
  //  'ALL' as RefKonditionBaseKey,
    FlaecheVersionKey_temp as %FlaecheVersionKey,
    MietverhaeltnisID as FactRefMVID,
    ApplyMap('Map_MO_to_MV', MietverhaeltnisID, Null()) as FactRefMO,
    RefMVR as FactRefMVR,
    'LeaseFlaecheFakten' as FactType,
    'MietFlaeche pro Einheit' as FactSubType,
    FlaecheProEinheit as FactValue,
    FlaecheVer_StartDatum as FactStart,
    If(Num(FlaecheVer_StartDatum) = ApplyMap('Max_FlaecheVer_Date', MietverhaeltnisID), '1', '0') as FactLatestFlag, 
    Left(RefMVR, 7) as FactRefWE,
    ApplyMap('Map_WE_to_Portfolio', Left(RefMVR, 7), null()) as FactRefPF,
    Date(Floor(FlaecheVer_EndDatum)) as RefEndDatum,
    Date(Floor(FlaecheFakten_Enddatum)) as RefFaktenEndDatum,
    Date(Floor(ApplyMap('Map_MVR_EndDate', RefMVR, Null()))) as RefMVREndDatum,
    Date(Floor(ApplyMap('Map_MVR_EndDate_orig', RefMVR, Null()))) as RefMVREndDatum_orig,
    Date(Floor(ApplyMap('Map_MO_EndDate', ApplyMap('Map_MO_to_MV', MietverhaeltnisID, Null()), Null()))) as RefMOEndDatum
        
//Resident Flaeche_MVR_temp;
FROM [$(vStorePath)temp-FlaecheMVR_temp.qvd] (qvd);


// Add Area Unit Areas
Concatenate (IVM_Facts_temp3)
LOAD
// 	'ALL' as %MietobjektVersionKey,
//     'ALL' as %KonditionKey,
//     'ALL' as RefKonditionBaseKey,    
    FlaecheVersionKey_temp as %FlaecheVersionKey,
    MietverhaeltnisID as FactRefMVID,
    RefMO as FactRefMO,
    ApplyMap('Map_MVR_to_MV', MietverhaeltnisID, Null()) as FactRefMVR,
    'LeaseFlaecheFakten' as FactType,
    'ObjektFlaeche pro Einheit'as FactSubType,
    FlaecheProEinheit as FactValue,
    FlaecheVer_StartDatum as FactStart,
    If(Num(FlaecheVer_StartDatum) = ApplyMap('Max_FlaecheVer_Date', MietverhaeltnisID), '1', '0') as FactLatestFlag,
    Left(RefMO, 7) as FactRefWE,
    ApplyMap('Map_WE_to_Portfolio', Left(RefMO, 7), null()) as FactRefPF,
    Date(Floor(FlaecheVer_EndDatum)) as RefEndDatum,
    Date(Floor(FlaecheFakten_Enddatum)) as RefFaktenEndDatum,
    Date(Floor(ApplyMap('Map_MVR_EndDate', ApplyMap('Map_MVR_to_MV', MietverhaeltnisID, Null()), Null()))) as RefMVREndDatum,
    Date(Floor(ApplyMap('Map_MVR_EndDate_orig', ApplyMap('Map_MVR_to_MV', MietverhaeltnisID, Null()), Null()))) as RefMVREndDatum_orig,
    Date(Floor(ApplyMap('Map_MO_EndDate', RefMO, Null()))) as RefMOEndDatum
    
//Resident Flaeche_MO_temp;
FROM [$(vStorePath)temp-FlaecheMO_temp.qvd] (qvd);


// Add Area Unit Versions
Concatenate (IVM_Facts_temp3)
LOAD
    %MietobjektVersionKey,
//     'ALL' as %KonditionKey,
//     'ALL' as RefKonditionBaseKey,
//     'ALL' as %FlaecheVersionKey,
	ApplyMap('Rev_Map_MV_to_MO', MietobjektID, Null()) as FactRefMVID,
    MietobjektID as FactRefMO,
    ApplyMap('Map_MVR_to_MV', ApplyMap('Rev_Map_MV_to_MO', MietobjektID), Null()) as FactRefMVR,
    'LeaseObjektFakten' as FactType,
    'AnzahlObjekt' as FactSubType,
    If(Not Match(Hauptnutzung, 'Einstellplätze', 'Aussenabstellplätze')>0, '1', Anzahl) as FactValue,
    MO_Ver_StartDatum as FactStart,
    MO_Ver_LatestFlag as FactLatestFlag,   
    Left(MietobjektID, 7) as FactRefWE,
    ApplyMap('Map_WE_to_Portfolio', Left(MietobjektID, 7), null()) as FactRefPF,
    Date(Floor(MO_Ver_EndDatum)) as RefEndDatum,
    Date(Floor(MO_Ver_EndDatum)) as RefFaktenEndDatum,
    Date(Floor(ApplyMap('Map_MVR_EndDate', ApplyMap('Map_MVR_to_MV', ApplyMap('Rev_Map_MV_to_MO', MietobjektID), Null()), Null()))) as RefMVREndDatum,
    Date(Floor(ApplyMap('Map_MVR_EndDate_orig', ApplyMap('Map_MVR_to_MV', ApplyMap('Rev_Map_MV_to_MO', MietobjektID), Null()), Null()))) as RefMVREndDatum_orig,   
    Date(Floor(MOEndDatum)) as RefMOEndDatum
    
//Resident Mietobjekte_Versionen_temp;
FROM [$(vStorePath)RF_TR-Mietobjekte.qvd] (qvd);


// MieterspiegelFakten_temp:
// NoConcatenate
// LOAD Distinct
// 	FactRefPF & '$(vKeySep)' & FactRefWE & '$(vKeySep)' & Coalesce(FactRefMVID, 'All') & '$(vKeySep)' & Coalesce(FactRefMO, 'All') & '$(vKeySep)' & Coalesce(FactRefMVR, 'All') & '$(vKeySep)' &Num(FactStart)& '$(vKeySep)' & FactSubType as %FaktenKey,
//     FactRefMVID,
//     FactRefMO,
//     FactRefMVR,
//     FactType as FaktenTyp,
//     FactSubType as SubTyp,
//     FactValue as MTHFaktenWert,
//     FactStart as FaktenValidFrom,
//     FactLatestFlag,
//     FactRefWE,
//     FactRefPF,
//     RefEndDatum as FaktenValidTo,
//     RefFaktenEndDatum,
//     RefMVREndDatum,
//     RefMVREndDatum_orig,
//     RefMOEndDatum
// //    FactRefMVR&'-'&Date(RefEndDatum, 'MM-YYYY') as %KeyKondition,
// //     FactRefMVID&'-'&Date(RefEndDatum, 'MM-YYYY') as %KeyFlaeche,
// //     FactRefMO&'-'&Date(RefEndDatum, 'MM-YYYY') as %KeyMietobjekt,
// //     FactRefMVR&'-'&Date(RefEndDatum, 'MM-YYYY') as %KeyMietvetrag,
// //     FactRefMVID&'-'&Date(RefEndDatum, 'MM-YYYY') as %KeyMietverhaeltnis

// Resident IVM_Facts_temp3;
// // DROP TABLE IVM_Facts_temp3;

// // Prepare Monthly IVM-Facts
// IVM_Facts_MTH_prep:
// NoConcatenate
// LOAD
// 	%FaktenKey,
// 	FaktenTyp as MTHFaktenTyp,
// 	SubTyp as MTHSubTyp,
// 	Sum(MTHFaktenWert)/12 as MTHFaktenWert,
// 	FaktenValidFrom as MTHFaktenValidFrom,
// 	FaktenValidTo as MTHFaktenValidTo,
//     FactRefMVID as MTHFactRefMVID,
//     FactRefPF as MTHFactRefPF,
//     FactRefWE as MTHFactRefWE,
//     FactRefMO as MTHFactRefMO,
//     FactRefMVR as MTHFactRefMVR

// Resident MieterspiegelFakten_temp
// //WHERE Not Match(SubTyp, 'AnzahlObjekt')>0
// GROUP BY
// 	%FaktenKey,
// 	FaktenTyp,
// 	SubTyp,
// 	FaktenValidFrom,
// 	FaktenValidTo,
//     FactRefMVID,
//     FactRefPF,
//     FactRefWE,
//     FactRefMO,
//     FactRefMVR
// ;


// are 13/11/22: skip the creation of the Yearly-Fact Table, create the monthly table directly
// Prepare Monthly IVM-Facts
IVM_Facts_MTH_prep:
NoConcatenate
LOAD
	FactRefPF & '$(vKeySep)' & FactRefWE & '$(vKeySep)' & Coalesce(FactRefMVID, 'All') & '$(vKeySep)' & Coalesce(FactRefMO, 'All') & '$(vKeySep)' & Coalesce(FactRefMVR, 'All') & '$(vKeySep)' &Num(FactStart)& '$(vKeySep)' & FactSubType as %FaktenKey,
	FactType as FaktenTyp,
	FactSubType as SubTyp,
    FactLatestFlag,
	Sum(FactValue)/12 as MTHFaktenWert,
	FactStart as FaktenValidFrom,
	RefFaktenEndDatum as FaktenValidTo,  // a modified End Date is being produced in order to avoid middle-month cuts
    FactRefMVID as FactRefMVID,
    FactRefPF as FactRefPF,
    FactRefWE as FactRefWE,
    FactRefMO as FactRefMO,
    FactRefMVR as FactRefMVR

Resident IVM_Facts_temp3
//WHERE Not Match(SubTyp, 'AnzahlObjekt')>0
GROUP BY
//	%FaktenKey,
	FactType,
	FactSubType,
	FactStart,
    FactLatestFlag,
	RefFaktenEndDatum,
    FactRefMVID,
    FactRefPF,
    FactRefWE,
    FactRefMO,
    FactRefMVR
;


IVM_MTH_Facts_temp2:
NoConcatenate
LOAD Distinct
	%FaktenKey,
//     MTHFaktenTyp,
// 	MTHSubTyp,
// 	MTHFaktenWert,
// 	MTHFaktenValidFrom,
// 	MTHFaktenValidTo,
//     MTHFactRefMVID,
//     MTHFactRefPF,
//     MTHFactRefWE,
//     MTHFactRefMO,
//     MTHFactRefMVR,
    FaktenTyp,
	SubTyp,
    FactLatestFlag,
	MTHFaktenWert,
	FaktenValidFrom,
	FaktenValidTo,
    FactRefMVID,
    FactRefPF,
    FactRefWE,
    FactRefMO,
    FactRefMVR,
    Date(AddMonths(Date(Floor(MonthStart(Date(FaktenValidFrom)))), IterNo()-1), 'MMM-YY') as MonthYear
    
Resident IVM_Facts_MTH_prep
WHILE AddMonths(Date(Floor(MonthStart(Date(FaktenValidFrom)))), IterNo()-1) <= Date(Floor(MonthEnd(Date(FaktenValidTo))));
DROP TABLE IVM_Facts_MTH_prep;


// Create monthly facts
MieterspiegelMTHFakten_temp:
NoConcatenate
LOAD Distinct
	%FaktenKey,
//    	MTHFactRefPF & '$(vKeySep)' & MTHFactRefWE & '$(vKeySep)' & Coalesce(MTHFactRefMVID, 'All') & '$(vKeySep)' & Coalesce(MTHFactRefMO, 'All') & '$(vKeySep)' & Coalesce(MTHFactRefMVR, 'All') & '$(vKeySep)' & MonthYear & '$(vKeySep)' &Num(MTHFaktenValidFrom) as RefMTHFaktenKey,
// 	MTHFaktenTyp,
// 	MTHSubTyp,
// 	MTHFaktenWert,
// 	MTHFaktenValidFrom,
// 	MTHFaktenValidTo,
    FactRefPF & '$(vKeySep)' & FactRefWE & '$(vKeySep)' & Coalesce(FactRefMVID, 'All') & '$(vKeySep)' & Coalesce(FactRefMO, 'All') & '$(vKeySep)' & Coalesce(FactRefMVR, 'All') & '$(vKeySep)' & MonthYear & '$(vKeySep)' &Num(FaktenValidFrom) as RefMTHFaktenKey,
	FaktenTyp,
	SubTyp,
    FactLatestFlag,
	MTHFaktenWert,
	FaktenValidFrom,
	FaktenValidTo,
//    MonthYear as RefMTHY,
    Dual(Year(Date(MonthYear))& '-' &Num(Month(Date(MonthYear)), '00'), Year(Date(MonthYear)) & Num(Month(Date(MonthYear)), '00')) as JahrMonat,
    Year(Date(MonthYear)) as FaktenJahr,
    Month(Date(MonthYear)) as FaktenMonat,
//     MTHFactRefMVID,
//     MTHFactRefPF,
//     MTHFactRefWE,
//     MTHFactRefMO,
//     MTHFactRefMVR
    FactRefMVID,
    FactRefPF,
    FactRefWE,
    FactRefMO,
    FactRefMVR
//    MTHRefMVMonthYear
    
Resident IVM_MTH_Facts_temp2
WHERE NOT IsNull(%FaktenKey);
//WHERE Match(FactType, 'LeaseCashFlowFakten')>0;
//WHERE Match(FaktenTyp, 'LeaseCashFlowFakten')>0;
DROP TABLE IVM_MTH_Facts_temp2;


// Store QVD
Call QvdStore ('IVM_Facts_temp3', '$(vStorePath)', 'temp', 'IVM_Facts_temp', '*', 1);

// Store QVD
// Call QvdStore ('MieterspiegelFakten_temp', '$(vStorePath)', 'RF_TR', 'MieterspiegelFakten', '*', 1);

// Store QVD
Call QvdStore ('MieterspiegelMTHFakten_temp', '$(vStorePath)', 'RF_TR', 'MieterspiegelMTH', '*', 1);


END IF

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_IVM_Fakten = (now() - vStartTime_IVM_Fakten)*86400;
Trace ---------------------------------- IVM_Fakten geladen ----------------------------------;
Trace $(vElapsed_IVM_Fakten);
//********************************************************************************************
///$tab 3.4.7 IVM - Bridge neu
// done in the Global 4.1 Bridge!
///$tab 3.4.8 IVM - Fluktuation
//********************************* Start Zeitmessung *********************************
// SET vStartTime_IVM_Flukt = 0;
// Set vElapsed_IVM_Flukt = 0;
Let vStartTime_IVM_Flukt  = now();

//*************************************************************************************

IF Not Isnull(QvdCreateTime('$(vStorePath)RF_TR-Mietvertraege.qvd')) Then

// IVM_Flukt_temp5:
// NoConcatenate
// LOAD Distinct
//     %MietverhaeltnisID,
//     RefMO as MietobjektID,
//     RefMVR as MietvertragID,
//     RefWE
    
// FROM [$(vStorePath)temp-IVMBridge_temp.QVD](qvd);

IVM_Flukt_temp5:
NoConcatenate
LOAD Distinct
    FactRefMVID as %MietverhaeltnisID,
    FactRefMO as MietobjektID,
    FactRefMVR as MietvertragID,
    FactRefWE as RefWE
    
//FROM [$(vStorePath)RF_TR-MieterspiegelFakten.QVD](qvd);  // are: taken new from the MSP-Facts
FROM [$(vStorePath)RF_TR-MieterspiegelMTH.QVD](qvd);  // are: taken new from the MSP-Facts

LEFT JOIN (IVM_Flukt_temp5)
LOAD Distinct
	MietvertragID,
    MieterName,
    Leerstand,
    MVR_StartDatum,
    MVR_EndDatum

FROM [$(vStorePath)RF_TR-Mietvertraege.QVD](qvd);


IVM_Flukt_temp4:
LOAD Distinct
	%MietverhaeltnisID,
    MietobjektID,
    MietvertragID,
    MieterName,
    Leerstand,
    Coalesce(MieterName, '') as MieterName_mod,
    If(Len(Trim(MieterName))>0,'False', 'True') as Leerstand_mod,
    MVR_StartDatum,
	Date(If(MietobjektID = Previous(MietobjektID), If(MVR_StartDatum = Previous(MVR_StartDatum), MVR_StartDatum, Previous(MVR_StartDatum)-1), 
      MVR_EndDatum)) as MVR_EndDatum_new

Resident IVM_Flukt_temp5
ORDER BY MietobjektID, MVR_StartDatum DESC;
DROP TABLE IVM_Flukt_temp5;


IVM_Flukt_temp3:
NoConcatenate
LOAD Distinct
	%MietverhaeltnisID,
    MietobjektID,
    MietvertragID,
    MieterName,
    MieterName_mod,
    Leerstand,
    MVR_StartDatum as StartDatum,
    MVR_EndDatum_new as EndDatum,
    If(MietobjektID=Previous(MietobjektID),
    	If(MieterName_mod=Previous(MieterName_mod) OR Previous(Leerstand_mod)='True', '0', '1'),'0') as Flukt_temp

Resident IVM_Flukt_temp4
ORDER BY %MietverhaeltnisID, MietobjektID, MietvertragID ASC;
DROP TABLE IVM_Flukt_temp4;

IVM_Flukt_temp2:
NoConcatenate
LOAD Distinct
	%MietverhaeltnisID,
    MietobjektID,
    MietvertragID,
    MieterName,
    MieterName_mod,
    Leerstand,
    StartDatum,
    EndDatum,
    Flukt_temp as Flukt,
    Date(AddYears(Date(Floor(YearStart(Date(StartDatum)))), IterNo()-1), 'YYYY') as Year

Resident IVM_Flukt_temp3
WHILE AddYears(Date(Floor(YearStart(Date(StartDatum)))), IterNo()-1) <= Date(Floor(YearEnd(EndDatum)));

DROP TABLE IVM_Flukt_temp3;

IVM_Flukt_temp:
NoConcatenate
LOAD Distinct
	%MietverhaeltnisID as MietverhaeltnisID,
    MietobjektID as %MietobjektID,
    MietvertragID,
    MieterName,
    Leerstand,
//     StartDatum,
//     EndDatum,
    "Year",
    If(Flukt=Previous(Flukt), If(MieterName_mod=Previous(MieterName_mod), Flukt-Previous(Flukt), Flukt), Flukt) as Flukt_diff
//    Flukt
// 	Flukt-Previous(Flukt) as Diff_Flukt

Resident IVM_Flukt_temp2
ORDER BY MietvertragID ASC, StartDatum ASC;

DROP TABLE IVM_Flukt_temp2;

// Store QVD
Call QvdStore ('IVM_Flukt_temp', '$(vStorePath)', 'RF_TR', 'IVM_Fluktuation', '*', 1);

END IF

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_IVM_Flukt = (now() - vStartTime_IVM_Flukt)*86400;
Trace ---------------------------------- IVM_Fluktuation geladen ----------------------------------;
Trace $(vElapsed_IVM_Flukt);
//********************************************************************************************
///$tab 3.4.9 IVM - Zinsszenario
//********************************* Start Zeitmessung *********************************
// SET vStartTime_IVM_Zinsszenario = 0;
// Set vElapsed_IVM_Zinsszenario = 0;
Let vStartTime_IVM_Zinsszenario  = now();

//*************************************************************************************

//IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_IVM_Mietobjekt_Konditionen.qvd')) AND Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_IVM_Mietvertrag_Konditionen.qvd')) Then

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_IVM_Mietobjekt_Konditionen.qvd')) Then

// Zinsszenario_tmp:
// LOAD
//     MietvertragID as %MietvertragID,
//     If(Referenzzinssatz>1, If(Referenzzinssatz>1000, Referenzzinssatz/100000, Referenzzinssatz/100), Referenzzinssatz) as Referenzzinssatz
// FROM [$(vSourcePath)DS_api_IVM_Mietvertrag_Konditionen.qvd]
// (qvd);

Zinsszenario_tmp:
LOAD
    MietobjektID as %MietobjektID,
    If(Referenzzinssatz>1, If(Referenzzinssatz>1000, Referenzzinssatz/100000, Referenzzinssatz/100), Referenzzinssatz) as Referenzzinssatz
FROM [$(vSourcePath)DS_api_IVM_Mietobjekt_Konditionen.qvd]   //are: taken new from Mietobjekt-Konditionen (there are no Conditions on the renatl contracts anymore Nov-2022)
(qvd);


left Join
LOAD Distinct
num(refzins) as Referenzzinssatz,
*
FROM [lib://0100_Global/04_Datasource/04_Excel/refzinssatz.xlsx]
(ooxml, embedded labels, table is Table1);

drop field refzins from Zinsszenario_tmp;


Zinsszenario:
Crosstable(Referenzzins_Neu,Senkungspotenzial,2)
Load Distinct
*
resident Zinsszenario_tmp;
drop Table Zinsszenario_tmp;


// Store QVD
Call QvdStore ('Zinsszenario', '$(vStorePath)', 'RF_TR', 'Zinsszenario', '*', 1);

End If


//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_IVM_Zinsszenario = (now() - vStartTime_IVM_Zinsszenario)*86400;
Trace ---------------------------------- IVM_Zinsszenario geladen ----------------------------------;
Trace $(vElapsed_IVM_Zinsszenario);
//********************************************************************************************


///$tab Ende IVM Area Model 3.4 <
//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_IVMAreaModel = (now() - vStartTime_IVMAreaModel)*86400;
Trace ---------------------------------- IVMAreaModel geladen ----------------------------------;
Trace $(vElapsed_IVMAreaModel);
//********************************************************************************************

///$tab Ende Fakten  3. <<
//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_FACT = (now() - vStartTime_FACT)*86400;
Trace ---------------------------------- FACTS geladen ----------------------------------;
Trace $(vElapsed_FACT);
//********************************************************************************************

///$tab >> 4. Bridge & Link
//********************************* Start Zeitmessung *********************************
// SET vStartTime_BridgeLink = 0;
// Set vElapsed_BridgeLink = 0;
Let vStartTime_BridgeLink  = now();

//*************************************************************************************
///$tab 4.1 Bridge_Table
//********************************* Start Zeitmessung *********************************
// SET vStartTime_BridgePrep = 0;
// Set vElapsed_BridgePrep = 0;
Let vStartTime_BridgePrep  = now();

//*************************************************************************************

//Preparation LinktoBridge-Table

IF Not Isnull(QvdCreateTime('$(vStorePath)temp-BewertungenFakten.qvd')) Then

Bridge_temp5:
NoConcatenate
LOAD Distinct
  	%BewertungKey as %FaktenKey,
//   Hash128(%BewertungKey) as %FaktenKey,
//    %BewertungKey as RefFaktenKey,
    %BewertungsID,
    BewValidFrom as FactValidFrom,
    BewValidTo as FactValidTo,
    'ConcatFact' as LinkKategorie,
    '' as LinkSubKategorie,
    If(Len(Trim(SubField(%BewertungKey, '$(vKeySep)', 1)))>0, SubField(%BewertungKey, '$(vKeySep)', 1), 'All') as RefPortfolioId,
    If(Len(Trim(SubField(%BewertungKey, '$(vKeySep)', 2)))>0, SubField(%BewertungKey, '$(vKeySep)', 2), 'All') as RefWE
// Resident Bewertungen_Fakten;
// DROP TABLE Bewertungen_Fakten;
FROM [$(vStorePath)temp-BewertungenFakten.qvd] (qvd);

ELSE

Bridge_temp5:
NoConcatenate
LOAD * Inline [
%FaktenKey, %BewertungsID, FactValidFrom, FactValidTo, LinkKategorie, LinkSubKategorie, RefPortfolioId, RefWE
];

END IF

IF Not Isnull(QvdCreateTime('$(vStorePath)temp-AbrechnungenFakten.qvd')) Then

Concatenate (Bridge_temp5)
LOAD Distinct
  	%AbrechnungKey as %FaktenKey,
//   Hash128(%AbrechnungKey) as %FaktenKey,
//    %AbrechnungKey as RefFaktenKey,
    %AbrechnungBudgetID,
    AbrBdgValidFrom as FactValidFrom,
    AbrBdgValidTo as FactValidTo,
    'ConcatFact' as LinkKategorie,
    SubTyp as LinkSubKategorie,
    If(Len(Trim(SubField(%AbrechnungKey, '$(vKeySep)', 1)))>0, SubField(%AbrechnungKey, '$(vKeySep)', 1), 'All') as RefPortfolioId,
    If(Len(Trim(SubField(%AbrechnungKey, '$(vKeySep)', 2)))>0, SubField(%AbrechnungKey, '$(vKeySep)', 2), 'All') as RefWE    
// Resident Abrechnungen_Fakten;
// DROP TABLE Abrechnungen_Fakten;
FROM [$(vStorePath)temp-AbrechnungenFakten.qvd] (qvd);

ELSE

Concatenate(Bridge_temp5)
LOAD * Inline [
%AbrechnungBudgetID
];

END IF

IF Not Isnull(QvdCreateTime('$(vStorePath)temp-Einzelbuchungen_temp.qvd')) Then

Concatenate (Bridge_temp5)
LOAD Distinct
  	%BuchungKey as %FaktenKey,
//   Hash128(%BuchungKey) as %FaktenKey,
//    %BuchungKey as RefFaktenKey,
    %BuchungsID,
    BauprojekteID,
    DivisionID,
    BuchungValidFrom as FactValidFrom,
    BuchungValidTo as FactValidTo,
    'ConcatFact' as LinkKategorie,
    SubTyp as LinkSubKategorie,
    If(Len(Trim(SubField(%BuchungKey, '$(vKeySep)', 1)))>0, SubField(%BuchungKey, '$(vKeySep)', 1), 'All') as RefPortfolioId,
    If(Len(Trim(SubField(%BuchungKey, '$(vKeySep)', 2)))>0, SubField(%BuchungKey, '$(vKeySep)', 2), 'All') as RefWE        
FROM [$(vStorePath)temp-EinzelbuchungenFakten.qvd] (qvd);

ELSE

Concatenate(Bridge_temp5)
LOAD * Inline [
%BuchungsID, BauprojekteID, DivisionID,
];

END IF

//tpl
IF Not Isnull(QvdCreateTime('$(vStorePath)temp-LiegenschaftswerteFakten.qvd')) Then

Concatenate (Bridge_temp5)
LOAD Distinct
  	%LSWKey as %FaktenKey,
//   Hash128(%AbrechnungKey) as %FaktenKey,
//    %AbrechnungKey as RefFaktenKey,
//    %LSWID as %AbrechnungBudgetID,
	%LSWID,
    LSWValidFrom as FactValidFrom,
    LSWValidTo as FactValidTo,
    'ConcatFact' as LinkKategorie,
    'Liegenschaftswerte' as LinkSubKategorie,
//    SubTyp as LinkSubKategorie,
    If(Len(Trim(SubField(%LSWKey, '$(vKeySep)', 1)))>0, SubField(%LSWKey, '$(vKeySep)', 1), 'All') as RefPortfolioId,
    If(Len(Trim(SubField(%LSWKey, '$(vKeySep)', 2)))>0, SubField(%LSWKey, '$(vKeySep)', 2), 'All') as RefWE    
// Resident Abrechnungen_Fakten;
// DROP TABLE Abrechnungen_Fakten;
FROM [$(vStorePath)temp-LiegenschaftswerteFakten.qvd] (qvd);

ELSE

Concatenate(Bridge_temp5)
LOAD * Inline [
%LSWID
];

END IF


IF Not Isnull(QvdCreateTime('$(vStorePath)temp-FinanzwertePFFakten.qvd')) Then

Concatenate (Bridge_temp5)
LOAD Distinct
  	%FWKey as %FaktenKey,
//   Hash128(%AbrechnungKey) as %FaktenKey,
//    %AbrechnungKey as RefFaktenKey,
//    %LSWID as %AbrechnungBudgetID,
	%FWID,
    FWValidFrom as FactValidFrom,
    FWValidTo as FactValidTo,
    'ConcatFact' as LinkKategorie,
    'FinanzwertePF' as LinkSubKategorie,
//    SubTyp as LinkSubKategorie,
    If(Len(Trim(SubField(%FWKey, '$(vKeySep)', 1)))>0, SubField(%FWKey, '$(vKeySep)', 1), 'All') as RefPortfolioId,
    If(Len(Trim(SubField(%FWKey, '$(vKeySep)', 2)))>0, SubField(%FWKey, '$(vKeySep)', 2), 'All') as RefWE    
// Resident Abrechnungen_Fakten;
// DROP TABLE Abrechnungen_Fakten;
FROM [$(vStorePath)temp-FinanzwertePFFakten.qvd] (qvd);

ELSE

Concatenate(Bridge_temp5)
LOAD * Inline [
%FWID
];

END IF

// Bridge_Date_Repo:
// NoConcatenate
// LOAD Distinct
// 	FactValidFrom,
//     FactValidTo
// Resident Bridge_temp5;

// LOAD Distinct
// 	FaktenValidFrom as FactValidFrom,
//     FaktenValidTo as FactValidTo
// FROM [$(vStorePath)RF_TR-IVM_Facts.qvd] (qvd);


FactDate_temp_Min:
NoConcatenate
LOAD
	Date(Floor(Min(MonthStart(FactValidFrom)))) as FactMinDate
Resident Bridge_temp5;

FactDate_temp_Max:
NoConcatenate
LOAD
	Date(Floor(Max(MonthEnd(FactValidTo)))) as FactMaxDate
Resident Bridge_temp5;

// Use these Variables for the MasterCalendar creation too...

LET _vStart = num(Peek('FactMinDate', 0, 'FactDate_temp_Min'));
LET _vEnd = num(Peek('FactMaxDate', 0, 'FactDate_temp_Max'));
LET _vNumOfDays = $(_vEnd) - $(_vStart) + 1;

DROP TABLES FactDate_temp_Min, FactDate_temp_Max;

IF Not Isnull(QvdCreateTime('$(vStorePath)RF_MD-Portfolios.qvd')) Then

Bridge_temp4:
NoConcatenate
LOAD Distinct
    %PortfolioID
    
FROM [$(vStorePath)RF_MD-Portfolios.QVD](qvd);

tempPFAll:
NoConcatenate
LOAD Distinct
	%PortfolioID,
    'All' & '$(vKeySep)'& %PortfolioID as AllPFId
    
FROM [$(vStorePath)RF_MD-Portfolios.QVD](qvd);


//END IF

  IF Not Isnull(QvdCreateTime('$(vStorePath)temp-WE_temp.qvd')) Then

  //LEFT JOIN (Bridge_temp4)
  tempPFWEBridgeBasis:
  NoConcatenate
  LOAD Distinct
//      %WirtschaftseinheitNr as RefWE,
	  %WirtschaftseinheitNr,
      PortfolioId as %PortfolioID,
      %WirtschaftseinheitNr & '$(vKeySep)'& PortfolioId as WEPFKey
  FROM [$(vStorePath)temp-WE_temp.qvd] (qvd)
  WHERE Len(Trim(PortfolioId))>0;

  // Add PF&All Combinations
  LOAD Distinct
      'All' as %WirtschaftseinheitNr,
      %PortfolioID,
      AllPFId as WEPFKey

  Resident tempPFAll;
  DROP TABLE tempPFAll;

  LEFT JOIN (Bridge_temp4)
  LOAD Distinct
  	%WirtschaftseinheitNr,
    %PortfolioID,
    WEPFKey   // join on this
  
  Resident tempPFWEBridgeBasis;
  DROP TABLE tempPFWEBridgeBasis;


  END IF
END IF

Bridge_temp3:
NoConcatenate
LOAD Distinct
//	RefWE as %WirtschaftseinheitNr,
	%WirtschaftseinheitNr,
    %PortfolioID,
//	Coalesce(WEPFKey, Coalesce(RefWE, 'All') & '$(vKeySep)'& %PortfolioID) as %WEPFKey
	If(Len(Trim(WEPFKey))>0, WEPFKey, If(Len(Trim(%WirtschaftseinheitNr))>0, %WirtschaftseinheitNr, 'All') & '$(vKeySep)'& %PortfolioID) as %WEPFKey
    
Resident Bridge_temp4;
DROP TABLE Bridge_temp4;

LEFT JOIN (Bridge_temp3)
LOAD Distinct
	%FaktenKey,
//    RefFaktenKey,
	RefWE & '$(vKeySep)'& RefPortfolioId as %WEPFKey,  //join on this
    %BewertungsID,
    %AbrechnungBudgetID,
    %BuchungsID,
    %LSWID,
    %FWID,
    BauprojekteID,
    DivisionID,
    If(Len(Trim(FactValidFrom))>0, FactValidFrom, Date($(_vStart))) as FactValidFrom,
    If(Len(Trim(FactValidTo))>0, FactValidTo, Date($(_vEnd))) as FactValidTo,
    LinkKategorie,
    LinkSubKategorie
//    If(Len(Trim(SubField(%FaktenKey, '$(vKeySep)', 1)))>0, SubField(%FaktenKey, '$(vKeySep)', 1), 'All') as RefPortfolioId,
//    If(Len(Trim(SubField(%FaktenKey, '$(vKeySep)', 2)))>0, SubField(%FaktenKey, '$(vKeySep)', 2), 'All') as RefWE
//     If(Len(Trim(SubField(RefFaktenKey, '$(vKeySep)', 1)))>0, SubField(RefFaktenKey, '$(vKeySep)', 1), 'All') as RefPortfolioId,
//     If(Len(Trim(SubField(RefFaktenKey, '$(vKeySep)', 2)))>0, SubField(RefFaktenKey, '$(vKeySep)', 2), 'All') as RefWE
Resident Bridge_temp5;
DROP TABLE Bridge_temp5;

Bridge_temp2:
NoConcatenate
LOAD Distinct
	Coalesce(%FaktenKey, If(Len(Trim(%PortfolioID))>0, %PortfolioID, 'All') & '$(vKeySep)' & If(Len(Trim(%WirtschaftseinheitNr))>0, %WirtschaftseinheitNr, 'All') & '$(vKeySep)' & 'All') as %FaktenKey,
//    RefFaktenKey,
    %BewertungsID,
    %AbrechnungBudgetID,
    %BuchungsID,
    %LSWID,
    %FWID,
    BauprojekteID as %BauprojekteID,
    DivisionID,
    If(Len(Trim(FactValidFrom))>0, FactValidFrom, Date($(_vStart))) as FactValidFrom,
    If(Len(Trim(FactValidTo))>0, FactValidTo, Date($(_vEnd))) as FactValidTo,
    If(Len(Trim(LinkKategorie))>0, LinkKategorie, 'ConcatFact') as LinkKategorie,
    If(Len(Trim(LinkSubKategorie))>0, LinkSubKategorie, '') as LinkSubKategorie,
    //Coalesce(LinkKategorie, 'ConcatFact') as LinkKategorie,
    //Coalesce(LinkSubKategorie, '') as LinkSubKategorie,
    %PortfolioID as RefPortfolioId,
	%WirtschaftseinheitNr as RefWE
    
Resident Bridge_temp3;
DROP TABLE Bridge_temp3;

// IF Not Isnull(QvdCreateTime('$(vStorePath)RF_TR-Bauprojekte.qvd')) Then

// Concatenate (Bridge_temp2)
// LOAD Distinct
// 	%FaktenKey,
// //    RefFaktenKey,
//     %BauprojekteID,
//     StartDatum as FactValidFrom,
//     If(Len(Trim(EndDatum))>0, EndDatum, Date($(_vEnd))) as FactValidTo,
//   //  EndDatum as FactValidTo,
//     'Bauprojekte' as LinkKategorie,
// 	'' as LinkSubKategorie,
//     If(Len(Trim(SubField(%FaktenKey, '$(vKeySep)', 1)))>0, SubField(%FaktenKey, '$(vKeySep)', 1), 'All') as RefPortfolioId,
//     If(Len(Trim(SubField(%FaktenKey, '$(vKeySep)', 2)))>0, SubField(%FaktenKey, '$(vKeySep)', 2), 'All') as RefWE
// //     If(Len(Trim(SubField(RefFaktenKey, '$(vKeySep)', 1)))>0, SubField(RefFaktenKey, '$(vKeySep)', 1), 'All') as RefPortfolioId,
// //     If(Len(Trim(SubField(RefFaktenKey, '$(vKeySep)', 2)))>0, SubField(RefFaktenKey, '$(vKeySep)', 2), 'All') as RefWE
// //Resident Bauprojekte_temp;
// FROM [$(vStorePath)RF_TR-Bauprojekte.qvd] (qvd);

// END IF


IF Not Isnull(QvdCreateTime('$(vStorePath)RF_TR-Zahlungen.qvd')) Then

// Concatenate (Bridge_temp2)
// LOAD Distinct
// 	%FaktenKey,
//     %ZahlungenID,
//     VertraegeID as %VertraegeID,
//     BauprojekteID as %BauprojekteID,
//     CDPStartDate as FactValidFrom,
// 	If(Len(Trim(CDPEndDate))>0, CDPEndDate, Date($(_vEnd))) as FactValidTo,
//     'Zahlungen' as LinkKategorie,
// 	'' as LinkSubKategorie,
//     If(Len(Trim(SubField(%FaktenKey, '$(vKeySep)', 1)))>0, SubField(%FaktenKey, '$(vKeySep)', 1), 'All') as RefPortfolioId,
//     If(Len(Trim(SubField(%FaktenKey, '$(vKeySep)', 2)))>0, SubField(%FaktenKey, '$(vKeySep)', 2), 'All') as RefWE

// FROM [$(vStorePath)RF_TR-Zahlungen.qvd] (qvd);

Bauprojekte_Bridge_temp2:
NoConcatenate
LOAD Distinct
    %BauprojekteID,
    WirtschaftseinheitsID as RefWE,
    RefPFID as RefPortfolioId,
    StartDatum as FactValidFrom,
    EndDatum as FactValidTo
    
FROM [$(vStorePath)RF_TR-Bauprojekte.QVD] (qvd);

// LEFT JOIN (Bauprojekte_Bridge_temp2)
// LOAD Distinct
//     %BauprojekteID,
//     %VertraegeID
    
// FROM [$(vStorePath)RF_TR-Vertraege.QVD] (qvd);

LEFT JOIN (Bauprojekte_Bridge_temp2)
LOAD Distinct
	BauprojekteID as %BauprojekteID,
    VertraegeID as %VertraegeID,
    %ZahlungenID,
    %FaktenKey as FaktenKey_temp

FROM [$(vStorePath)RF_TR-Zahlungen.qvd] (qvd);

// Bauprojekte_Bridge_temp:
// NoConcatenate
// LOAD Distinct
// 	*,
//     If(Len(Trim(FaktenKey_temp))>0, FaktenKey_temp, 'All') as [%FaktenKey]
    
// Resident Bauprojekte_Bridge_temp2;
// DROP TABLE Bauprojekte_Bridge_temp2;

// DROP FIELD FaktenKey_temp FROM Bauprojekte_Bridge_temp;

Concatenate (Bridge_temp2)
LOAD Distinct
//	%FaktenKey,
	Coalesce(FaktenKey_temp, If(Len(Trim(RefPortfolioId))>0, RefPortfolioId, 'All') & '$(vKeySep)' & If(Len(Trim(RefWE))>0, RefWE, 'All') & '$(vKeySep)' & 'All') as %FaktenKey,
    %ZahlungenID,
    %VertraegeID,
    %BauprojekteID,
    FactValidFrom,
	FactValidTo,
    'Zahlungen Bauprojekte' as LinkKategorie,
	'' as LinkSubKategorie,
    RefPortfolioId,
    RefWE

Resident Bauprojekte_Bridge_temp2;
DROP TABLE Bauprojekte_Bridge_temp2;

ELSE

Concatenate(Bridge_temp2)
LOAD * Inline [
%ZahlungenID, %VertraegeID, %BauprojekteID
];

END IF


IF Not Isnull(QvdCreateTime('$(vStorePath)RF_TR-Investitionsplanung.qvd')) Then

Concatenate (Bridge_temp2)
LOAD Distinct
	%FaktenKey,
//    RefFaktenKey,
    BewertungsID as %BewertungsID,
    VersionID,
    InvPlanValidFrom as FactValidFrom,
    If(Len(Trim(InvPlanValidTo))>0, InvPlanValidTo, Date($(_vEnd))) as FactValidTo,
   // InvPlanValidTo as FactValidTo,
    'InvPlanung' as LinkKategorie,
	'' as LinkSubKategorie,
    If(Len(Trim(SubField(%FaktenKey, '$(vKeySep)', 1)))>0, SubField(%FaktenKey, '$(vKeySep)', 1), 'All') as RefPortfolioId,
    If(Len(Trim(SubField(%FaktenKey, '$(vKeySep)', 2)))>0, SubField(%FaktenKey, '$(vKeySep)', 2), 'All') as RefWE
//     If(Len(Trim(SubField(RefFaktenKey, '$(vKeySep)', 1)))>0, SubField(RefFaktenKey, '$(vKeySep)', 1), 'All') as RefPortfolioId,
//     If(Len(Trim(SubField(RefFaktenKey, '$(vKeySep)', 2)))>0, SubField(RefFaktenKey, '$(vKeySep)', 2), 'All') as RefWE
//Resident Investitionsplanung_temp;
FROM [$(vStorePath)RF_TR-Investitionsplanung.qvd] (qvd);

ELSE

Concatenate(Bridge_temp2)
LOAD * Inline [
VersionID
];


END IF

IF Not Isnull(QvdCreateTime('$(vStorePath)RF_TR-Hypotheken.qvd')) Then

Concatenate (Bridge_temp2)
LOAD Distinct
	%FaktenKey,
//    RefFaktenKey,
    %HypothekID,
    RahmenkreditID as %RahmenkreditID,
    StartDatum as FactValidFrom,
    If(Len(Trim(Faelligkeit))>0, Faelligkeit, Date($(_vEnd))) as FactValidTo,
  //  Faelligkeit as FactValidTo,
    'Hypotheken' as LinkKategorie,
	'' as LinkSubKategorie,
    If(Len(Trim(SubField(%FaktenKey, '$(vKeySep)', 1)))>0, SubField(%FaktenKey, '$(vKeySep)', 1), 'All') as RefPortfolioId,
    If(Len(Trim(SubField(%FaktenKey, '$(vKeySep)', 2)))>0, SubField(%FaktenKey, '$(vKeySep)', 2), 'All') as RefWE
//     If(Len(Trim(SubField(RefFaktenKey, '$(vKeySep)', 1)))>0, SubField(RefFaktenKey, '$(vKeySep)', 1), 'All') as RefPortfolioId,
//     If(Len(Trim(SubField(RefFaktenKey, '$(vKeySep)', 2)))>0, SubField(RefFaktenKey, '$(vKeySep)', 2), 'All') as RefWE
//Resident Hypotheken_temp;
FROM [$(vStorePath)RF_TR-Hypotheken.qvd] (qvd);

ELSE

Concatenate(Bridge_temp2)
LOAD * Inline [
%HypothekID
];

END IF

IF Not Isnull(QvdCreateTime('$(vStorePath)RF_TR-Rahmenkredite.qvd')) Then

Concatenate (Bridge_temp2)
LOAD Distinct
	%FaktenKey,
//    RefFaktenKey,
    %RahmenkreditID,
    StartDatum as FactValidFrom,
    If(Len(Trim(Faelligkeit))>0, Faelligkeit, Date($(_vEnd))) as FactValidTo,
   // Faelligkeit as FactValidTo,
    'Rahmenkredite' as LinkKategorie,
	'' as LinkSubKategorie,
    If(Len(Trim(SubField(%FaktenKey, '$(vKeySep)', 1)))>0, SubField(%FaktenKey, '$(vKeySep)', 1), 'All') as RefPortfolioId,
    If(Len(Trim(SubField(%FaktenKey, '$(vKeySep)', 2)))>0, SubField(%FaktenKey, '$(vKeySep)', 2), 'All') as RefWE
//     If(Len(Trim(SubField(RefFaktenKey, '$(vKeySep)', 1)))>0, SubField(RefFaktenKey, '$(vKeySep)', 1), 'All') as RefPortfolioId,
//     If(Len(Trim(SubField(RefFaktenKey, '$(vKeySep)', 2)))>0, SubField(RefFaktenKey, '$(vKeySep)', 2), 'All') as RefWE
//Resident Rahmenkredite_temp;
FROM [$(vStorePath)RF_TR-Rahmenkredite.qvd] (qvd);

ELSE

Concatenate(Bridge_temp2)
LOAD * Inline [
%RahmenkreditID
];

END IF

IF Not Isnull(QvdCreateTime('$(vStorePath)RF_TR-Schuldbriefe.qvd')) Then

Concatenate (Bridge_temp2)
LOAD Distinct
	%FaktenKey,
//    RefFaktenKey,
    %SchuldbriefID,
    HypothekID as %HypothekID,
    StartDatum as FactValidFrom,
    If(Len(Trim(Faelligkeit))>0, Faelligkeit, Date($(_vEnd))) as FactValidTo,
   // Faelligkeit as FactValidTo,
    'Schuldbriefe' as LinkKategorie,
	'' as LinkSubKategorie,
    If(Len(Trim(SubField(%FaktenKey, '$(vKeySep)', 1)))>0, SubField(%FaktenKey, '$(vKeySep)', 1), 'All') as RefPortfolioId,
    If(Len(Trim(SubField(%FaktenKey, '$(vKeySep)', 2)))>0, SubField(%FaktenKey, '$(vKeySep)', 2), 'All') as RefWE
//     If(Len(Trim(SubField(RefFaktenKey, '$(vKeySep)', 1)))>0, SubField(RefFaktenKey, '$(vKeySep)', 1), 'All') as RefPortfolioId,
//     If(Len(Trim(SubField(RefFaktenKey, '$(vKeySep)', 2)))>0, SubField(RefFaktenKey, '$(vKeySep)', 2), 'All') as RefWE
//Resident Schuldbriefe_temp;
FROM [$(vStorePath)RF_TR-Schuldbriefe.qvd] (qvd);

ELSE

Concatenate(Bridge_temp2)
LOAD * Inline [
%SchuldbriefID
];

END IF


// Add IVM-Area Model
IF Not Isnull(QvdCreateTime('$(vStorePath)temp-IVM_Facts_temp.qvd')) Then
//IVM_Bridge_temp:
Concatenate(Bridge_temp2)
LOAD Distinct
    FactRefPF & '$(vKeySep)' & FactRefWE & '$(vKeySep)' & Coalesce(FactRefMVID, 'All') & '$(vKeySep)' & Coalesce(FactRefMO, 'All') & '$(vKeySep)' & Coalesce(FactRefMVR, 'All') & '$(vKeySep)' &Num(FactStart)& '$(vKeySep)' & FactSubType as %FaktenKey,
    %FlaecheVersionKey,
	FactRefMO & '$(vKeySep)' & %KonditionKey as %KeyToKondition,
    FactRefMO as %MietobjektID,
    FactRefMVR as %MietvertragID,
    FactRefMVID as %MietverhaeltnisID,
    FactStart as FactValidFrom,
    RefEndDatum as FactValidTo,
    'Mieterspiegel' as LinkKategorie,
    FactSubType as LinkSubKategorie,
    FactRefWE as RefWE,
    FactRefPF as RefPortfolioId

FROM [$(vStorePath)temp-IVM_Facts_temp.qvd] (qvd);
//Resident IVM_Facts_temp

ELSE

Concatenate(Bridge_temp2)
LOAD * Inline [
%FlaecheVersionKey, %KeyToKondition, %MietobjektID, %MietvertragID, %MietverhaeltnisID
];

END IF


// Put it together

Bridge_temp3_woWE:
NoConcatenate
LOAD
	*
Resident Bridge_temp2
WHERE Match(RefWE, 'All')>0;

Bridge_temp2_WE:
NoConcatenate
LOAD
	*
Resident Bridge_temp2
WHERE Not(Match(RefWE, 'All')>0);
DROP TABLE Bridge_temp2;

IF Not Isnull(QvdCreateTime('$(vStorePath)RF_MD-Portfolios.qvd')) Then

LEFT JOIN (Bridge_temp3_woWE)
LOAD Distinct
	PFAncestorID as RefPortfolioId,
    %PortfolioID as PFPortfolioID			// are 08/04/22: sometimes Hypo are linked to Fonds, we have to have the drilldown to PF

// Resident Ancestry_Portfolio_temp;
// DROP TABLE Ancestry_Portfolio_temp;
FROM [$(vStorePath)RF_MD-Portfolios.qvd] (qvd);

END IF

Bridge_temp2_woWE:
NoConcatenate
LOAD
	*,
    Coalesce(PFPortfolioID, 'All') as PFPortfolioID_temp		//have to convert PFId Null to 'All' otherwise the WEs are also Null

Resident Bridge_temp3_woWE;
DROP TABLE Bridge_temp3_woWE;

IF Not Isnull(QvdCreateTime('$(vStorePath)RF_MD-Portfolios.qvd')) Then

PF_temp2:
NoConcatenate
LOAD Distinct
	%PortfolioID

FROM [$(vStorePath)RF_MD-Portfolios.qvd] (qvd);

END IF

IF Not Isnull(QvdCreateTime('$(vStorePath)temp-WE_temp.qvd')) Then

LEFT JOIN (PF_temp2)
LOAD Distinct
	PortfolioId as %PortfolioID,
    %WirtschaftseinheitNr

FROM [$(vStorePath)temp-WE_temp.qvd] (qvd)
WHERE Len(Trim(PortfolioId))>0;

END IF

PF_temp:
NoConcatenate
LOAD Distinct
	%PortfolioID as PortfolioId,
//    %WirtschaftseinheitNr as WirtschaftseinheitsID
	If(Len(Trim(%WirtschaftseinheitNr))>0, %WirtschaftseinheitNr, 'All') as WirtschaftseinheitsID
    
Resident PF_temp2;
DROP TABLE PF_temp2;


LEFT JOIN (Bridge_temp2_woWE)
LOAD Distinct
	PortfolioId as PFPortfolioID_temp,
    WirtschaftseinheitsID
    
//Resident WE_temp;
//FROM [$(vStorePath)temp-WE_temp.qvd] (qvd);
Resident PF_temp;
DROP TABLE PF_temp;


Concatenate (Bridge_temp2_WE)
LOAD Distinct
	%FaktenKey,
//    RefFaktenKey,
    %BewertungsID,
    %AbrechnungBudgetID,
    %BuchungsID,
    %LSWID,
    %FWID,
    %ZahlungenID,
    %VertraegeID,
    %BauprojekteID,
    DivisionID,
    VersionID,
    %HypothekID,
    %RahmenkreditID,
    %SchuldbriefID,
//     %FlaecheVersionKey, 
//     %KeyToKondition, 
//     %MietobjektID, 
//     %MietvertragID, 
//     %MietverhaeltnisID,
    FactValidFrom,
    FactValidTo,
    LinkKategorie,
    LinkSubKategorie,
     If(Len(Trim(RefPortfolioId))>0, RefPortfolioId, If(Len(Trim(SubField(%FaktenKey, '$(vKeySep)', 1)))>0, SubField(%FaktenKey, '$(vKeySep)', 1), 'All')) as RefPortfolioId,
     If(Len(Trim(WirtschaftseinheitsID))>0, WirtschaftseinheitsID, If(Len(Trim(SubField(%FaktenKey, '$(vKeySep)', 2)))>0, SubField(%FaktenKey, '$(vKeySep)', 2), 'All')) as RefWE

Resident Bridge_temp2_woWE;
DROP TABLE Bridge_temp2_woWE;

Bridge_temp:
NoConcatenate
LOAD Distinct
	%FaktenKey,
//    RefFaktenKey,
    %BewertungsID,
    %AbrechnungBudgetID,
    %BuchungsID,
    %LSWID,
    %FWID,
    %ZahlungenID,
    %VertraegeID,
    %BauprojekteID,
    DivisionID,
    VersionID,
    %HypothekID,
    %RahmenkreditID,
    %SchuldbriefID,
    %FlaecheVersionKey, 
    %KeyToKondition, 
    %MietobjektID, 
    %MietvertragID, 
    %MietverhaeltnisID,
    FactValidFrom,
    FactValidTo,
    LinkKategorie,
    LinkSubKategorie,
    MonthYear,
    RefWE,
    RefPortfolioId,
    If(Len(Trim(RefWE))>0, RefWE, 'All') & '$(vKeySep)' & MonthYear as %WEMonthYear
//    If(Len(Trim(SubField(%FaktenKey, '$(vKeySep)', 2)))>0, SubField(%FaktenKey, '$(vKeySep)', 2), 'All') & '$(vKeySep)' & MonthYear as %WEMonthYear
WHERE Num(MonthYear) >= Num($(_vStart)) AND Num(MonthYear) <= Num($(_vEnd))
;
// Preceding load
LOAD
	*,
	Date(AddMonths(Date(Floor(MonthStart(Date(FactValidFrom)))), IterNo()-1), 'MMM-YY') as MonthYear
    
Resident Bridge_temp2_WE
WHILE AddMonths(Date(Floor(MonthStart(Date(FactValidFrom)))), IterNo()-1) <= Date(Floor(MonthStart(FactValidTo)));
DROP TABLE Bridge_temp2_WE;

// Store QVD
//temporary File
Call QvdStore ('Bridge_temp', '$(vStorePath)', 'temp', 'Bridge_temp', '*', 1);


//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_BridgePrep = (now() - vStartTime_BridgePrep)*86400;
Trace ---------------------------------- Bridge Preparation geladen ----------------------------------;
Trace $(vElapsed_BridgePrep);
//********************************************************************************************

///$tab 4.2 WE_Bridge_Table
//********************************* Start Zeitmessung *********************************
// SET vStartTime_WEBridgePrep = 0;
// Set vElapsed_WEBridgePrep = 0;
Let vStartTime_WEBridgePrep  = now();

//*************************************************************************************

WEBridge_temp_Min:
NoConcatenate
LOAD
	Date(Floor(Min(MonthStart(FactValidFrom)))) as WEFactMinDate
FROM [$(vStorePath)temp-Bridge_temp.qvd] (qvd)
//Resident Bridge_temp
WHERE Match(LinkKategorie, 'ConcatFact')>0;

WEBridge_temp_Max:
NoConcatenate
LOAD
	Date(Floor(Max(MonthEnd(FactValidTo)))) as WEFactMaxDate
FROM [$(vStorePath)temp-Bridge_temp.qvd] (qvd)
//Resident Bridge_temp
WHERE Match(LinkKategorie, 'ConcatFact')>0;

// Use these Variables for the MasterCalendar creation too...

LET _vStart = num(Peek('WEFactMinDate', 0, 'WEBridge_temp_Min'));
LET _vEnd = num(Peek('WEFactMaxDate', 0, 'WEBridge_temp_Max'));

DROP TABLES WEBridge_temp_Min, WEBridge_temp_Max;

// Preparation WEtoBridge-Table
we_temp4:
NoConcatenate
LOAD Distinct
    %WirtschaftseinheitNr,
    %WirtschaftseinheitSCDID,
    %WEVersion,
    VersionDate,
    ValidFromDate,
    ValidToDate,
    CurrentFlag,
    PortfolioId
    
//Resident WE_temp;
FROM [$(vStorePath)temp-WE_temp.qvd] (qvd);

// *** Mapping
Mapping_MinVerDate:
Mapping LOAD Distinct
	%WirtschaftseinheitNr,
	Date(Floor(Min(ValidFromDate))) as MinVersionDate
Resident we_temp4
GROUP BY %WirtschaftseinheitNr;

we_temp3:
NoConcatenate
LOAD Distinct
	%WirtschaftseinheitNr,
    %WirtschaftseinheitSCDID,
    %WEVersion,
    VersionDate,
    ValidFromDate,
    ValidToDate,
    CurrentFlag,
//    NewDate,
//     WEValidFrom,
//     WEValidTo,
    PortfolioId,
    ApplyMap('Mapping_MinVerDate', %WirtschaftseinheitNr, Null()) as MinVersionDate,
	Date(If(%WirtschaftseinheitNr = Previous(%WirtschaftseinheitNr), If(ValidFromDate = Previous(ValidFromDate), ValidFromDate, Previous(ValidFromDate)-1), $(vCurrentDate))) as NewDate

Resident we_temp4
ORDER BY %WirtschaftseinheitNr, VersionDate DESC;
DROP TABLE we_temp4;

we_temp2:
NoConcatenate
LOAD
	%WirtschaftseinheitNr,
    %WirtschaftseinheitSCDID,
    %WEVersion,
    VersionDate,
    ValidFromDate,
    ValidToDate,
    CurrentFlag,
    NewDate,
    WEValidFrom,
    WEValidTo,
    PortfolioId,
    MinVersionDate
;
// Preceding load
LOAD
	*,
    If(NewDate = $(vCurrentDate) or NewDate > $(vCurrentDate), Date(Floor(MonthEnd(Date($(_vEnd))))), Date(Floor(MonthEnd(NewDate)))) as WEValidTo,
    If(ValidFromDate = MinVersionDate or ValidFromDate < MinVersionDate, Date(Floor(MonthStart(Date($(_vStart))))), Date(Floor(MonthStart(ValidFromDate)))) as WEValidFrom

Resident we_temp3;
DROP TABLE we_temp3;

WE_Bridge_temp:
NoConcatenate
LOAD Distinct
	%WirtschaftseinheitNr,
    %WirtschaftseinheitSCDID,
    %WEVersion,
    VersionDate,
    ValidFromDate,
    ValidToDate,
    CurrentFlag,
    NewDate,
    WEValidFrom,
    WEValidTo,
	If(Len(Trim(%WirtschaftseinheitNr))>0, %WirtschaftseinheitNr, 'All') & '$(vKeySep)' & MonthYear as %WEMonthYear,
    MonthYear,
    PortfolioId,
    MinVersionDate
;
// Preceding load
LOAD
	*, 
	Date(AddMonths(Date(Floor(MonthStart(WEValidFrom))), IterNo()-1), 'MMM-YY') as MonthYear
    
Resident we_temp2
WHILE AddMonths(Date(Floor(MonthStart(WEValidFrom))), IterNo()-1) <= Date(Floor(MonthStart(WEValidTo)));
DROP TABLE we_temp2;

Wirtschaftseinheiten:
NoConcatenate
LOAD Distinct
	*
FROM [$(vStorePath)temp-WE_temp.qvd] (qvd);

LEFT JOIN (Wirtschaftseinheiten)
LOAD Distinct
	%WirtschaftseinheitSCDID,
	WEValidFrom,
    WEValidTo,
    MinVersionDate
    
Resident WE_Bridge_temp;


// Store QVD
//temporary File
Call QvdStore ('WE_Bridge_temp', '$(vStorePath)', 'temp', 'WE_Bridge_temp', '*', 1);

// Store Final WE-File
Call QvdStore ('Wirtschaftseinheiten', '$(vStorePath)', 'RF_MD', 'Wirtschaftseinheiten', '*', 1);

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_WEBridgePrep = (now() - vStartTime_WEBridgePrep)*86400;
Trace ---------------------------------- Bridge Preparation geladen ----------------------------------;
Trace $(vElapsed_WEBridgePrep);
//********************************************************************************************

///$tab 4.3 Cleanup_Bridge
//********************************* Start Zeitmessung *********************************
// SET vStartTime_cleanBridge = 0;
// Set vElapsed_cleanBridge = 0;
Let vStartTime_cleanBridge  = now();

//*************************************************************************************

// Minimum and maximum FactDate

Bridge_temp_Min:
NoConcatenate
LOAD
	Date(Floor(Min(MonthStart(FactValidFrom)))) as FactMinDate
FROM [$(vStorePath)temp-Bridge_temp.qvd] (qvd)
//Resident Bridge_temp
WHERE Match(LinkKategorie, 'ConcatFact')>0;

Bridge_temp_Max:
NoConcatenate
LOAD
	Date(Floor(Max(MonthEnd(FactValidTo)))) as FactMaxDate
FROM [$(vStorePath)temp-Bridge_temp.qvd] (qvd)
//Resident Bridge_temp
WHERE Match(LinkKategorie, 'ConcatFact')>0;

// Use these Variables for the MasterCalendar creation too...

LET _vStart = num(Peek('FactMinDate', 0, 'Bridge_temp_Min'));
LET _vEnd = num(Peek('FactMaxDate', 0, 'Bridge_temp_Max'));
LET _vNumOfDays = $(_vEnd) - $(_vStart) + 1;

DROP TABLES Bridge_temp_Min, Bridge_temp_Max;


// Final Bridge Table to Link

BridgeToLink_temp5:
NoConcatenate
LOAD Distinct
	%WEMonthYear,
    If(Len(Trim(RefWE))>0, RefWE, 'All') as WE,
    RefPortfolioId as PF,
    MonthYear

FROM [$(vStorePath)temp-Bridge_temp.qvd] (qvd);
//Resident Bridge_temp;

LOAD Distinct
	%WEMonthYear,
	If(Len(Trim(%WirtschaftseinheitNr))>0, %WirtschaftseinheitNr, 'All') as WE,
    PortfolioId as PF,
    MonthYear

FROM [$(vStorePath)temp-WE_Bridge_temp.qvd] (qvd);
//Resident WE_Bridge_temp;

BridgeToLink_temp4:
NoConcatenate
LOAD Distinct
	%WEMonthYear,
	WE,
    PF,
    MonthYear,
    WE & '$(vKeySep)'& PF & '$(vKeySep)'& MonthYear as %WEPFMTHKey

Resident BridgeToLink_temp5;
DROP TABLE BridgeToLink_temp5;

LEFT JOIN (BridgeToLink_temp4)
LOAD Distinct
	%WEMonthYear,
    %WEVersion as WEVersion

FROM [$(vStorePath)temp-WE_Bridge_temp.qvd] (qvd);
//Resident WE_Bridge_temp;

LEFT JOIN (BridgeToLink_temp4)
LOAD  // not distinct!
//  	%WEMonthYear,
    %FaktenKey,
    RefWE & '$(vKeySep)'& RefPortfolioId & '$(vKeySep)'& MonthYear as %WEPFMTHKey
    
FROM [$(vStorePath)temp-Bridge_temp.qvd] (qvd)
WHERE NOT IsNull(%FaktenKey);
//Resident Bridge_temp;


// *** Mapping
Map_BridgeToLink_Ver_temp:
Mapping LOAD Distinct
	PortfolioId,
    Date(Floor(Max(Date#(SubField(%WEVersion, '$(vKeySep)', -1), 'MMM-YY'))), 'MMM-YY') as Version

FROM [$(vStorePath)temp-WE_Bridge_temp.qvd] (qvd)
//Resident WE_Bridge_temp
GROUP BY PortfolioId;

Max_Version_temp:
LOAD Distinct
	Date(Floor(Max(Date#(SubField(WE_Version, '$(vKeySep)', -1), 'MMM-YY'))), 'MMM-YY') as MaxVer

FROM [$(vStorePath)temp-WE_temp.qvd] (qvd);


LET vMaxVer = Peek('MaxVer', 0, 'Max_Version_temp');

DROP TABLE Max_Version_temp;


BridgeToLink_temp3:
NoConcatenate
LOAD Distinct
	%WEMonthYear,
    %FaktenKey,
    MonthYear,
    WE,
    PF,
    Coalesce(WEVersion, WE & '$(vKeySep)' &  If(Len(Trim(ApplyMap('Map_BridgeToLink_Ver_temp', PF, Null())))>0, ApplyMap('Map_BridgeToLink_Ver_temp', PF, Null()), '$(vMaxVer)')) as %WEVersion
    
Resident BridgeToLink_temp4;
DROP TABLE BridgeToLink_temp4;


LEFT JOIN (BridgeToLink_temp3)
LOAD Distinct
//	%WEMonthYear,
    %FaktenKey,
    FactValidFrom,
    FactValidTo,
	SubField(%FaktenKey, '$(vKeySep)', 4) as %StakeholderID,
    %BewertungsID,
    %AbrechnungBudgetID,
    %BuchungsID,
    %LSWID,
    %FWID,
    %ZahlungenID,
    %VertraegeID,
    %BauprojekteID,
    DivisionID,
    VersionID,
    %HypothekID,
    %RahmenkreditID,
    %SchuldbriefID,
    %FlaecheVersionKey, 
    %KeyToKondition, 
    %MietobjektID, 
    %MietvertragID, 
    %MietverhaeltnisID,
    LinkKategorie,
    LinkSubKategorie
    
FROM [$(vStorePath)temp-Bridge_temp.qvd] (qvd);
//Resident Bridge_temp;


BridgeToLink_temp2:
NoConcatenate
LOAD Distinct
	%WEMonthYear,
    If(Len(Trim(WE))>0, WE, SubField(%FaktenKey, '$(vKeySep)', 2)) as WirtschaftseinheitsID,
    If(Len(Trim(PF))>0, PF, SubField(%FaktenKey, '$(vKeySep)', 1)) as PortfolioID,
    Coalesce(%FaktenKey, If(Len(Trim(PF))>0, PF, 'All') & '$(vKeySep)' & If(Len(Trim(WE))>0, WE, 'All') & '$(vKeySep)' & 'All') as %FaktenKey,
    If(Len(Trim(FactValidFrom))>0, FactValidFrom, Date($(_vStart))) as FactValidFrom,
    If(Len(Trim(FactValidTo))>0, FactValidTo, Date($(_vEnd))) as FactValidTo,
    %StakeholderID as StakeholderID_temp,
    %BewertungsID as BewertungsID_temp,
    %AbrechnungBudgetID as AbrechnungBudgetID_temp,
    %BuchungsID as BuchungsID_temp,
    %LSWID as LSWID_temp,
    %FWID as FWID_temp,
    %ZahlungenID as ZahlungenID_temp,
    %VertraegeID as VertraegeID_temp,
    %BauprojekteID as BauprojekteID_temp,
    DivisionID as DivisionID_temp,
    VersionID as InvPlanID_temp,
    %HypothekID as HypothekID_temp,
    %RahmenkreditID as RahmenkreditID_temp,
    %SchuldbriefID as SchuldbriefID_temp,
    %FlaecheVersionKey as FlaecheVersionKey_temp, 
    %KeyToKondition as KeyToKondition_temp, 
    %MietobjektID as MietobjektID_temp, 
    %MietvertragID as MietvertragID_temp, 
    %MietverhaeltnisID as MietverhaeltnisID_temp,
    LinkKategorie as LinkKategorie_temp,
    LinkSubKategorie as LinkSubKategorie_temp,
    MonthYear,
	%WEVersion

Resident BridgeToLink_temp3;
//WHERE Len(Trim([%FaktenKey]))>0;
DROP TABLE BridgeToLink_temp3;


// Final Bridge Table to Link

BridgeToLink_temp:
NoConcatenate
LOAD Distinct
	%WEMonthYear,
    %FaktenKey & '$(vKeySep)' & Round(Num(FactValidFrom)) & '$(vKeySep)' & Round(Num(FactValidTo)) as %LinkKey

Resident BridgeToLink_temp2;


// Final Bridge Table to WE

WEToBridge_temp:
NoConcatenate
LOAD Distinct
    %WEVersion,
	%WEMonthYear,
    MonthYear as %MonthYear

Resident BridgeToLink_temp2;


// Store QVD
Call QvdStore ('BridgeToLink_temp2', '$(vStorePath)', 'temp', 'BridgeLink', '*', 1);

// Store QVD
Call QvdStore ('BridgeToLink_temp', '$(vStorePath)', 'RF_TR', 'BridgeToLink', '*', 1);
// Store QVD
Call QvdStore ('WEToBridge_temp', '$(vStorePath)', 'RF_TR', 'WEToBridge', '*', 1);
// Store QVD
//Call QvdStore ('IVM_Bridge_temp', '$(vStorePath)', 'RF_TR', 'IVMBridge', '*', 1);



//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_cleanBridge = (now() - vStartTime_cleanBridge)*86400;
Trace ---------------------------------- Cleanup Bridge geladen ----------------------------------;
Trace $(vElapsed_cleanBridge);
//********************************************************************************************
///$tab 4.4 Master Kalender
//********************************* Start Zeitmessung *********************************
// SET vStartTime_Cal = 0;
// Set vElapsed_Cal = 0;
Let vStartTime_Cal  = now();

//*************************************************************************************

Calendar_temp_Min:
NoConcatenate
LOAD
	Date(Floor(Min(MonthStart(FactValidFrom)))) as FactMinDate
FROM [$(vStorePath)temp-Bridge_temp.qvd] (qvd)
WHERE Match(LinkKategorie, 'ConcatFact')>0;

Calendar_temp_Max:
NoConcatenate
LOAD
	Date(Floor(Max(MonthEnd(FactValidTo)))) as FactMaxDate
FROM [$(vStorePath)temp-Bridge_temp.qvd] (qvd)
WHERE Match(LinkKategorie, 'ConcatFact')>0;

// Use these Variables for the MasterCalendar creation too...

LET _vStart = num(Peek('FactMinDate', 0, 'Calendar_temp_Min'));
LET _vEnd = num(Peek('FactMaxDate', 0, 'Calendar_temp_Max'));
LET _vNumOfDays = $(_vEnd) - $(_vStart) + 1;

DROP TABLES Calendar_temp_Min, Calendar_temp_Max;


Date_src:
LOAD
If($(_vStart)<Num(Makedate(2000,1,1)), Num(Makedate(2000,1,1)), $(_vStart)) + Rowno() -1 as DateID
AUTOGENERATE $(_vNumOfDays);

MasterCalendar_temp:
NoConcatenate
LOAD Distinct
    DateID, // just in case
    Date(DateID) as Date, // it will be in format defined in your SET DateFormat=, or in your system format
    Day(Date(DateID)) as Day,
    Week(Date(DateID)) as Week,
    Month(Date(DateID)) as Month, // simple month name; it is dual - numeric and text
    Dual(Month(Date(DateID)) & '-' & Year(Date(DateID)), Year(Date(DateID)) & Num(Month(Date(DateID)), '00')) as DualMthYr, // Month-Year format, dual
    Year(Date(DateID)) as Year,
    Weekday(Date(DateID)) as Weekday,
    'Q' & Ceil(Month(Date(DateID))/3) as Quarter, // in format Q1, Q2, Q3, Q4
    Dual('Q' & Ceil(Month(Date(DateID))/3) & '-' & Year(Date(DateID)),
    Year(Date(DateID)) & Ceil(Month(Date(DateID))/3)) as QtrYear, // Qn-Year, dual
    Date(Floor(MonthStart(Date(DateID)))) as BeginningOfMonth,
    Date(Floor(MonthEnd(Date(DateID)))) as EndOfMonth,
    Date(Floor(MonthStart(Date(DateID))), 'MMM-YY') as %MonthYear

RESIDENT Date_src;
Drop Table Date_src;

// Store QVD
Call QvdStore ('MasterCalendar_temp', '$(vStorePath)', 'RF_MD', 'MasterCalendar', '*', 1);


//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_Cal = (now() - vStartTime_Cal)*86400;
Trace ---------------------------------- Kalender geladen ----------------------------------;
Trace $(vElapsed_Cal);
//********************************************************************************************

///$tab 4.5 Geschäftsjahr Tabelle
//********************************* Start Zeitmessung *********************************
// SET vStartTime_GJ = 0;
// Set vElapsed_GJ = 0;
Let vStartTime_GJ  = now();

//*************************************************************************************

PeriodLength:
LOAD Distinct
	Abschlussperiodizitaet,
    FieldValueCount(Abschlussperiodizitaet) as DistCountValue
//Resident Portfolios_temp;
FROM [$(vStorePath)RF_MD-Portfolios.qvd] (qvd);

LET vLengthOfField = Peek('DistCountValue', 0 , 'PeriodLength');

FOR i = 0 TO Len(vLengthOfField)

  LET vPeriodLength = Peek('Abschlussperiodizitaet', i, 'PeriodLength');

  Switch vPeriodLength
    Case 'MONTHLY'
      LEFT JOIN (PeriodLength)
      LOAD
          Abschlussperiodizitaet,
          '1' as AbschlussMonatLaenge
      Resident PeriodLength;

    Case 'BIANNUALLY'
      LEFT JOIN (PeriodLength)
      LOAD
          Abschlussperiodizitaet,
          '6' as AbschlussMonatLaenge
      Resident PeriodLength;

    Case 'QUARTERLY'
      LEFT JOIN (PeriodLength)
      LOAD
          Abschlussperiodizitaet,
          '3' as AbschlussMonatLaenge
      Resident PeriodLength;

    Default
      LEFT JOIN (PeriodLength)
      LOAD
          Abschlussperiodizitaet,
          '12' as AbschlussMonatLaenge
      Resident PeriodLength;
      
   End Switch;

NEXT i
;

// *** Mapping
MAP_PeriodLength:
Mapping LOAD
	Abschlussperiodizitaet,
    AbschlussMonatLaenge
Resident PeriodLength;
DROP TABLE PeriodLength;


// GJ_Table_temp2:
// NoConcatenate
// LOAD Distinct
// 	FactValidFrom,
//     FactValidTo,
//     Year(FactValidFrom) as CalYearFrom,
//     Year(FactValidTo) as CalYearTo,
//     %FaktenKey,
//     %WEMonthYear
    
// //Resident Bridge_temp;
// FROM [$(vStorePath)temp-Bridge_temp.qvd] (qvd);


GJ_Table_temp2:
NoConcatenate
LOAD Distinct
	FactValidFrom,
    FactValidTo,
    Year(FactValidFrom) as CalYearFrom,
    Year(FactValidTo) as CalYearTo,
    %FaktenKey,
    %WEMonthYear,
    %WEVersion

FROM [$(vStorePath)temp-BridgeLink.qvd] (qvd);

LEFT JOIN (GJ_Table_temp2)
LOAD Distinct
	%WirtschaftseinheitSCDID,
//    %WEVersion,
	%WEMonthYear
    
//Resident WE_Bridge_temp;
FROM [$(vStorePath)temp-WE_Bridge_temp.qvd] (qvd);

LEFT JOIN (GJ_Table_temp2)
LOAD Distinct
	%WirtschaftseinheitSCDID,
    AbschlussMonatNum_temp as AbschlussMonatNum,
    ApplyMap('MAP_PeriodLength', Abschlussperiodizitaet_temp, null()) as AbschlussMonatLaenge
;
// Preceding load
LOAD Distinct
	%WirtschaftseinheitSCDID,
    Coalesce(AbschlussMonatNum, '12') as AbschlussMonatNum_temp,
    Coalesce(Abschlussperiodizitaet, '12') as Abschlussperiodizitaet_temp
    
//Resident WE_temp;
FROM [$(vStorePath)RF_MD-Wirtschaftseinheiten.qvd] (qvd);

LEFT JOIN (GJ_Table_temp2)
LOAD Distinct
	%FaktenKey,
    JahrMonat,
    Num(Month(JahrMonat)) as Monat
    
FROM [$(vStorePath)RF_TR-Fakten.qvd] (qvd);

GJ_Table_temp:
NoConcatenate
LOAD Distinct
	%WEMonthYear,
    %FaktenKey,
    FactValidFrom,
    FactValidTo,
    Date(Floor(MonthStart(AddMonths(GJEndDate, AbschlussMonatLaenge_temp*(-1)+1)))) as GJStartDate,
    GJEndDate,
    GeschäftsJahr,
    CalYearFrom as KalenderJahr,
    AbschlussMonatNum_temp as AbschlussMonatNum,
    AbschlussMonatLaenge_temp as AbschlussMonatLaenge,
    JahrMonat,
    CalYearFrom&if(Monat<10,'0','')&Monat as PeriodeCJ,
    CalYearFrom&if(MonatUmgerechnet<10,'0','')&MonatUmgerechnet as PeriodeGJ
;
// Preceding load
LOAD
	*,
    Date(Floor(MonthEnd(MakeDate(GeschäftsJahr, AbschlussMonatNum_temp)))) as GJEndDate,
    If(Monat>AbschlussMonatNum_temp, Monat-AbschlussMonatNum_temp, Monat+(AbschlussMonatLaenge_temp-AbschlussMonatNum_temp)) as MonatUmgerechnet
;
// Preceding load
LOAD
	*,
	If(Num(Month(FactValidFrom))>AbschlussMonatNum_temp, 1, 0)+Year(FactValidFrom) as GeschäftsJahr
;
// Preceding load
LOAD
	*,
    Coalesce(AbschlussMonatNum, '12') as AbschlussMonatNum_temp,
    Coalesce(AbschlussMonatLaenge, '12') as AbschlussMonatLaenge_temp

Resident GJ_Table_temp2;
DROP TABLE GJ_Table_temp2;

// Store QVD
Call QvdStore ('GJ_Table_temp', '$(vStorePath)', 'temp', 'GJTable_temp', '*', 1);


//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_GJ = (now() - vStartTime_GJ)*86400;
Trace ---------------------------------- Geschäftsjahr geladen ----------------------------------;
Trace $(vElapsed_GJ);
//********************************************************************************************


///$tab 4.6 Link_Tabelle
//********************************* Start Zeitmessung *********************************
// SET vStartTime_Link = 0;
// Set vElapsed_Link = 0;
Let vStartTime_Link  = now();

//*************************************************************************************

// Final Link Table

LinkTable_temp:
NoConcatenate
LOAD Distinct
	%FaktenKey,
    %FaktenKey & '$(vKeySep)' & Round(Num(FactValidFrom)) & '$(vKeySep)' & Round(Num(FactValidTo)) as %LinkKey,
    BewertungsID_temp as BewertungsID,
	BewertungsID_temp as %RefBewID,
    AbrechnungBudgetID_temp as AbrechnungBudgetID,
    BuchungsID_temp as BuchungsID,
    LSWID_temp as LSWID,
    FWID_temp as FWID,
    ZahlungenID_temp as ZahlungenID,
    VertraegeID_temp as VertraegeID,
	BauprojekteID_temp as BauprojekteID,
    BauprojekteID_temp as %RefCDPID,
    DivisionID_temp as DivisionID,
    InvPlanID_temp as InvPlanID,
    HypothekID_temp as HypothekID,
    RahmenkreditID_temp as RahmenkreditID,
    SchuldbriefID_temp as SchuldbriefID,
    FlaecheVersionKey_temp as %FlaecheVersionKey, 
    KeyToKondition_temp as %KeyToKondition, 
    MietobjektID_temp as %MietobjektID, 
    MietvertragID_temp as %MietvertragID, 
    MietverhaeltnisID_temp as %MietverhaeltnisID,
    StakeholderID_temp as %StakeholderID,
    FactValidFrom,
    FactValidTo,
    LinkKategorie_temp as LinkKategorie,
    LinkSubKategorie_temp as LinkSubKategorie,
    WirtschaftseinheitsID,
//    WirtschaftseinheitsID as %WERefKey,
//    WirtschaftseinheitsID as %WERefKeyMSP,
    PortfolioID,
    If(Match(PortfolioID, 'All')>0, null(), PortfolioID) as %PortfolioID

FROM [$(vStorePath)temp-BridgeLink.qvd] (qvd);
//Resident BridgeToLink_temp2;

END IF

// Join Geschäftsjahr-Table to the LinkTable
LEFT JOIN (LinkTable_temp)
LOAD Distinct
	%FaktenKey,
    KalenderJahr,
    GeschäftsJahr,
    GJStartDate,
    GJEndDate,
    JahrMonat,
    PeriodeCJ,
    PeriodeGJ

// Resident GJ_Table_temp;
// DROP TABLE GJ_Table_temp;
FROM [$(vStorePath)temp-GJTable_temp.qvd] (qvd);
//Resident GJ_Table_temp;

// Store QVD
Call QvdStore ('LinkTable_temp', '$(vStorePath)', 'RF_TR', 'LinkTable', '*', 1);


//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_Link = (now() - vStartTime_Link)*86400;
Trace ---------------------------------- Link Table geladen ----------------------------------;
Trace $(vElapsed_Link);
//********************************************************************************************

///$tab Ende Bridge & Link 4. <<
//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_BridgeLink = (now() - vStartTime_BridgeLink)*86400;
Trace ---------------------------------- Bridge&Link-Tabellen geladen ----------------------------------;
Trace $(vElapsed_BridgeLink);
//********************************************************************************************


// //*************************************** Ende Zeitmessung ***********************************
// Let vElapsed_BridgeLinkwoCal = num((now()) - $(vStartTime_BridgeLink)-$(vElapsed_Cal)-$(vElapsed_GJ))*86400;
// Trace ---------------------------------- Bridge&Link ohne Kalender geladen ----------------------------------;
// Trace $(vElapsed_BridgeLinkwoCal);
// //********************************************************************************************
///$tab >> 5. P&L Rollups
// are 12/11/22: removed, not applicable anymore
///$tab >> 6. Spezialthemen
//********************************* Start Zeitmessung *********************************
// SET vStartTime_Spez = 0;
// Set vElapsed_Spez = 0;
Let vStartTime_Spez  = now();

//*************************************************************************************
///$tab 6.1 Liegenschaftsstrategie
//********************************* Start Zeitmessung *********************************
// SET vStartTime_LSStrat = 0;
// Set vElapsed_LSStrat = 0;
Let vStartTime_LSStrat = now();

//*************************************************************************************

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Strategien_WE.qvd')) Then

Liegenschaftsstrategie_temp:
NoConcatenate
LOAD Distinct
    WirtschaftseinheitsID as %WirtschaftseinheitNr,
    LiegenschaftsstrategieStatus,
    Genehmigungsdatum_temp as Genehmigungsdatum,
    Bearbeitungsdatum_temp as Bearbeitungsdatum,
    _KEY_content,
    LiegenschaftsstrategieAM_temp as LiegenschaftsstrategieAM,
    LiegenschaftsstrategieAMBemerkung,
    LiegenschaftsstrategieAMPeriode_temp as LiegenschaftsstrategieAMPeriode,
    LSStratKey,
    LiegenschaftsstrategiePM_temp as LiegenschaftsstrategiePM,
    LiegenschaftsstrategiePMBemerkung,
    LiegenschaftsstrategiePMPeriode_temp as LiegenschaftsstrategiePMPeriode,
    PlanJahr
;
// Preceding load
LOAD
	*,
    ApplyMap('MappingLSStrategie', LiegenschaftsstrategieAM, null()) as LiegenschaftsstrategieAM_temp,
    ApplyMap('MappingLSStrategie', LiegenschaftsstrategiePM, null()) as LiegenschaftsstrategiePM_temp,
    ApplyMap('MappingLSStrategiePeriode', LiegenschaftsstrategieAMPeriode, null()) as LiegenschaftsstrategieAMPeriode_temp,
    ApplyMap('MappingLSStrategiePeriode', LiegenschaftsstrategiePMPeriode, null()) as LiegenschaftsstrategiePMPeriode_temp,
    Date(Genehmigungsdatum) as Genehmigungsdatum_temp,
    Timestamp(Bearbeitungsdatum) as Bearbeitungsdatum_temp

FROM [$(vSourcePath)DS_api_Strategien_WE.qvd]
(qvd);

LEFT JOIN (Liegenschaftsstrategie_temp)
LOAD Distinct
    _KEY_content,
    Date(Massnahmedatum) as DatumMassnahme,
    Massnahme,
    SubField(_KEY_content, '$(vKeySep)', 1) & '$(vKeySep)' & If(RowNo()<10, '0'&RowNo(), RowNo()) as MassnahmeKey,
    ErstelltVon
FROM [$(vSourcePath)DS_api_StratMassnahmen_WE.qvd]
(qvd);

DROP FIELD _KEY_content FROM Liegenschaftsstrategie_temp; 

LEFT JOIN (Liegenschaftsstrategie_temp)
LOAD Distinct
    "UserID" as ErstelltVon,
    Vorname as ErstelltVorname,
    Nachname as ErstelltNachname,
    Vorname & ' ' & Nachname as ErstelltVollerName
    
FROM [$(vSourcePath)DS_api_User.qvd]
(qvd);

// Store QVD
Call QvdStore ('Liegenschaftsstrategie_temp', '$(vStorePath)', 'RF_MD', 'Liegenschaftsstrategie', '*', 1);

End If


//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_LSStrat = (now() - vStartTime_LSStrat)*86400;
Trace ---------------------------------- Liegenschaftstrategie geladen ----------------------------------;
Trace $(vElapsed_LSStrat);
//********************************************************************************************

///$tab 6.2 QualityProfileWE
//********************************* Start Zeitmessung *********************************
// SET vStartTime_QualProfWE = 0;
// Set vElapsed_QualProfWE = 0;
Let vStartTime_QualProfWE = now();

//*************************************************************************************

// IF Not Isnull(QvdCreateTime('$(vSourcePath)QualityProfile.qvd')) Then

//     QualityProfile_temp:
//     NoConcatenate
//     LOAD Distinct
//         __KEY_root,
//         "comment",
//         Kriterium,
//         __KEY_entries,
//         calculated_weight,
//         manual_weight,
//         both_weight,
//         calculated_grade,
//         manual_grade,
//         both_grade,
//         %Wirtschaftseinheitsnr as %WirtschaftseinheitNr,
//         total_grade,
//         //Load *,
//     	ApplyMap('MappingQPKategorie',Kriterium, Null()) as Kategorie_DE,
//    		ApplyMap('MappingQPKriteriumfull',Kriterium, Null()) as Pfad_DE,
//     	ApplyMap('MappingQPKriterium',Kriterium, Null()) as Kriterium_DE
//     FROM [$(vSourcePath)QualityProfile.qvd](qvd);  

    
// // Store QVD
// Call QvdStore ('QualityProfile_temp', '$(vStorePath)', 'RF_MD', 'QualityProfile', '*', 1);

// End If



IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_QPF_WE_Typ.qvd')) Then

QPF_WE_Typ:
LOAD
    Bemerkung,
    Typ,
    WirtschaftseinheitsID as %WirtschaftseinheitNr,
    _KEY_entries,
    _KEY_root,
    ApplyMap('MappingQPKategorie',Typ, Null()) as Kategorie_DE,
    ApplyMap('MappingQPKriterium',Typ, Null()) as Kriterium_DE
FROM [$(vSourcePath)DS_api_QPF_WE_Typ.qvd]
(qvd);


IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_QPF_WE_Gewichte.qvd')) Then

Left Join(QPF_WE_Typ)
LOAD
    GewichtBerechnet,
    GewichtManuell,
    Gewicht,
    WirtschaftseinheitsID as %WirtschaftseinheitNr,
    _KEY_entries
FROM [$(vSourcePath)DS_api_QPF_WE_Gewichte.qvd]
(qvd);

// Store QVD
//Call QvdStore ('QPF_WE_Gewichte', '$(vStorePath)', 'RF_MD', 'QPF_WE_Gewichte', '*', 1);

End If; 


IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_QPF_WE_Ratings.qvd')) Then

Left Join(QPF_WE_Typ)
LOAD
    RatingBerechnet,
    RatingManuell,
    Rating,
    WirtschaftseinheitsID as %WirtschaftseinheitNr,
    _KEY_entries
FROM [$(vSourcePath)DS_api_QPF_WE_Ratings.qvd]
(qvd);

// Store QVD
//Call QvdStore ('QPF_WE_Ratings', '$(vStorePath)', 'RF_MD', 'QPF_WE_Ratings', '*', 1);


End If;

// Store QVD
Call QvdStore ('QPF_WE_Typ', '$(vStorePath)', 'RF_MD', 'QualityProfileWE', '*', 1);


End if; 




//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_QualProfWE = (now() - vStartTime_QualProfWE)*86400;
Trace ---------------------------------- Qualitätsprofil geladen ----------------------------------;
Trace $(vElapsed_QualProfWE);
//********************************************************************************************
///$tab 6.3 Stakeholders (Kreditgeber)
//********************************* Start Zeitmessung *********************************
// SET vStartTime_Stakeholders = 0;
// Set vElapsed_Stakeholders = 0;
Let vStartTime_Stakeholders = now();

//*************************************************************************************


// Stakeholders Tabelle bisher (31/03/22) nur mit Kreditgeber

IF Not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Stakeholders.qvd')) Then

Stakeholders_temp:
NoConcatenate
LOAD Distinct
//     BasisURL,
//     _KEY_root,
    ReferenzNrStakeholder,
    ExterneID,
    StakeholderID as %StakeholderID,
    NameStakeholder,
    Status,
    ApplyMap('MappingStakeholder', Typ, Null()) as StakeholderTyp
FROM [$(vSourcePath)DS_api_Stakeholders.qvd]
(qvd)
WHERE Match(Typ, 'CREDITOR')>0;


// Store QVD
Call QvdStore ('Stakeholders_temp', '$(vStorePath)', 'RF_MD', 'Stakeholders', '*', 1);

END IF


//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_Stakeholders = (now() - vStartTime_Stakeholders)*86400;
Trace ---------------------------------- Stakeholders (Kreditgeber) geladen ----------------------------------;
Trace $(vElapsed_Stakeholders);
//********************************************************************************************
///$tab 6.4 Benchmark Comparison
//********************************* Start Zeitmessung *********************************
// SET vStartTime_BenchComp = 0;
// Set vElapsed_BenchComp = 0;
Let vStartTime_BenchComp = now();

//*************************************************************************************


If  not Isnull(QvdCreateTime('$(vSourcePath)Immoindex_KGAST.qvd')) then

Immoindex_tmp2:
LOAD Distinct
    Datum,
    num(Month(Datum)) as Monat,
    year(Datum) as Year,
    "Total",
    Gemischt,
    Wohnen,
    Geschaeft
FROM [$(vSourcePath)Immoindex_KGAST.qvd]
(qvd);

Immoindex_tmp:
NoConcatenate Load *
Resident Immoindex_tmp2
where Monat = 12;

Drop Table Immoindex_tmp2;

Immoindex:
Load Distinct
	Year as Jahr,
    Total / TotalPrev -1 as Performance,
    Gemischt / GemischtPrev -1 as Performance_Gemischt,
    Wohnen / WohnenPrev -1 as Performance_Wohnen,
    Geschaeft / GeschaeftPrev -1 as Performance_Kommerziell,
    Total as Indexstand,
    Gemischt as Indexstand_Gemischt,
    Wohnen as Indexstand_Wohnen,
    Geschaeft as Indexstand_Kommerziell
;
NoConcatenate Load 
	Total,
    Gemischt,
    Wohnen,
    Geschaeft,
    Previous(Total) as TotalPrev,
    Previous(Gemischt) as GemischtPrev,
    Previous(Wohnen) as WohnenPrev,
    Previous(Geschaeft) as GeschaeftPrev,
    Year
Resident Immoindex_tmp;
Drop Table Immoindex_tmp;


Index_tmp2: 
CrossTable (Fondsname,Performance)
LOAD Distinct
    Jahr,
    Performance as KGAST,
    Performance_Gemischt as KGAST_Gemischt,
    Performance_Wohnen as KGAST_Wohnen,
    Performance_Kommerziell as KGAST_Kommerziell
Resident Immoindex
where 1=1;  //verhindert $orphan Tables


Indizes_SFAMA_KGAST_temp:
Load *,
	'Benchmark' as Typ,
    AutoNumber(Jahr &'$(vKeySep)' & Fondsname) as %key_tmp
Resident Index_tmp2;
Drop Table Index_tmp2;


Index_tmp3: 
CrossTable (Fondsname,Indexstand)
LOAD Distinct
    Jahr,
    Indexstand as KGAST,
    Indexstand_Gemischt as KGAST_Gemischt,
    Indexstand_Wohnen as KGAST_Wohnen,
    Indexstand_Kommerziell as KGAST_Kommerziell
// FROM [$(vSourcePath)Immoindex_KGAST.qvd]
// (qvd)
Resident Immoindex
where 1=1;  //verhindert $orphan Tables
Drop Table Immoindex;



LEft Join(Indizes_SFAMA_KGAST_temp)
Load *,
	'Benchmark' as Typ,
    AutoNumber(Jahr &'$(vKeySep)' & Fondsname) as %key_tmp
Resident Index_tmp3;
Drop Table Index_tmp3;

Drop Field [%key_tmp] from Indizes_SFAMA_KGAST_temp;


Concatenate(Indizes_SFAMA_KGAST_temp)
LOAD Distinct
    Jahr,
    Performance,
    Indexstand,
    'SXI' as Fondsname,
    'Benchmark' as Typ
FROM [$(vSourcePath)Immoindex_SXI.qvd]
(qvd);

//Aktiveren sobald SIX-API lizenziert (Ladelogik für Performance-Zeitreihe aus API-Call)

// tmp:
// LOAD
//     Close,
//     "DATE",
//     day("DATE") as Tag,
//     num(month("DATE")) as Monat,
//     year("DATE") as Jahr
// FROM [lib://$(vStore)/04_Datasource/01_qvd/Immoindex_SXI.qvd]
// (qvd);

// tmp2:
// NoConcatenate Load 
//     Jahr,
//     FirstSortedValue(Close,-DATE) as Indexstand,
//     Max(DATE) as DATE
// resident tmp
// Group by Jahr;

// Drop Table tmp;


// Concatenate(Indizes_SFAMA_KGAST)
// Load
// 	Jahr,
//     Indexstand / Indexstand_PREV -1 as Performance,
//     Indexstand,
//     'SXI' as Fondsname,
//     'Benchmark' as Typ
//     ;
// Load 
//     Jahr,
//     Previous(Indexstand) as Indexstand_PREV,
//     Indexstand
// Resident tmp2;
// Drop Table tmp2;



Concatenate(Indizes_SFAMA_KGAST_temp)
LOAD Distinct
    Fondsname,
    [Short Name] as [ShortName],
    Jahr,
    Sektor,
    Performance,
    NAV as Indexstand,
    'Kunde' as Typ
FROM [$(vSourcePath)Peervergleich.qvd]
(qvd);

//Kennzahlen (Peers + Kunde)

Peervergleich_temp:
CrossTable(KPI,Werte,10)
LOAD Distinct
    ISIN,
    Fondsname,
    [Short Name] as [ShortName],
    Sektor,
    Region,
    Investmentstruktur,
    Jahr,
    [JB per],
    owner,
    Gefaesstyp,
    Mietzinserträge,
    NAV,
    Performance,
    Anlagerendite,
    Ausschüttungsrendite,
    Ausschüttungsquote,
    ROE,
    Agio,
    EBIT_Marge,
    Fremdfinanzierungsquote,
    Mietausfallrate,
    TER_GAV,
    TER_NAV,
    ROIC
FROM [$(vSourcePath)Peervergleich.qvd]
(qvd)
where 1 = 1; //verhindert $orphan Tables

// Store QVD
Call QvdStore ('Indizes_SFAMA_KGAST_temp', '$(vStorePath)', 'RF_MD', 'Indizes_SFAMA_KGAST', '*', 1);

// Store QVD
Call QvdStore ('Peervergleich_temp', '$(vStorePath)', 'RF_MD', 'Peervergleich', '*', 1);

End if


//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_BenchComp = (now() - vStartTime_BenchComp)*86400;
Trace ---------------------------------- Benchmark Comparison geladen ----------------------------------;
Trace $(vElapsed_BenchComp);
//********************************************************************************************

///$tab 6.5 KAG Abweichung
//********************************* Start Zeitmessung *********************************
// SET vStartTime_KAGAbw = 0;
// Set vElapsed_KAGAbw = 0;
Let vStartTime_KAGAbw = now();

//*************************************************************************************

// Temporary Table: non-Standard

If  not Isnull(QvdCreateTime('$(vStorePath)RF_TR-MieterspiegelMTH.qvd')) then

KAG_Kategorien_temp:
NoConcatenate
LOAD Distinct

	%FaktenKey,
    //%LinkKey,
    FactRefMVID,
    MTHFaktenWert,
    FaktenTyp,
	SubTyp,
    FaktenValidFrom,
    FaktenValidTo
//     FactRefPF,
//     FactRefWE,
//     FactRefMO,
//     FactRefMVR
    
//FROM [$(vStorePath)RF_TR-IVM_Facts.qvd] (qvd)
//FROM [$(vStorePath)MieterspiegelFakten.qvd] (qvd)
FROM [$(vStorePath)RF_TR-MieterspiegelMTH.qvd] (qvd)
Where SubTyp='NET_RENT' and FaktenTyp='LeaseCashFlowFakten';

 

Left Join(KAG_Kategorien_temp)	
// NoConcatenate
LOAD Distinct

	%FaktenKey,
//     FactValidFrom,
//     FactValidTo,    
    %WEMonthYear,
    %LinkKey
    
    
;  

// Preceding load
NoConcatenate
LOAD Distinct
	*,
     Hash256(%FaktenKey & '$(vKeySep)' & Round(Num(FactValidFrom)) & '$(vKeySep)' & Round(Num(FactValidTo))) as %LinkKey
    
 FROM [$(vStorePath)temp-BridgeLink.qvd] (qvd); 
  


Left Join(KAG_Kategorien_temp)	
// NoConcatenate
LOAD Distinct
   	%WEVersion,
    %WEMonthYear
    

FROM [$(vStorePath)RF_TR-WEToBridge.qvd] (qvd);


Left Join(KAG_Kategorien_temp)	
 LOAD Distinct	
    %WirtschaftseinheitNr,
    %WEVersion,
    KAGKategorie,
    FiskalischeKategorie

 FROM [$(vStorePath)temp-WEAktuell.qvd] (qvd)
//FROM [$(vStorePath)RF_MD-Wirtschaftseinheiten.qvd] (qvd)
 Where KAGKategorie>0  or FiskalischeKategorie>0;



Left Join(KAG_Kategorien_temp)	
LOAD Distinct
    WirtschaftseinheitsID as %WirtschaftseinheitNr,
//     %MietobjektVersionKey,
    Hauptnutzung_temp as Hauptnutzung,
    HauptnutzungRGB,
    HauptnutzungSortierung,
    Nutzung_temp as Nutzung,
    Nutzung_vereinfacht,
    Nutzung_vereinfachtRGB, //nte
    NutzungKommerziell,
    NutzungMarkt,
    MietobjektID

;
// Preceding load
LOAD
	*,
    ApplyMap('MappingRU', Hauptnutzung, Null()) as Hauptnutzung_temp,
    ApplyMap('MappingRUType2', Nutzung, Null()) as Nutzung_temp,
    ApplyMap('MappingPM',Hauptnutzung) as Nutzung_vereinfacht,			//nte
    ApplyMap('MappingPMRGB',Hauptnutzung) as Nutzung_vereinfachtRGB,   //nte
    ApplyMap('MappingNutzungMarkt', ApplyMap('MappingRU', Hauptnutzung), Null()) as NutzungMarkt,
    ApplyMap('MappingRURGB',Hauptnutzung) as HauptnutzungRGB,
    Applymap('MappingRUOrder',Hauptnutzung) as HauptnutzungSortierung,
    ApplyMap('MappingNutzungKommerziell',Hauptnutzung) as NutzungKommerziell
FROM [$(vSourcePath)DS_api_IVM_Mietobjekte_Versionen.qvd]
(qvd);






Left Join(KAG_Kategorien_temp)	
Load Distinct
	%WirtschaftseinheitNr,
    %WEVersion,
    Hauptnutzung,
   	match(Hauptnutzung,'Wohnen','Nebennutzung Wohnen') as HauptnutzungWohnen,
	match(Hauptnutzung,'Büro' , 'Verkauf' ,'Gewerbe/Industrie' ,'Hotel' ,'Gastronomie' , 'Freizeit/Kultur/Bildung' , 'Gesundheit/Pflege' , 'Lager' , 'Nebennutzung kommerziell' , 'Spezialnutzung mit Fläche' , 'Spezialnutzung ohne Fläche') as HauptnutzungKommerziell,	
    match(Hauptnutzung,'Büro', 'Verkauf', 'Gewerbe/Industrie',  'Freizeit/Kultur/Bildung' , 'Gesundheit/Pflege', 'Nebennutzung kommerziell',  'Spezialnutzung mit Fläche' , 'Spezialnutzung ohne Fläche') as HauptnutzungGeschäftshäuser,
	match(Hauptnutzung, 'Gastronomie','Hotel') as HauptnutzungGastwirtschaftsgewerbe,
   	match( Hauptnutzung, 'Lager') as HauptnutzungFabrikgebäude
    
Resident KAG_Kategorien_temp
Where ( Hauptnutzung >0);




Left Join(KAG_Kategorien_temp)	
Load Distinct
	%WirtschaftseinheitNr,
//      %WEVersion,
    sum(MTHFaktenWert) as Werte_HauptnutzungWohnen
     

Resident KAG_Kategorien_temp
Where (HauptnutzungWohnen=1)
Group by %WirtschaftseinheitNr;




Left Join(KAG_Kategorien_temp)	
Load Distinct
	%WirtschaftseinheitNr,
//      %WEVersion,
   sum(MTHFaktenWert) as Werte_HauptnutzungKommerziell
     

Resident KAG_Kategorien_temp
Where (HauptnutzungKommerziell=1)
Group by %WirtschaftseinheitNr;


Left Join(KAG_Kategorien_temp)	
Load Distinct
	%WirtschaftseinheitNr,
//      %WEVersion,
   sum(MTHFaktenWert) as Werte_HauptnutzungGeschäftshäuser
     

Resident KAG_Kategorien_temp
Where (HauptnutzungGeschäftshäuser=1)
Group by %WirtschaftseinheitNr;


Left Join(KAG_Kategorien_temp)	
Load Distinct
	%WirtschaftseinheitNr,
//      %WEVersion,
   sum(MTHFaktenWert) as Werte_HauptnutzungGastwirtschaftsgewerbe
     

Resident KAG_Kategorien_temp
Where (HauptnutzungGastwirtschaftsgewerbe=1)
Group by %WirtschaftseinheitNr;



Left Join(KAG_Kategorien_temp)	
Load Distinct
	%WirtschaftseinheitNr,
//      %WEVersion,
   sum(MTHFaktenWert) as Werte_HauptnutzungFabrikgebäude
     

Resident KAG_Kategorien_temp
Where (HauptnutzungFabrikgebäude=1)
Group by %WirtschaftseinheitNr;


Left Join(KAG_Kategorien_temp)	
Load Distinct
	%WirtschaftseinheitNr,
//      %WEVersion,
     sum(MTHFaktenWert) as Werte_Hauptnutzung
     

Resident KAG_Kategorien_temp
Where ( Hauptnutzung >0)
Group by %WirtschaftseinheitNr;


Left Join(KAG_Kategorien_temp)	
Load Distinct
	%WirtschaftseinheitNr,
     %WEVersion,
    sum(Werte_HauptnutzungWohnen)/ sum(Werte_Hauptnutzung) as Prz_Wohnen,
  	sum(Werte_HauptnutzungKommerziell)/  sum(Werte_Hauptnutzung)  as Prz_Kommerziell,
  	sum(Werte_HauptnutzungGeschäftshäuser)/  sum(Werte_Hauptnutzung)  as Prz_Geschäftshäuser,
    sum(Werte_HauptnutzungGastwirtschaftsgewerbe)/  sum(Werte_Hauptnutzung) as Prz_Gastwirtschaftsgewerbe,
    sum(Werte_HauptnutzungFabrikgebäude)/  sum(Werte_Hauptnutzung)  as Prz_Fabrikgebäude
    
Resident KAG_Kategorien_temp
Group By %WirtschaftseinheitNr, %WEVersion;


   
Left Join(KAG_Kategorien_temp)	
Load
Distinct
	%WirtschaftseinheitNr,
     %WEVersion,
    if (Prz_Kommerziell >= 0.60, 'Kommerzielle Liegenschaften', 
    	if(Prz_Kommerziell < 0.20, 'Wohnbauten', 
   		 if(Prz_Kommerziell >= 0.20, 'Gemischte Nutzung', 
   			 'nicht verfügbar'))) as KAGKategorieMS
       
Resident KAG_Kategorien_temp
Where  ( Hauptnutzung >0);

Left Join(KAG_Kategorien_temp)	
Load
Distinct
	%WirtschaftseinheitNr,
     %WEVersion,
    if (Match (KAGKategorie, KAGKategorieMS), '','Abweichung') as Abweichung_KAGKategorie
    
   
Resident KAG_Kategorien_temp
Where  ( Hauptnutzung >0);


  
         
   Left Join(KAG_Kategorien_temp)	
Load
Distinct
	%WirtschaftseinheitNr,
     %WEVersion,
   	if (RangeMax(Prz_Wohnen, 
    		Prz_Geschäftshäuser, 
        	Prz_Gastwirtschaftsgewerbe,
        	Prz_Fabrikgebäude)=Prz_Wohnen,
        'Wohnhäuser',
    if (RangeMax(Prz_Wohnen, 
        	Prz_Geschäftshäuser, 
            Prz_Gastwirtschaftsgewerbe,
            Prz_Fabrikgebäude)=Prz_Geschäftshäuser, 
        'Geschäftshäuser, Büro- und Bankgebäude, Warenhäuser, Kinogebäude',
    if (RangeMax(Prz_Wohnen, 
            Prz_Geschäftshäuser, 
            Prz_Gastwirtschaftsgewerbe,
            Prz_Fabrikgebäude)=Prz_Gastwirtschaftsgewerbe, 
         'Gastwirtschaftsgewerbe, Hotellerie',
    if (RangeMax(Prz_Wohnen, 
            Prz_Geschäftshäuser, 
            Prz_Gastwirtschaftsgewerbe,
            Prz_Fabrikgebäude)=Prz_Fabrikgebäude, 
          'Fabrikgebäude, Lagergebäude, gewerbliche Bauten',
           	if (Match(Prz_Wohnen, Prz_Geschäftshäuser) or
                Match (Prz_Wohnen, Prz_Gastwirtschaftsgewerbe) or
                Match (Prz_Wohnen,   Prz_Fabrikgebäude) or
                Match (Prz_Geschäftshäuser, Prz_Gastwirtschaftsgewerbe) or
       			Match (Prz_Geschäftshäuser,  Prz_Fabrikgebäude) or
                Match (Prz_Gastwirtschaftsgewerbe,  Prz_Fabrikgebäude), 'unentschieden',
    		'nicht verfügbar')
	)))) as FiskalischeKategorieMS
   
Resident KAG_Kategorien_temp
Where  ( Hauptnutzung >0);

Left Join(KAG_Kategorien_temp)	
Load
Distinct
	%WirtschaftseinheitNr,
     %WEVersion,
    if (Match (FiskalischeKategorie, FiskalischeKategorieMS), '','Abweichung') as Abweichung_FiskalischeKategorie
    
   
Resident KAG_Kategorien_temp
Where  ( Hauptnutzung >0);


Drop Fields %WirtschaftseinheitNr, %WEMonthYear, %LinkKey, %FaktenKey from KAG_Kategorien_temp;

// Store QVD
Call QvdStore ('KAG_Kategorien_temp', '$(vStorePath)', 'RF_MD', 'KAG_Kategorien', '*', 1);

END IF

//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_KAGAbw = (now() - vStartTime_KAGAbw)*86400;
Trace ---------------------------------- KAG Abweichungen geladen ----------------------------------;
Trace $(vElapsed_KAGAbw);
//********************************************************************************************

///$tab 6.6 Instandsetzungen WE
//********************************* Start Zeitmessung *********************************
// SET vStartTime_RecoWE = 0;
// Set vElapsed_RecoWE = 0;
Let vStartTime_RecoWE = now();

//*************************************************************************************



// Sanierungsmodell auf WE-Ebene
If  not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Reco_Bauteile_WE.qvd')) then

Reco_Bauteile_WE:
LOAD Distinct
    Bauteil,
    Id,
    Konstruktion,
    Materialisierung,
    WirtschaftseinheitsID,
    _KEY_components,
    _KEY_root
FROM [$(vSourcePath)DS_api_Reco_Bauteile_WE.qvd]
(qvd);

Reco_Bauteile_WE_1:
Load Distinct *,
	ApplyMap('MappingBauteil',Bauteil, Null()) as Bauteil_DE
Resident Reco_Bauteile_WE;

Drop Table Reco_Bauteile_WE;

If  not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Bauteile_WE.qvd')) then

Left Join(Reco_Bauteile_WE_1)
LOAD
    Bauteil,
    Bauteilgruppe,
    GebaeudeID,
    Gewicht,
    Konstruktion,
    Materialisierung,
    Nutzung,
    RatingStandard,
    RatingZustand,
    ReferenzNrGebaeude,
    WirtschaftseinheitsID,
    _KEY_content,
    _KEY_root
FROM [$(vSourcePath)DS_api_Bauteile_WE.qvd]
(qvd);

If  not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Reco_Details_WE.qvd')) then


Left Join (Reco_Bauteile_WE_1)
LOAD
    Annuitaet,
    AufgeschobeneKosten,
    Budget,
    DauerSanierung,
    EndeSanierung,
    Ende,
    Kommentar,
    Kosten,
    Neuwert,
    Restlebensdauer,
    SanierungBemerkung,
    SanierungPeriode,
    StartSanierung,
    "Start",
    WirtschaftseinheitsID,
    _KEY_components,
    _KEY_details
FROM [$(vSourcePath)DS_api_Reco_Details_WE.qvd]
(qvd);

If  not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Gesamtlebensdauer_WE.qvd')) then

Left Join (Reco_Bauteile_WE_1)
LOAD
    GesamtlebensdauerBerechnet,
    GesamtlebensdauerManuell,
    Gesamtlebensdauer,
    WirtschaftseinheitsID,
    _KEY_details
FROM [$(vSourcePath)DS_api_Gesamtlebensdauer_WE.qvd]
(qvd);

If  not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Reco_Details_WE.qvd')) then


Left Join(Reco_Bauteile_WE_1)
LOAD
    Annuitaet,
    AufgeschobeneKosten,
    Budget,
    DauerSanierung,
    EndeSanierung,
    Ende,
    Kommentar,
    Kosten,
    Neuwert,
    Restlebensdauer,
    SanierungBemerkung,
    SanierungPeriode,
    StartSanierung,
    "Start",
    WirtschaftseinheitsID,
    _KEY_components,
    _KEY_details
FROM [$(vSourcePath)DS_api_Reco_Details_WE.qvd]
(qvd);

End if; 
End if; 
End If; 

If  not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Reco_Sanierungen_WE.qvd')) then


Left Join(Reco_Bauteile_WE_1)
LOAD
    Annuitaet,
    AnteilNeuwert,
    AufgeschobeneKosten,
    Basiskosten,
    Bemerkung,
    Budget,
    Eingriffstiefe,
    Enddatum,
    EndeSanierung,
    GebaeudeID,
    Gesamtlebensdauer,
    Kosten,
    Kostenreduktion,
    Neuwert,
    ReferenzNrGebaeude,
    Restlebensdauer,
    SanierungBemerkung,
    SanierungPeriode,
    Sanierungsdauer,
    StartKostenreduktion,
    StartSanierung,
    Startdatum,
    WirtschaftseinheitsID,
    _KEY_content
FROM [$(vSourcePath)DS_api_Reco_Sanierungen_WE.qvd]
(qvd);


If  not Isnull(QvdCreateTime('$(vSourcePath)DS_api_Baujahre_WE.qvd')) then


Left Join(Reco_Bauteile_WE_1)

LOAD
    Baujahr,
    KommentarBaujahr,
    TotaleLebensdauer,
    _KEY_content
FROM [$(vSourcePath)DS_api_Baujahre_WE.qvd]
(qvd);

End if;

End if;

Reco_Bauteile_WE_2:
Load *,
	WirtschaftseinheitsID as %WirtschaftseinheitNr
Resident Reco_Bauteile_WE_1;


Call QvdStore ('Reco_Bauteile_WE_2', '$(vStorePath)', 'RF_MD', 'InstandsetzungenWE', '*', 1);

End if; 



//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_RecoWE = (now() - vStartTime_RecoWE)*86400;
Trace ---------------------------------- Reco WE geladen ----------------------------------;
Trace $(vElapsed_RecoWE);
//********************************************************************************************





///$tab Ende Spezialthemen 6. <<
//*************************************** Ende Zeitmessung ***********************************
Let vElapsed_Spez = (now() - vStartTime_Spez)*86400;
Trace ---------------------------------- Spezialthemen geladen ----------------------------------;
Trace $(vElapsed_Spez);
//********************************************************************************************
///$tab >> 7. Alte 03 Schicht (ALT)
// are 12/11/22: removed, not needed anymore
///$tab >>Ende Timer<<
//*************************************** Ende Zeitmessung ***********************************
Let vElapsed = (now() - vStartTime)*86400;
Trace ---------------------------------- Total Time ----------------------------------;
Trace $(vElapsed);
//********************************************************************************************

///$tab VAR-Cleanup
// cleanup all variables, except for the time-measurement ones to be implemented...
LET vTable = '';
LET vField = '';
LET vBauteile = '';
LET vMinAbrJahr = '';
LET vMaxLeaseDate = '';
LET vMaxMOVerDate = '';
LET vMaxVer = '';
LET vLengthOfField = '';
LET vPeriodLength = '';
LET vFileCompare = '';
LET vnewFileName = '';
LET i = '';
LET j = '';
LET _vStart = '';
LET _vEnd = '';
LET _vNumOfDays = '';
LET vIVM_MinStartDate = '';
LET vAbrBdgField = '';
LET vPFAbrBdgField = '';

LET vMaxDepth = '';
LET vLevel = '';
LET vFields_PlanLevelIDName = '';
LET vFields_PlanLevelID = '';
LET vFields_PlanLevelName = '';
///$tab Datenmodell
// Build the Data-Model in the App

If vKeepDM = '1' Then

Trace ***** Laden der Daten aus dem Datamodel *****;

//Initialisiere Zeitmessung
Let vStartTime  = num(now());

For Each File in Filelist(vStorePath&'*.qvd')
  
  LET vFileCompare = SubField(File, '\', -1);
  If Wildmatch(vFileCompare, '*RF_*') Then
  
   Qualify *;
   Unqualify '%*';
  
   LET vnewFileName = SubField(SubField(vFileCompare, '-', -1), '.', 1);
   
   [$(vnewFileName)]:
   LOAD * From [$(File)] (qvd);
  
   Unqualify *;
  
  End If

Next File


Trace ***** Laden der Daten aus dem Datamodel. Benötigte Zeit in Sekunden: *****;
Let vElapsed = num((now()) - $(vStartTime))*86400;
Trace $(vElapsed);

End If
///$tab LadezeitenAbspeichern
Trace ************************************* Ladezeiten *************************************;
Trace Kontohierarchien: $(vElapsed_KTO);
Trace Kontohierarchy_Custom: $(vElapsed_KtoCustom);
Trace Kontohierarchy_Dim: $(vElapsed_KtoDim);
Trace Kontohierarchy_SIA: $(vElapsed_KtoSIA);
Trace Kontohierarchy_KKV: $(vElapsed_KtoKKV);
Trace Kontohierarchy_OR: $(vElapsed_KtoOR);
Trace Kontohierarchy_KeyFig: $(vElapsed_KtoKeyFig);
Trace Dimensionen: $(vElapsed_DIM);
Trace Dim_Portfolios: $(vElapsed_PF);
Trace Dim_WEVersionen: $(vElapsed_WEVer);
Trace Dim_WEAktuell: $(vElapsed_WEAct);
Trace Dim_WEConcat: $(vElapsed_WEConc);
Trace Dim_KagKomm: $(vKagKomm);
Trace Dim_RevGeo: $(vElapsed_RevGeo);
Trace Dim_WETotal: $(vElapsed_WETotal);
Trace Dim_GrundStueckeVer: $(vElapsed_LandVer);
Trace Dim_GrundStueckeAct: $(vElapsed_LandAct);
Trace Dim_GrundStueckeConc: $(vElapsed_LandConc);
Trace Dim_GrundStueckeTotal: $(vElapsed_LandTotal);
Trace Dim_BuildingTotal: $(vElapsed_BuildingConc);
Trace Dim_RefWertTotal: $(vElapsed_RefWert);
Trace Dim_Projekte: $(vElapsed_Proj);
Trace Dim_Bewertung: $(vElapsed_Bew);
Trace Fact_FaktenTotal: $(vElapsed_FACT);
Trace Fact_BewAbrFakten: $(vElapsed_FACTBewAbr);
Trace Fact_BdgAnpassungen: $(vElapsed_BdgAnpassungen);
Trace Fact_Abrechnungen: $(vElapsed_Abr);
Trace Fact_Buchungen: $(vElapsed_Buchungen);
Trace Fact_Liegenschaftswerte: $(vElapsed_Liegenschaftswerte);
Trace Fact_FinanzwertePF: $(vElapsed_FinanzwertePF);
Trace Fact_CashFlows: $(vElapsed_CF);
Trace Fact_SepFakten: $(vElapsed_SepFact);
Trace Fact_ConcatFakten: $(vElapsed_ConcatFact);
Trace Fact_Bauprojekte: $(vElapsed_Bauprojekte);
Trace Fact_CDProj: $(vElapsed_CDProj);
Trace Fact_Vertraege: $(vElapsed_Vertraege);
Trace Fact_Zahlungen: $(vElapsed_Zahlungen);
Trace Fact_InvPlanning: $(vElapsed_InvPlan);
Trace Fact_InvPlanningWE: $(vElapsed_InvPlanWE);
Trace Fact_Darlehen: $(vElapsed_Darlehen);
Trace Fact_Hypotheken: $(vElapsed_Hypo);
Trace Fact_Schuldbriefe: $(vElapsed_Schuldbrief);
Trace Fact_Rahmenkredite: $(vElapsed_RK);
Trace Fact_IVM_Area_Model: $(vElapsed_IVMAreaModel);
Trace Fact_IVM_Mietverhaeltnisse: $(vElapsed_IVM_Mietverhaeltnisse);
Trace Fact_IVM_Mietobjekte: $(vElapsed_IVM_Mietobjekte);
Trace Fact_IVM_Mietvertraege: $(vElapsed_IVM_Mietvertraege);
Trace Fact_IVM_FlaecheVersionen: $(vElapsed_IVM_FlaecheVersionen);
Trace Fact_IVM_Konditionen: $(vElapsed_IVM_Konditionen);
Trace Fact_IVM_Fakten: $(vElapsed_IVM_Fakten);
Trace Fact_IVM_Bridge: $(vElapsed_IVM_Bridge);
Trace Fact_IVM_Fluktuation: $(vElapsed_IVM_Flukt);
Trace Fact_IVM_Zinszenario: $(vElapsed_IVM_Zinsszenario);
Trace Fact_BridgePrep: $(vElapsed_BridgePrep);
Trace Link_WEBridgePrep: $(vElapsed_WEBridgePrep);
Trace Link_CleanupBridge: $(vElapsed_cleanBridge);
Trace Link_MasterCal: $(vElapsed_Cal);
Trace Link_Geschaeftsjahr: $(vElapsed_GJ);
Trace Link_LinkTable: $(vElapsed_Link);
Trace Link_Total: $(vElapsed_BridgeLink);
// Trace RL_TotalRollup: $(vElapsed_Rollup);
// Trace RL_CustomRollup: $(vElapsed_RollupCust);
// Trace RL_DimRollup: $(vElapsed_RollupDim);
// Trace RL_SIARollup: $(vElapsed_RollupSIA);
// Trace RL_KKVRollup: $(vElapsed_RollupKKV);
// Trace RL_ORRollup: $(vElapsed_RollupOR);
Trace Spez_TotalSpez: $(vElapsed_Spez);
Trace Spez_LSStrategie: $(vElapsed_LSStrat);
Trace Spez_QualProfWE: $(vElapsed_QualProfWE);
Trace Spez_Stakeholders: $(vElapsed_Stakeholders);
Trace Spez_KAGAbweichung: $(vElapsed_KAGAbw);
Trace Spez_Benchmark: $(vElapsed_BenchComp);
Trace Spez_RecoWE: $(vElapsed_RecoWE);
// Trace Dim_AlteDim: $(vElapsed_DimAlt);
// Trace Dim_ALT_MSP: $(vElapsed_Rent);
// Trace Dim_ALT_QPF: $(vElapsed_Qual);
// Trace Dim_ALT_IS: $(vElapsed_IS);
Trace Total_ElapsedTime: $(vElapsed);

Trace **************************************************************************************;

Ladezeiten_all:
NoConcatenate
Load * Inline [
Abschnitt, Zeit
Kontohierarchien, $(vElapsed_KTO)
Kontohierarchy_Custom, $(vElapsed_KtoCustom)
Kontohierarchy_Dim, $(vElapsed_KtoDim)
Kontohierarchy_SIA, $(vElapsed_KtoSIA)
Kontohierarchy_KKV, $(vElapsed_KtoKKV)
Kontohierarchy_OR, $(vElapsed_KtoOR)
Kontohierarchy_KeyFig, $(vElapsed_KtoKeyFig)
Dimensionen, $(vElapsed_DIM)
Dim_Portfolios, $(vElapsed_PF)
Dim_WEVersionen, $(vElapsed_WEVer)
Dim_WEAktuell, $(vElapsed_WEAct)
Dim_WEConcat, $(vElapsed_WEConc)
Dim_KagKomm, $(vKagKomm)
Dim_RevGeo, $(vElapsed_RevGeo)
Dim_WETotal, $(vElapsed_WETotal)
Dim_GrundStueckeVer, $(vElapsed_LandVer)
Dim_GrundStueckeAct, $(vElapsed_LandAct)
Dim_GrundStueckeConc, $(vElapsed_LandConc)
Dim_GrundStueckeTotal, $(vElapsed_LandTotal)
Dim_BuildingTotal, $(vElapsed_BuildingConc)
Dim_RefWertTotal, $(vElapsed_RefWert)
Dim_Projekte, $(vElapsed_Proj)
Dim_Bewertung, $(vElapsed_Bew)
Fact_FaktenTotal, $(vElapsed_FACT)
Fact_BewAbrFakten, $(vElapsed_FACTBewAbr)
Fact_BdgAnpassungen, $(vElapsed_BdgAnpassungen)
Fact_Abrechnungen, $(vElapsed_Abr)
Fact_Buchungen, $(vElapsed_Buchungen)
Fact_Liegenschaftswerte, $(vElapsed_Liegenschaftswerte)
Fact_FinanzwertePF, $(vElapsed_FinanzwertePF);
Fact_CashFlows, $(vElapsed_CF)
Fact_SepFakten, $(vElapsed_SepFact)
Fact_ConcatFakten, $(vElapsed_ConcatFact)
Fact_Bauprojekte, $(vElapsed_Bauprojekte)
Fact_CDProj, $(vElapsed_CDProj)
Fact_Vertraege, $(vElapsed_Vertraege)
Fact_Zahlungen, $(vElapsed_Zahlungen)
Fact_InvPlanning, $(vElapsed_InvPlan)
Fact_InvPlanningWE, $(vElapsed_InvPlanWE)
Fact_Darlehen, $(vElapsed_Darlehen)
Fact_Hypotheken, $(vElapsed_Hypo)
Fact_Schuldbriefe, $(vElapsed_Schuldbrief)
Fact_Rahmenkredite, $(vElapsed_RK)
Fact_IVM_Mietverhaeltnisse, $(vElapsed_IVM_Mietverhaeltnisse)
Fact_IVM_Mietobjekte, $(vElapsed_IVM_Mietobjekte)
Fact_IVM_Mietvertraege, $(vElapsed_IVM_Mietvertraege)
Fact_IVM_FlaecheVersionen, $(vElapsed_IVM_FlaecheVersionen)
Fact_IVM_Konditionen, $(vElapsed_IVM_Konditionen)
Fact_IVM_Fakten, $(vElapsed_IVM_Fakten)
Fact_IVM_Bridge, $(vElapsed_IVM_Bridge)
Fact_IVM_Fluktuation, $(vElapsed_IVM_Flukt)
Fact_IVM_Zinszenario, $(vElapsed_IVM_Zinsszenario)
Fact_BridgeToLink, $(vElapsed_BridgeLink)
Fact_BridgePrep, $(vElapsed_BridgePrep)
Link_WEBridgePrep, $(vElapsed_WEBridgePrep)
Link_MasterCal, $(vElapsed_Cal)
Link_Geschaeftsjahr, $(vElapsed_GJ)
Link_LinkTable, $(vElapsed_Link)
Link_CleanupBridge, $(vElapsed_cleanBridge)
Link_Total, $(vElapsed_BridgeLink)
Spez_TotalSpez, $(vElapsed_Spez)
Spez_LSStrategie, $(vElapsed_LSStrat)
Spez_QualProfWE, $(vElapsed_QualProfWE)
Spez_Stakeholders, $(vElapsed_Stakeholders)
Spez_Benchmark, $(vElapsed_BenchComp)
Spez_RecoWE, $(vElapsed_RecoWE)
Total_ElapsedTime, $(vElapsed)
];

Ladezeiten_ohne_Total:
NoConcatenate
Load * Inline [
Abschnitt, Zeit
Kontohierarchy_Custom, $(vElapsed_KtoCustom)
Kontohierarchy_Dim, $(vElapsed_KtoDim)
Kontohierarchy_SIA, $(vElapsed_KtoSIA)
Kontohierarchy_KKV, $(vElapsed_KtoKKV)
Kontohierarchy_OR, $(vElapsed_KtoOR)
Kontohierarchy_KeyFig, $(vElapsed_KtoKeyFig)
Dim_Portfolios, $(vElapsed_PF)
Dim_WEVersionen, $(vElapsed_WEVer)
Dim_WEAktuell, $(vElapsed_WEAct)
Dim_WEConcat, $(vElapsed_WEConc)
Dim_KagKomm, $(vKagKomm)
Dim_RevGeo, $(vElapsed_RevGeo)
Dim_GrundStueckeVer, $(vElapsed_LandVer)
Dim_GrundStueckeAct, $(vElapsed_LandAct)
Dim_GrundStueckeConc, $(vElapsed_LandConc)
Dim_BuildingTotal, $(vElapsed_BuildingConc)
Dim_RefWertTotal, $(vElapsed_RefWert)
Dim_Projekte, $(vElapsed_Proj)
Dim_Bewertung, $(vElapsed_Bew)
Fact_BdgAnpassungen, $(vElapsed_BdgAnpassungen)
Fact_Abrechnungen, $(vElapsed_Abr)
Fact_Buchungen, $(vElapsed_Buchungen)
Fact_Liegenschaftswerte, $(vElapsed_Liegenschaftswerte)
Fact_FinanzwertePF, $(vElapsed_FinanzwertePF);
Fact_CashFlows, $(vElapsed_CF)
Fact_SepFakten, $(vElapsed_SepFact)
Fact_ConcatFakten, $(vElapsed_ConcatFact)
Fact_CDProj, $(vElapsed_CDProj)
Fact_Vertraege, $(vElapsed_Vertraege)
Fact_Zahlungen, $(vElapsed_Zahlungen)
Fact_InvPlanning, $(vElapsed_InvPlan)
Fact_InvPlanningWE, $(vElapsed_InvPlanWE)
Fact_Hypotheken, $(vElapsed_Hypo)
Fact_Schuldbriefe, $(vElapsed_Schuldbrief)
Fact_Rahmenkredite, $(vElapsed_RK)
Fact_IVM_Mietverhaeltnisse, $(vElapsed_IVM_Mietverhaeltnisse)
Fact_IVM_Mietobjekte, $(vElapsed_IVM_Mietobjekte)
Fact_IVM_Mietvertraege, $(vElapsed_IVM_Mietvertraege)
Fact_IVM_FlaecheVersionen, $(vElapsed_IVM_FlaecheVersionen)
Fact_IVM_Konditionen, $(vElapsed_IVM_Konditionen)
Fact_IVM_Fakten, $(vElapsed_IVM_Fakten)
Fact_IVM_Bridge, $(vElapsed_IVM_Bridge)
Fact_IVM_Fluktuation, $(vElapsed_IVM_Flukt)
Fact_IVM_Zinszenario, $(vElapsed_IVM_Zinsszenario)
Fact_BridgePrep, $(vElapsed_BridgePrep)
Link_WEBridgePrep, $(vElapsed_WEBridgePrep)
Link_MasterCal, $(vElapsed_Cal)
Link_Geschaeftsjahr, $(vElapsed_GJ)
Link_LinkTable, $(vElapsed_Link)
Link_CleanupBridge, $(vElapsed_cleanBridge)
Spez_LSStrategie, $(vElapsed_LSStrat)
Spez_QualProfWE, $(vElapsed_QualProfWE)
Spez_Stakeholders, $(vElapsed_Stakeholders)
Spez_Benchmark, $(vElapsed_BenchComp)
Spez_RecoWE, $(vElapsed_RecoWE)

];

// Store QVD
Call QvdStore ('Ladezeiten_all', '$(vStorePath)', 'temp', 'Ladezeiten_all', '*', 1);
// Store QVD
Call QvdStore ('Ladezeiten_ohne_Total', '$(vStorePath)', 'temp', 'Ladezeiten', '*', 1);
///$tab EXIT
Exit Script;